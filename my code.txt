`admin-dashboard/code2.txt`

```
`code.txt`

```
`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`src/App.jsx`

```javascript
// src/App.jsx

import React, { useState } from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import LoginPage from './LoginPage.jsx';
import Dashboard from './Dashboard.jsx';
import theme from './theme.js';

/**
 * The main App component.
 * It acts as the root of the application, managing authentication state
 * and providing the global MUI theme.
 */
function App() {
  // State to track if the user is logged in. Default is false.
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  // Function to be passed to LoginPage to handle successful login
  const handleLogin = () => {
    setIsLoggedIn(true);
  };

  // Function to be passed to Dashboard to handle logout
  const handleLogout = () => {
    setIsLoggedIn(false);
  };

  return (
    // ThemeProvider applies the custom theme to all descendant components.
    // CssBaseline provides a consistent baseline style across browsers.
    <ThemeProvider theme={theme}>
      <CssBaseline />
      {/* Conditionally render Dashboard or LoginPage based on login state */}
      {isLoggedIn ? (
        <Dashboard onLogout={handleLogout} />
      ) : (
        <LoginPage onLogin={handleLogin} />
      )}
    </ThemeProvider>
  );
}

export default App;

```

`src/Dashboard.jsx`

```javascript
// src/Dashboard.jsx

import React, { useState, useEffect } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Grid, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress,
  Button,
} from "@mui/material";

import { Bloodtype, LocationCity, AddLink, Close } from "@mui/icons-material";

// ✅ Dummy API functions (replace with real API calls)
const fetchPendingPatients = async () =>
  Promise.resolve([
    { id: 1, name: "John Doe", blood_group: "A+", city: "Delhi" },
    { id: 2, name: "Jane Smith", blood_group: "O-", city: "Mumbai" },
  ]);

const fetchActiveEmergencies = async () =>
  Promise.resolve([
    { id: 3, patient_name: "Alex", blood_group: "B+", status: "Urgent" },
    { id: 4, patient_name: "Maria", blood_group: "AB-", status: "Open" },
  ]);

const Dashboard = ({ onLogout }) => {
  const [tabValue, setTabValue] = useState(0);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm")); // <600px
  const isTablet = useMediaQuery(theme.breakpoints.between("sm", "md")); // 600-900px
  const isLaptop = useMediaQuery(theme.breakpoints.between("md", "lg")); // 900-1200px

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      const apiCall = tabValue === 0 ? fetchPendingPatients : fetchActiveEmergencies;
      const result = await apiCall();
      setData(result);
      setLoading(false);
    };
    loadData();
  }, [tabValue]);

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // ✅ Card list for small & medium screens
  const renderCardList = () => (
    <Grid container spacing={2}>
      {data.map((item) => (
        <Grid item xs={12} sm={6} md={4} key={item.id}>
          <Card variant="outlined" sx={{ height: "100%" }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                {tabValue === 0 ? item.name : item.patient_name}
              </Typography>
              <Stack direction="column" spacing={1}>
                <Chip
                  icon={<Bloodtype />}
                  label={`Blood Group: ${item.blood_group}`}
                  size="small"
                />
                {tabValue === 0 ? (
                  <Chip
                    icon={<LocationCity />}
                    label={`City: ${item.city}`}
                    size="small"
                  />
                ) : (
                  <Chip label={`Status: ${item.status}`} color="warning" size="small" />
                )}
              </Stack>
            </CardContent>
            <CardActions sx={{ justifyContent: "flex-end" }}>
              {tabValue === 0 ? (
                <Button variant="contained" size="small" startIcon={<AddLink />}>
                  Create Bridge
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="secondary"
                  size="small"
                  startIcon={<Close />}
                >
                  Close Request
                </Button>
              )}
            </CardActions>
          </Card>
        </Grid>
      ))}
    </Grid>
  );

  // ✅ Table for larger screens (Laptop & Desktop)
  const renderTable = () => (
    <TableContainer>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>{tabValue === 0 ? "Name" : "Patient Name"}</TableCell>
            <TableCell>Blood Group</TableCell>
            <TableCell>{tabValue === 0 ? "City" : "Status"}</TableCell>
            <TableCell align="right">Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {data.map((item) => (
            <TableRow hover key={item.id}>
              <TableCell>{tabValue === 0 ? item.name : item.patient_name}</TableCell>
              <TableCell>
                <Chip
                  label={item.blood_group}
                  color="primary"
                  variant="outlined"
                  size="small"
                />
              </TableCell>
              <TableCell>
                {tabValue === 0 ? (
                  item.city
                ) : (
                  <Chip label={item.status} color="warning" size="small" />
                )}
              </TableCell>
              <TableCell align="right">
                {tabValue === 0 ? (
                  <Button variant="contained" size="small" startIcon={<AddLink />}>
                    Create Bridge
                  </Button>
                ) : (
                  <Button
                    variant="contained"
                    color="secondary"
                    size="small"
                    startIcon={<Close />}
                  >
                    Close Request
                  </Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );

// inside src/Dashboard.jsx — modify the JSX return where Container is used:

  return (
    <Box
      sx={{
        flexGrow: 1,
        backgroundColor: theme.palette.background.default,
        minHeight: "100vh",
      }}
    >
      {/* AppBar stays full width of viewport */}
      <AppBar position="static" sx={{ boxShadow: 1 }}>
        <Toolbar sx={{ px: { xs: 2, md: 4 } }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            🩸 BloodBridge AI
          </Typography>
          <Button color="inherit" onClick={onLogout}>
            Logout
          </Button>
        </Toolbar>
      </AppBar>

      {/* Make container span full width but keep inner content centered with a maxWidth */}
      <Container
        maxWidth={false}
        disableGutters
        sx={{
          px: { xs: 2, md: 4 },
          py: 4,
        }}
      >
        {/* center the page content while allowing it to be fluid on small screens */}
        <Box sx={{ width: "100%", maxWidth: 1100, mx: "auto" }}>
          <Typography variant="h4" gutterBottom>
            Admin Dashboard
          </Typography>

          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Box sx={{ borderBottom: 1, borderColor: "divider", mb: 3 }}>
              <Tabs value={tabValue} onChange={handleTabChange}>
                <Tab label="Pending Patients" />
                <Tab label="Active Emergencies" />
              </Tabs>
            </Box>

            {loading ? (
              <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
                <CircularProgress />
              </Box>
            ) : (
              // responsive decision: cards for small/tablet, table for larger screens
              (isMobile || isTablet) ? renderCardList() : renderTable()
            )}
          </Paper>
        </Box>
      </Container>
    </Box>
  );

};

export default Dashboard;

```

`src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`src/LoginPage.jsx`

```javascript
// src/LoginPage.jsx

import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert } from '@mui/material';

/**
 * The LoginPage component.
 * It displays a simple login form and validates the password.
 * On successful validation, it calls the onLogin prop function.
 */
const LoginPage = ({ onLogin }) => {
  // State to hold the password input value
  const [password, setPassword] = useState('');
  // State to hold any login error messages
  const [error, setError] = useState('');

  // Handles the form submission
  const handleSubmit = (event) => {
    event.preventDefault(); // Prevent default form submission behavior

    // Simple validation: check if the password is "admin"
    if (password === 'admin') {
      setError(''); // Clear any previous errors
      onLogin(); // Call the parent component's login handler
    } else {
      // Set an error message for incorrect password
      setError('Incorrect password. Hint: try "admin"');
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Typography component="h1" variant="h5">
          🩸 BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {/* Display an error alert if the error state is not empty */}
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2 }}
          >
            Sign In
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;   

```

`src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

// It's good practice to have a minimal CSS reset or base styles.
// You can leave the default index.css or make it an empty file for now.
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

`src/mockApi.js`

```javascript
// src/mockApi.js

/**
 * This file acts as a fake backend API.
 * The functions here simulate network requests by returning a Promise
 * that resolves with mock data after a 500ms delay.
 */

// Mock data for the "Pending Patients" tab
const mockPendingPatients = [
  { "id": "p1", "name": "Aarav Sharma", "blood_group": "A+", "city": "Delhi" },
  { "id": "p2", "name": "Saanvi Gupta", "blood_group": "O-", "city": "Mumbai" },
  { "id": "p3", "name": "Vihaan Reddy", "blood_group": "B+", "city": "Bangalore" },
  { "id": "p4", "name": "Diya Singh", "blood_group": "AB-", "city": "Kolkata" }
];

// Mock data for the "Active Emergencies" tab
const mockActiveEmergencies = [
  { "id": "e1", "patient_name": "Isha Patel", "blood_group": "AB+", "status": "Searching" },
  { "id": "e2", "patient_name": "Rohan Kumar", "blood_group": "O+", "status": "Partially Fulfilled" },
  { "id": "e3", "patient_name": "Ananya Joshi", "blood_group": "A-", "status": "Critical" }
];

/**
 * Fetches a list of pending patients.
 * @returns {Promise<Array<Object>>} A promise that resolves to the patient list.
 */
export const fetchPendingPatients = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockPendingPatients);
    }, 500); // 500ms delay to simulate network latency
  });
};

/**
 * Fetches a list of active emergencies.
 * @returns {Promise<Array<Object>>} A promise that resolves to the emergencies list.
 */
export const fetchActiveEmergencies = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockActiveEmergencies);
    }, 500); // 500ms delay to simulate network latency
  });
};

```

`src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

```

`admin-dashboard/eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`admin-dashboard/index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`admin-dashboard/src/api/apiClient.js`

```javascript
// src/api/apiClient.js
import axios from 'axios';

const BASE = (import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001').replace(/\/$/, '');

const apiClient = axios.create({
  baseURL: BASE,
  headers: { 'Content-Type': 'application/json' },
  timeout: 20000,
});

// simple map to avoid spamming same error repeatedly
const loggedUrls = new Set();

apiClient.interceptors.request.use((config) => {
  const url = config.url || '';
  // attach token for everything except login/register
  if (!url.includes('/login') && !url.includes('/register')) {
    const token = localStorage.getItem('token');
    if (token && typeof token === 'string' && token.split('.').length === 3) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }
  return config;
});

apiClient.interceptors.response.use(
  (res) => res,
  (err) => {
    const out = {
      url: err.config?.url,
      status: err.response?.status,
      message: err.message,
      data: err.response?.data,
    };

    // Log each failing URL once to reduce noise
    if (!loggedUrls.has(out.url)) {
      loggedUrls.add(out.url);
      console.error('API request failed:', out);
    }

    const normalized = new Error(out.message || 'API error');
    normalized.url = out.url;
    normalized.status = out.status;
    normalized.data = out.data;
    return Promise.reject(normalized);
  }
);

export default apiClient;

```

`admin-dashboard/src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`admin-dashboard/src/App.jsx`

```javascript
// admin-dashboard/src/App.jsx
import React from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import { AuthProvider } from './context/AuthContext.jsx';
import { Routes, Route, Navigate } from 'react-router-dom'; // ✅ IMPORT ROUTER COMPONENTS
import theme from './theme.js';
import LoginPage from './pages/LoginPage.jsx';
import DashboardPage from './pages/Dashboard.jsx';
import { useAuth } from './hooks/useAuth.js';

/**
 * A protected route component. If the user is not logged in,
 * it redirects them to the login page.
 */
const ProtectedRoute = ({ children }) => {
  const { isLoggedIn } = useAuth();
  return isLoggedIn ? children : <Navigate to="/" />;
};

/**
 * The main App component, now with a proper routing structure.
 */
function App() {
  return (
    <AuthProvider>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <Routes>
          <Route path="/" element={<LoginPage />} />
          <Route 
            path="/dashboard" 
            element={
              <ProtectedRoute>
                <DashboardPage />
              </ProtectedRoute>
            } 
          />
        </Routes>
      </ThemeProvider>
    </AuthProvider>
  );
}

export default App;

```

`admin-dashboard/src/components/common/ConfirmationDialog.jsx`

```javascript
// src/components/common/ConfirmationDialog.jsx
import React, { useState, useCallback } from 'react';
import PropTypes from 'prop-types';
import {
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from '@mui/material';

/**
 * Reusable confirmation dialog.
 * - Awaits async onConfirm handlers before closing.
 * - Disables buttons while processing to avoid duplicate calls.
 */
const ConfirmationDialog = ({ open, onClose, onConfirm, title, message, confirmText = 'Confirm', cancelText = 'Cancel' }) => {
  const [processing, setProcessing] = useState(false);

  const handleConfirm = useCallback(async () => {
    if (processing) return;
    setProcessing(true);
    try {
      if (typeof onConfirm === 'function') {
        // Call handler and await if it returns a promise
        const result = onConfirm();
        if (result && typeof result.then === 'function') {
          await result;
        }
      }
    } catch (err) {
      // Log — parent can set error state if needed
      // Avoid swallowing errors silently in prod; you may surface this to UI
      // eslint-disable-next-line no-console
      console.error('ConfirmationDialog onConfirm error:', err);
    } finally {
      setProcessing(false);
      if (typeof onClose === 'function') onClose();
    }
  }, [onConfirm, onClose, processing]);

  return (
    <Dialog
      open={Boolean(open)}
      onClose={() => {
        if (!processing && typeof onClose === 'function') onClose();
      }}
      aria-labelledby="confirmation-dialog-title"
      aria-describedby="confirmation-dialog-description"
      fullWidth
      maxWidth="xs"
    >
      <DialogTitle id="confirmation-dialog-title">{title}</DialogTitle>
      <DialogContent>
        <DialogContentText id="confirmation-dialog-description">
          {message}
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={() => { if (!processing && typeof onClose === 'function') onClose(); }} disabled={processing}>
          {cancelText}
        </Button>

        <Button
          onClick={handleConfirm}
          color="primary"
          variant="contained"
          autoFocus
          disabled={processing}
        >
          {confirmText}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

ConfirmationDialog.propTypes = {
  open: PropTypes.bool,
  onClose: PropTypes.func,
  onConfirm: PropTypes.func,
  title: PropTypes.string,
  message: PropTypes.string,
  confirmText: PropTypes.string,
  cancelText: PropTypes.string,
};

ConfirmationDialog.defaultProps = {
  open: false,
  onClose: () => {},
  onConfirm: null,
  title: 'Confirm',
  message: '',
  confirmText: 'Confirm',
  cancelText: 'Cancel',
};

export default React.memo(ConfirmationDialog);

```

`admin-dashboard/src/components/dashboard/BloodGroupChart.jsx`

```javascript
// src/components/dashboard/BloodGroupChart.jsx
import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
} from 'recharts';
import { Box, Typography, useTheme } from '@mui/material';

/**
 * A responsive bar chart to display blood group distribution.
 * Expects data shape: [{ blood_group: 'A+', count: 10 }, ...]
 */
const BloodGroupChart = ({ data }) => {
  const theme = useTheme();

  // Defensive: normalize/sort data so chart is stable
  const prepared = useMemo(() => {
    if (!Array.isArray(data)) return [];
    // ensure numeric counts and stable ordering (by blood_group)
    return [...data]
      .map((d) => ({ blood_group: d.blood_group ?? 'Unknown', count: Number(d.count) || 0 }))
      .sort((a, b) => {
        // you can sort by count desc: return b.count - a.count;
        // here we sort by blood_group for predictable axis order
        return a.blood_group.localeCompare(b.blood_group);
      });
  }, [data]);

  if (!prepared || prepared.length === 0) {
    return (
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: 300 }}>
        <Typography color="text.secondary">No chart data available.</Typography>
      </Box>
    );
  }

  return (
    // aria-label helps screen readers understand this visual
    <Box role="img" aria-label="Donor distribution by blood group">
      <ResponsiveContainer width="100%" height={300}>
        <BarChart
          data={prepared}
          margin={{ top: 6, right: 16, left: -12, bottom: 6 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke={theme.palette.divider} />
          <XAxis dataKey="blood_group" stroke={theme.palette.text.secondary} />
          <YAxis stroke={theme.palette.text.secondary} allowDecimals={false} />
          <Tooltip
            contentStyle={{
              backgroundColor: theme.palette.background.paper,
              borderColor: theme.palette.divider,
            }}
            formatter={(value) => [value, 'Donors']}
          />
          <Legend />
          <Bar dataKey="count" name="Total Donors" fill={theme.palette.primary.main} />
        </BarChart>
      </ResponsiveContainer>
    </Box>
  );
};

BloodGroupChart.propTypes = {
  data: PropTypes.arrayOf(
    PropTypes.shape({
      blood_group: PropTypes.string,
      count: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    })
  ),
};

BloodGroupChart.defaultProps = {
  data: [],
};

export default React.memo(BloodGroupChart);

```

`admin-dashboard/src/components/dashboard/StatCard.jsx`

```javascript
// src/components/dashboard/StatCard.jsx
import React from "react";
import PropTypes from "prop-types";
import { Paper, Box, Typography, Avatar, useTheme } from "@mui/material";

/**
 * A reusable component to display a single dashboard statistic.
 *
 * Props:
 * - icon: React node shown inside the Avatar
 * - title: short label for the stat
 * - value: numeric or string value to display
 * - color: theme token or CSS color for Avatar background (e.g. "primary.main")
 */
const StatCard = ({ icon, title, value, color = "primary.main" }) => {
  const theme = useTheme();

  // Resolve theme token like "primary.main" to an actual color string
  const resolvedColor = (() => {
    if (!color) return undefined;
    // if color contains a dot, treat as theme token
    if (typeof color === "string" && color.includes(".")) {
      const [paletteKey, shade] = color.split(".");
      return theme.palette?.[paletteKey]?.[shade] ?? color;
    }
    return color;
  })();

  // Format numbers nicely (1000 -> 1,000)
  const formattedValue =
    typeof value === "number"
      ? new Intl.NumberFormat().format(value)
      : value ?? "—";

  return (
    <Paper
      elevation={3}
      sx={{
        p: 2,
        display: "flex",
        alignItems: "center",
        height: "100%",
      }}
      role="region"
      aria-label={`${title} stat`}
      title={`${title}: ${formattedValue}`}
    >
      <Avatar
        sx={{
          bgcolor: resolvedColor,
          width: 56,
          height: 56,
          mr: 2,
          color: (theme.palette.getContrastText
            ? theme.palette.getContrastText(resolvedColor)
            : "#fff"),
        }}
        aria-hidden="true"
      >
        {icon}
      </Avatar>

      <Box sx={{ minWidth: 0 }}>
        <Typography color="text.secondary" noWrap variant="caption">
          {title}
        </Typography>
        <Typography variant="h5" component="div" fontWeight="bold" noWrap>
          {formattedValue}
        </Typography>
      </Box>
    </Paper>
  );
};

StatCard.propTypes = {
  icon: PropTypes.node,
  title: PropTypes.string.isRequired,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  color: PropTypes.string,
};

StatCard.defaultProps = {
  icon: null,
  value: "0",
  color: "primary.main",
};

export default React.memo(StatCard);

```

`admin-dashboard/src/context/AuthContext.jsx`

```javascript
// src/context/AuthContext.jsx
import React, { createContext, useState } from 'react';

// 1. Create the context
// This object will be used by other components to access the auth state.
export const AuthContext = createContext(null);

// 2. Create the Provider component
// This component will wrap our application and provide the auth state.
export const AuthProvider = ({ children }) => {
  // Initialize the token state by reading from localStorage.
  // This ensures that the user remains logged in even after a page refresh.
  const [token, setToken] = useState(localStorage.getItem('token'));

  // The login function saves the token to both localStorage and the state.
  const login = (newToken) => {
    localStorage.setItem('token', newToken);
    setToken(newToken);
  };

  // The logout function removes the token from localStorage and the state.
  const logout = () => {
    localStorage.removeItem('token');
    setToken(null);
  };

  // 3. Define the value to be provided by the context
  // We derive `isLoggedIn` directly from the presence of a token.
  const value = {
    token,
    isLoggedIn: !!token,
    login,
    logout,
  };

  // 4. Return the provider with the value, wrapping any child components.
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

```

`admin-dashboard/src/hooks/useAuth.js`

```javascript
// src/hooks/useAuth.js
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext.jsx';

/**
 * A custom hook for accessing the AuthContext.
 * This simplifies the process in any component that needs auth data,
 * as we can just call `useAuth()` instead of `useContext(AuthContext)`.
 */
export const useAuth = () => {
  return useContext(AuthContext);
};

```

`admin-dashboard/src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`admin-dashboard/src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom'; // <-- 1. IMPORT THE ROUTER
import App from './App.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    {/* 2. WRAP YOUR APP WITH THE ROUTER */}
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

```

`admin-dashboard/src/pages/Dashboard.jsx`

```javascript
// admin-dashboard/src/pages/Dashboard.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress, Button, Alert,
  Badge, Grid, Snackbar
} from "@mui/material";
import {
  Bloodtype, LocationCity, AddLink, Close, Logout,
  PeopleAlt, Favorite, Healing, Warning,
  Dashboard as DashboardIcon, Inbox as InboxIcon,
  People as PeopleIcon, Emergency as EmergencyIcon,
  Hub as HubIcon, ShowChart as ShowChartIcon,
  CheckCircleOutline as CheckCircleOutlineIcon,
  NotificationImportant as EscalationIcon,
  AddCircleOutline as AddCircleOutlineIcon
} from "@mui/icons-material";
import { createClient } from '@supabase/supabase-js';

import { useAuth } from "../hooks/useAuth.js";
import apiClient from "../api/apiClient.js";
import StatCard from "../components/dashboard/StatCard.jsx";
import BloodGroupChart from "../components/dashboard/BloodGroupChart.jsx";
import ConfirmationDialog from "../components/common/ConfirmationDialog.jsx";

// --- INITIALIZE SUPABASE CLIENT ---
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseAnonKey);

const normalizeList = (res) => {
  if (!res) return [];
  if (Array.isArray(res)) return res;
  const d = res.data;
  if (Array.isArray(d)) return d;
  if (d && Array.isArray(d.data)) return d.data;
  return [];
};

const TabPanel = ({ children, value, index, ...other }) => (
  <div role="tabpanel" hidden={value !== index} {...other}>
    {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
  </div>
);

const getDueDateInfo = (dueDate) => {
  if (!dueDate) return { text: 'N/A', color: 'text.secondary', days: Infinity };
  const today = new Date();
  const nextDate = new Date(dueDate);
  today.setHours(0, 0, 0, 0);
  nextDate.setHours(0, 0, 0, 0);
  const diffTime = nextDate - today;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays < 0) return { text: `OVERDUE by ${Math.abs(diffDays)} days`, color: 'error.main', days: diffDays };
  if (diffDays === 0) return { text: 'DUE TODAY', color: 'error.main', days: diffDays };
  if (diffDays <= 7) return { text: `Due in ${diffDays} days`, color: 'warning.main', days: diffDays };
  return { text: `Due in ${diffDays} days`, color: 'text.primary', days: diffDays };
};

const DashboardPage = () => {
  const { logout } = useAuth();
  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down("md"));
  const [currentTab, setCurrentTab] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [snackbar, setSnackbar] = useState({ open: false, message: '' });
  const [dialogConfig, setDialogConfig] = useState({ open: false, title: '', message: '', onConfirm: () => {} });

  const [stats, setStats] = useState({});
  const [bloodGroupData, setBloodGroupData] = useState([]);
  const [inboxMessages, setInboxMessages] = useState([]);
  const [pendingPatients, setPendingPatients] = useState([]);
  const [monitoredPatients, setMonitoredPatients] = useState([]);
  const [emergencies, setEmergencies] = useState([]);
  const [bridges, setBridges] = useState([]);
  const [leaderboard, setLeaderboard] = useState([]);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError('');
    try {
      const [
        statsRes, 
        bloodGroupRes, 
        patientsRes, 
        emergenciesRes, 
        bridgesRes, 
        inboxRes,
        leaderboardRes
      ] = await Promise.all([
        apiClient.get('/api/admin/stats'),
        apiClient.get('/api/admin/stats/blood-groups'),
        apiClient.get('/api/admin/patients'),
        apiClient.get('/api/admin/emergencies'),
        apiClient.get('/api/admin/bridges'),
        apiClient.get('/api/admin/inbox'),
        apiClient.get('/api/admin/leaderboard')
      ]);

      setStats(statsRes.data || {});
      setBloodGroupData(bloodGroupRes.data || []);
      setEmergencies(normalizeList(emergenciesRes));
      setBridges(normalizeList(bridgesRes));
      setInboxMessages(normalizeList(inboxRes));
      setLeaderboard(normalizeList(leaderboardRes));

      const allPatients = normalizeList(patientsRes);
      const PENDING_STATUSES = ['pending', 'pending_opt_in', 'pending_details', 'pending_verification'];
      setPendingPatients(allPatients.filter(p => PENDING_STATUSES.includes(p.status)));
      
      const bridged = allPatients.filter(p => p.status === 'bridged');
      bridged.sort((a, b) => getDueDateInfo(a.next_due_date).days - getDueDateInfo(b.next_due_date).days);
      setMonitoredPatients(bridged);
    } catch (err) {
      setError('Failed to fetch data. Your session may have expired.');
      if (err.response && err.response.status === 401) logout();
    } finally {
      setLoading(false);
    }
  }, [logout]);

  useEffect(() => {
    fetchData();
    if (supabaseUrl && supabaseAnonKey) {
      const channel = supabase.channel('public-db-changes')
        .on('postgres_changes', { event: '*', schema: 'public' }, () => {
          console.log('Real-time change detected, refetching data...');
          fetchData();
        })
        .subscribe();
      
      return () => { supabase.removeChannel(channel); };
    }
  }, [fetchData]);

  const handleApiAction = async (action, successMessage) => {
    try {
      const response = await action();
      setSnackbar({ open: true, message: response.data.message || successMessage });
      fetchData();
    } catch (err) {
      setSnackbar({ open: true, message: err.response?.data?.error || 'Action failed!' });
    }
    setDialogConfig({ ...dialogConfig, open: false });
  };

  const confirmAction = (title, message, action, successMessage) => {
    setDialogConfig({ open: true, title, message, onConfirm: () => handleApiAction(action, successMessage) });
  };

  const renderLeaderboard = () => {
    if (loading && leaderboard.length === 0) {
      return <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}><CircularProgress /></Box>;
    }
    if (!leaderboard || leaderboard.length === 0) {
      return <Typography sx={{ p: 3, textAlign: 'center', height: '100%' }}>No donor data for leaderboard.</Typography>;
    }
    return (
      <TableContainer>
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell>Rank</TableCell>
              <TableCell>Name</TableCell>
              <TableCell align="right">Points</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {leaderboard.map((donor, index) => (
              <TableRow key={index}>
                <TableCell>{index + 1}</TableCell>
                <TableCell>{donor.name}</TableCell>
                <TableCell align="right">{donor.gamification_points}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  const renderDuePatientsAlert = () => {
    const duePatients = monitoredPatients.filter(p => getDueDateInfo(p.next_due_date).days <= 7);
    
    if (duePatients.length === 0) return null;
    
    return (
      <Paper elevation={3} sx={{ p: { xs: 2, md: 3 }, mb: 4, border: 2, borderColor: 'error.main' }}>
        <Typography variant="h6" color="error.main" gutterBottom>
          Action Required: Patients Due for Transfusion
        </Typography>
        <TableContainer>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Name</TableCell>
                <TableCell>Due Date</TableCell>
                <TableCell>Status</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {duePatients.map((p) => {
                const dueInfo = getDueDateInfo(p.next_due_date);
                return (
                  <TableRow key={p.id} hover>
                    <TableCell>{p.name}</TableCell>
                    <TableCell>{p.next_due_date ? new Date(p.next_due_date).toLocaleDateString() : 'N/A'}</TableCell>
                    <TableCell sx={{ color: dueInfo.color }}>{dueInfo.text}</TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
    );
  };

  const renderTabContent = () => {
    switch (currentTab) {
      case 0: // Analytics
        return (
          <Grid container spacing={3} sx={{ mt: 1 }}>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<PeopleIcon />} title="Total Donors" value={stats.total_donors} />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Favorite />} title="Active & Eligible" value={stats.active_donors} color="success.main" />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Warning />} title="Patients Due Soon" value={stats.patients_at_risk} color="warning.main" />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Healing />} title="Pending Patients" value={stats.pending_patients} color="info.main" />
            </Grid>
            
            <Grid item sx={{ width: { xs: '100%', lg: '66%' } }}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>Donor Blood Groups</Typography>
                <Box sx={{ height: 320 }}>
                  <BloodGroupChart data={bloodGroupData} />
                </Box>
              </Paper>
            </Grid>
            <Grid item sx={{ width: { xs: '100%', lg: '34%' } }}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>Top Donors Leaderboard</Typography>
                {renderLeaderboard()}
              </Paper>
            </Grid>
          </Grid>
        );
      
      case 1: // Inbox
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>User Phone</TableCell>
                  <TableCell>Message</TableCell>
                  <TableCell>Reason</TableCell>
                  <TableCell align="right">Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {inboxMessages.map((msg) => (
                  <TableRow key={msg.id}>
                    <TableCell>{msg.user_phone}</TableCell>
                    <TableCell>{msg.user_message}</TableCell>
                    <TableCell><Chip label={msg.reason} color="warning" size="small" /></TableCell>
                    <TableCell align="right">
                      <Button 
                        onClick={() => confirmAction(
                          'Confirm Resolution', 
                          `Mark message from ${msg.user_phone} as resolved?`, 
                          () => apiClient.post(`/api/admin/inbox/${msg.id}/resolve`), 
                          'Message Resolved!'
                        )} 
                        startIcon={<CheckCircleOutlineIcon />}
                      >
                        Resolve
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 2: // Pending Patients
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Name</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {pendingPatients.map((p) => (
                  <TableRow key={p.id}>
                    <TableCell>{p.name}</TableCell>
                    <TableCell><Chip label={p.status} size="small" /></TableCell>
                    <TableCell>
                      <Button 
                        onClick={() => confirmAction(
                          'Confirm Bridge Creation', 
                          `Create a bridge for ${p.name}?`, 
                          () => apiClient.post(`/api/admin/patients/${p.id}/create-bridge`), 
                          'Bridge Created!'
                        )} 
                        startIcon={<AddCircleOutlineIcon />}
                      >
                        Create Bridge
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 3: // Patient Monitor
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Patient Name</TableCell>
                  <TableCell>Next Transfusion</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {monitoredPatients.map((p) => { 
                  const ddi = getDueDateInfo(p.next_due_date); 
                  return (
                    <TableRow key={p.id} sx={{ backgroundColor: ddi.days < 0 ? 'rgba(255, 0, 0, 0.1)' : 'transparent' }}>
                      <TableCell>{p.name}</TableCell>
                      <TableCell sx={{ color: ddi.color }}>{ddi.text}</TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 4: // Active Emergencies
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Patient</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {emergencies.map((req) => (
                  <TableRow key={req.id}>
                    <TableCell>{req.patient_name}</TableCell>
                    <TableCell>{req.status}</TableCell>
                    <TableCell>
                      <Stack direction="row" spacing={1}>
                        <Button 
                          size="small" 
                          onClick={() => confirmAction(
                            'Confirm Closure', 
                            `Close request for ${req.patient_name}?`, 
                            () => apiClient.post(`/api/admin/emergencies/${req.id}/close`), 
                            'Request Closed!'
                          )} 
                          startIcon={<Close />}
                        >
                          Close
                        </Button>
                        <Button 
                          size="small" 
                          color="warning" 
                          onClick={() => confirmAction(
                            'Confirm Escalation', 
                            `Escalate request for ${req.patient_name}?`, 
                            () => apiClient.post(`/api/admin/emergencies/${req.id}/escalate`), 
                            'Escalation Initiated!'
                          )} 
                          startIcon={<EscalationIcon />}
                        >
                          Escalate
                        </Button>
                      </Stack>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 5: // Bridge Monitor
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Bridge Name</TableCell>
                  <TableCell>Patient</TableCell>
                  <TableCell>Members</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {bridges.map((b) => (
                  <TableRow key={b.id}>
                    <TableCell>{b.name}</TableCell>
                    <TableCell>{b.patient_name}</TableCell>
                    <TableCell>{b.member_count}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      default:
        return <div>Select a tab</div>;
    }
  };

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', bgcolor: 'background.default' }}>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>🩸 BloodBridge AI Dashboard</Typography>
          <Button color="inherit" onClick={logout} startIcon={<Logout />}>Logout</Button>
        </Toolbar>
      </AppBar>

      <Container maxWidth="xl" sx={{ mt: 2, mb: 4, flexGrow: 1, overflowY: 'auto' }}>
        {renderDuePatientsAlert()}
        
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        <Paper sx={{ p: 2 }}>
          <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
            <Tabs 
              value={currentTab} 
              onChange={(e, val) => setCurrentTab(val)} 
              variant="scrollable" 
              scrollButtons="auto"
            >
              <Tab icon={<ShowChartIcon />} label="Analytics" />
              <Tab icon={<InboxIcon />} label={
                <Badge badgeContent={inboxMessages.length} color="error">
                  Inbox
                </Badge>
              } />
              <Tab icon={<PeopleIcon />} label={
                <Badge badgeContent={pendingPatients.length} color="primary">
                  Pending Patients
                </Badge>
              } />
              <Tab icon={<PeopleIcon />} label="Patient Monitor" />
              <Tab icon={<EmergencyIcon />} label="Active Emergencies" />
              <Tab icon={<HubIcon />} label="Bridge Monitor" />
            </Tabs>
          </Box>

          {loading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
              <CircularProgress />
            </Box>
          ) : (
            renderTabContent()
          )}
        </Paper>
      </Container>

      <ConfirmationDialog 
        {...dialogConfig} 
        onClose={() => setDialogConfig({ ...dialogConfig, open: false })} 
      />
      
      <Snackbar 
        open={snackbar.open} 
        autoHideDuration={6000} 
        onClose={() => setSnackbar({ ...snackbar, open: false })} 
        message={snackbar.message} 
      />
    </Box>
  );
};

export default DashboardPage;

```

`admin-dashboard/src/pages/LoginPage.jsx`

```javascript
// admin-dashboard/src/pages/LoginPage.jsx
import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert, CircularProgress } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth.js';
import apiClient from '../api/apiClient.js';

const LoginPage = () => {
  const { login } = useAuth();
  const navigate = useNavigate();

  // --- MODIFICATION: Hardcode the phone number for the demo user ---
  // We no longer need a state for the phone number.
  const phone = '+918000000000';
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleLogin = async (event) => {
    event.preventDefault();
    setError('');
    
    // Simple password validation
    if (!password) {
        setError('Password is required.');
        return;
    }

    setLoading(true);
    try {
      // The component now sends the hardcoded phone number and the entered password.
      console.log('Attempting login with:', { phone, password });
      const response = await apiClient.post('/api/admin/login', { phone, password });

      if (response.data?.token) {
        console.log('Login successful, token:', response.data.token);
        // Using localStorage to persist the token across browser sessions.
        localStorage.setItem('token', response.data.token);
        login(response.data.token);
        navigate('/dashboard');
      } else {
        // This case is unlikely if the backend is structured correctly, but good to have.
        setError('Login failed: No token received from server.');
      }
    } catch (err) {
      console.error('Login error:', {
        message: err.message,
        status: err.response?.status,
        data: err.response?.data,
      });

      // Provide more specific feedback to the user.
      if (err.response?.status === 401) {
        setError('Invalid password. Hint: try "admin123"');
      } else if (err.code === 'ECONNABORTED' || !err.response) {
        setError('Cannot connect to the server. Please ensure it is running.');
      } else {
        setError(err.response?.data?.message || 'An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box sx={{ mt: 8, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Typography component="h1" variant="h5">
          🩸 BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleLogin} sx={{ mt: 3, width: '100%' }}>
          {/* --- MODIFICATION: The phone number input field has been removed --- */}
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="current-password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            disabled={loading}
            sx={{ mt: 3, mb: 2 }}
          >
            {loading ? <CircularProgress size={24} color="inherit" /> : 'Sign In'}
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;

```

`admin-dashboard/src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`admin-dashboard/vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

`backend/.env`

```
# ----------------------------------
# SERVER CONFIGURATION
# ----------------------------------
PORT=3001

# ----------------------------------
# SECURITY
# ----------------------------------
# Generate a new random string from https://www.uuidgenerator.net/ and paste it here
JWT_SECRET="eb4db4a414678902613083784a04ec9de45570856d8ced1dbe6fdd4a545ff715"

# ----------------------------------
# DATABASE (CONNECTION POOLER)
# ----------------------------------
# Replace the ENTIRE line below with your Connection Pooler URI from Supabase
DATABASE_URL="postgresql://postgres.psussvygzgzkkwdjqbwp:asdfusahdfuu3842r7gdsfh@aws-1-ap-southeast-1.pooler.supabase.com:6543/postgres"

# ----------------------------------
# THIRD-PARTY APIs
# ----------------------------------
# Paste your Gemini API key from Google AI Studio
GEMINI_API_KEY="AIzaSyBvD9N56Z5PWeVZHSHNPKkYM3A1JlhO09w"

# For the local Python service
ML_SERVICE_URL="http://localhost:8000"

# ----------------------------------
# WHATSAPP (FROM YOUR META APP)
# ----------------------------------
# Paste your own credentials from your Meta for Developers App
WHATSAPP_TOKEN="EAAY5EGe8MHkBPWtYv6S5oJtPBWCXNu6Ym4sZCadC7c4uONUhsQ4ZAAlEwKMcIyAGowxW64NrWfPpKF7zi3Xd8VQSAQA3tEV1ao5pqwLB2z7aSRnUo5ZCyQQXpsz87ZA6DpbgyX8i2Mk7CVIUZAneZCAfQusHLjLEofU0Szu7PWZAqALCSL7Dss3Fov6Pcwgtj5XAbk3MCmmZAXa7OxZAPqiZBsW3ssAN5Dk9rC8AYhhbbWkwZDZD"
WHATSAPP_PHONE_NUMBER_ID="729824143554882"
WHATSAPP_APP_SECRET="e94bd0c1a5619ee68b105222b0185dc6"
WHATSAPP_VERIFY_TOKEN="inquilab_bloodai-123-2025-hackathon"

# ----------------------------------
# DEMO & ADMIN
# ----------------------------------
ADMIN_DEMO_PHONE="+918000000000"
DEMO_VERIFIED_PHONE_NUMBERS=""


```

`backend/server.js`

```javascript
// backend/server.js

// Import required dependencies
import express from 'express'; // Express framework for building the server
import cors from 'cors'; // Middleware for enabling CORS
import morgan from 'morgan'; // Middleware for request logging
import config from './src/config/config.js'; // Configuration settings
import adminRoutes from './src/routes/adminRoutes.js'; // Admin dashboard routes
import { verifyWebhook } from './src/middleware/verifyWebhook.js'; // Webhook signature verification
import webhookController from './src/controllers/webhookController.js'; // Webhook handling controller
import BridgeCoordinationService from './src/services/bridgeCoordinationService.js';

// --- PHASE 1: PREDICTIVE ENGAGEMENT ---
import cron from 'node-cron'; // Import the cron scheduler library
import EngagementService from './src/services/engagementService.js'; // Import our new engagement service
// --- END PHASE 1 ---

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3001; // Use environment PORT or default to 3001

// Middleware setup
app.use(cors()); // Enable CORS for all routes
app.use(morgan('tiny')); // Log HTTP requests in 'tiny' format

// API and Health Routes
app.get('/health', (req, res) => {
  // Health check endpoint to verify server status
  res.status(200).json({ status: 'healthy', now: new Date().toISOString() });
});

// Admin routes with JSON body parser
app.use('/api/admin', express.json({ limit: '1mb' }), adminRoutes);

// Webhook Routes
app.get('/webhook', webhookController.verifyToken); // Handle Meta webhook verification (GET)

app.post(
  '/webhook',
  express.json({
    verify: (req, res, buf) => {
req.rawBody = buf.toString();     }
  }),
  verifyWebhook, // This middleware will now use req.rawBody
  webhookController.handleMessage // This controller will use the parsed req.body
);

// Global Error Handling
app.use((err, req, res, next) => {
  // Handle errors from middleware or routes
  console.error('[ERROR HANDLER]', err.stack);
  res.status(500).json({ message: 'An internal server error occurred.' });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason) => {
  console.error('Unhandled Rejection:', reason);
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
});


// --- PHASE 1: PREDICTIVE ENGAGEMENT SCHEDULER ---
// This task is scheduled to run at 9:00 AM every day in the Asia/Kolkata timezone.
// It will automatically find donors who are now eligible to donate again and send them a reminder.
console.log('🕒 Cron job for eligibility reminders scheduled to run every day at 9:00 AM.');
cron.schedule('0 9 * * *', () => {
  console.log('⏰ It is 9:00 AM. Triggering the eligibility reminder cron job...');
  // We create a new instance to ensure it's a fresh run
  const engagementService = new EngagementService();
  engagementService.sendEligibilityReminders();
}, {
  scheduled: true,
  timezone: "Asia/Kolkata" // IMPORTANT: Set to your target timezone
});

console.log('🕒 Cron job for automatic bridge requests scheduled to run every day at 8:00 AM.');
cron.schedule('0 8 * * *', () => {
  console.log('⏰ It is 8:00 AM. Triggering automatic bridge requests...');
  const bridgeService = new BridgeCoordinationService();
  bridgeService.triggerAutomaticBridgeRequests();
}, {
  scheduled: true,
  timezone: "Asia/Kolkata"
});

// '0 10 * * 0' means at minute 0, hour 10, on day-of-week 0 (Sunday).
console.log('🕒 Cron job for inactive donor nudges scheduled to run every Sunday at 10:00 AM.');
cron.schedule('0 10 * * 0', () => {
    console.log('⏰ It is Sunday 10:00 AM. Triggering inactive donor nudge...');
    const engagementService = new EngagementService();
    engagementService.sendInactiveDonorNudges();
}, {
    scheduled: true,
    timezone: "Asia/Kolkata"
});
// --- END PHASE 1 ---


// Start the server
app.listen(PORT, () => {
  console.log(`✅ BloodBridge AI backend is running on port ${PORT}`);
});

```

`backend/src/config/config.js`

```javascript
// backend/src/config/config.js
import 'dotenv/config'; // Loads variables from .env into process.env

// This object maps environment variables to a clean, accessible config object.
const config = {
    port: process.env.PORT,
    jwtSecret: process.env.JWT_SECRET,
    databaseUrl: process.env.DATABASE_URL,
    geminiApiKey: process.env.GEMINI_API_KEY,
    mlServiceUrl: process.env.ML_SERVICE_URL,
    whatsappToken: process.env.WHATSAPP_TOKEN,
    whatsappPhoneNumberId: process.env.WHATSAPP_PHONE_NUMBER_ID,
    whatsappAppSecret: process.env.WHATSAPP_APP_SECRET,
    whatsappVerifyToken: process.env.WHATSAPP_VERIFY_TOKEN,
    adminDemoPhone: process.env.ADMIN_DEMO_PHONE,
    demoVerifiedPhoneNumbers: process.env.DEMO_VERIFIED_PHONE_NUMBERS
};

// This validation step ensures the application fails fast if critical secrets are missing.
// It's a crucial security and stability feature.
const requiredConfig = ['port', 'jwtSecret', 'databaseUrl'];
const missingConfig = requiredConfig.filter(key => !config[key]);

if (missingConfig.length > 0) {
    console.error(`🔴 FATAL ERROR: Missing required environment variables: ${missingConfig.join(', ')}`);
    // Exit the application with an error code.
    process.exit(1);
}

export default config;

```

`backend/src/config/db.js`

```javascript
// backend/src/config/db.js
import { Pool } from 'pg';
import config from './config.js';

/**
 * Creates a new connection pool.
 * The pool manages multiple client connections to the database,
 * reusing them to improve performance and stability.
 */
const pool = new Pool({
  connectionString: config.databaseUrl,
});

/**
 * A helper function to execute a simple query.
 * @param {string} text - The SQL query string.
 * @param {Array} params - The parameters to pass to the query.
 * @returns {Promise<QueryResult>} The result from the database.
 */
const query = (text, params) => pool.query(text, params);

// We export the entire pool so we can use it for transactions later,
// and the query function for convenience.
const db = {
  query,
  pool,
};

export default db;

```

`backend/src/controllers/adminController.js`

```javascript
// backend/src/controllers/adminController.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import db from '../config/db.js';
import bridgeService from '../services/bridgeService.js';
import bridgeCoordinationService from '../services/bridgeCoordinationService.js'; 
import emergencyService from '../services/emergencyService.js';

/**
 * Admin Login
 */
export const login = async (req, res) => {
  const { phone, password } = req.body;
  if (!phone || !password) {
    return res.status(400).json({ message: 'Phone and password are required' });
  }
  try {
    // Demo admin login (for prototype)
    if (phone === config.adminDemoPhone && password === 'admin123') {
      const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
      console.log(`Login successful for demo admin: ${phone}`);
      return res.json({ token });
    }
    // In a real app, you would have hashed password validation here
    const { rows } = await db.query(
      'SELECT * FROM users WHERE phone = $1 AND role = $2',
      [phone, 'Admin']
    );
    if (rows.length === 0 || rows[0].password !== password) {
      console.warn('Login failed for phone:', phone);
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
    console.log(`Login successful for user: ${phone}`);
    return res.json({ token });

  } catch (err) {
    console.error('Login error:', { error: err.message, phone });
    return res.status(500).json({ message: 'Server error during login' });
  }
};

/**
 * Create a Blood Bridge for a Patient
 */
export const createBridgeForPatient = async (req, res) => {
  const { patientId } = req.params;
  try {
    const { rows: [patient] } = await db.query(
      'SELECT * FROM patients WHERE id = $1',
      [patientId]
    );

    if (!patient) {
      return res.status(404).json({ message: 'Patient not found' });
    }
    if (patient.status === 'bridged') {
      return res.status(400).json({ message: 'Patient already has a bridge.' });
    }

    const { rows: [bridge] } = await db.query(
      'INSERT INTO blood_bridges (patient_id, name, blood_group, city) VALUES ($1, $2, $3, $4) RETURNING id',
      [patient.id, `${patient.name}'s Bridge`, patient.blood_group, patient.city]
    );

    const result = await bridgeService.populateNewBridge(
      bridge.id,
      patient.city,
      patient.blood_group,
      patient.pincode
    );

    await db.query(
      "UPDATE patients SET status = 'bridged' WHERE id = $1",
      [patientId]
    );
    console.log(`ADMIN ACTION: Created and populated Bridge ${bridge.id} with ${result.count} members.`);
    res.json({
      success: true,
      message: `Blood Bridge created and populated with ${result.count} top donors.`
    });
  } catch (error) {
    console.error('Error creating bridge for patient:', error);
    await db.query( "UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    res.status(500).json({ error: 'Failed to create and populate bridge.' });
  }
};

/**
 * Close Emergency Request
 */
export const closeEmergency = async (req, res) => {
  const { requestId } = req.params;
  try {
    const { rowCount } = await db.query(
      "UPDATE emergency_requests SET status = 'closed' WHERE id = $1 AND status = 'active'",
      [requestId]
    );
    if (rowCount === 0) {
      return res.status(404).json({ message: "Active request not found or already closed."})
    }
    console.log(`ADMIN ACTION: Closed emergency request ${requestId}`);
    res.json({ success: true, message: 'Request successfully closed.' });
  } catch (error) {
    console.error(`Error closing emergency ${requestId}:`, error);
    res.status(500).json({ error: 'Failed to close request.' });
  }
};

/**
 * Triggers a transfusion request for a patient in a Blood Bridge.requestBridgeTransfusion
 */
export const requestBridgeTransfusion = async (req, res) => {
  const { bridgeId } = req.params;
  try {
    // Use the imported instance directly
    const result = await bridgeCoordinationService.requestTransfusion(bridgeId);
  // --- END OF FIX ---
    console.log(`ADMIN ACTION: Triggered transfusion request for bridge ${bridgeId}`);
    res.json(result);
  } catch (error) {
    console.error(`Error requesting bridge transfusion for ${bridgeId}:`, error);
    res.status(500).json({ error: error.message || 'Failed to send bridge request.' });
  }
};

/**
 * Fetches the four main statistics for the StatCards on the dashboard.
 */
export const getDashboardStats = async (req, res) => {
  try {
    const [
      { rows: [totalDonors] },
      { rows: [activeDonors] },
      { rows: [pendingPatients] },
      { rows: [atRisk] }
    ] = await Promise.all([
      db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor'"),
      db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor' AND availability_status = 'available'"),
      db.query("SELECT COUNT(*) as count FROM patients WHERE status = 'pending_verification'"),
      db.query("SELECT COUNT(*) as count FROM emergency_requests WHERE status = 'active'")
    ]);
    
    res.json({
      total_donors: parseInt(totalDonors.count, 10),
      active_donors: parseInt(activeDonors.count, 10),
      pending_patients: parseInt(pendingPatients.count, 10),
      patients_at_risk: parseInt(atRisk.count, 10),
    });
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({ error: 'Failed to fetch dashboard stats.' });
  }
};

/**
 * Fetches the count of donors for each blood group for the chart.
 */
export const getBloodGroupStats = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT blood_group, COUNT(*) as count 
       FROM users 
       WHERE user_type = 'donor' AND blood_group IS NOT NULL AND blood_group != 'Unknown'
       GROUP BY blood_group 
       ORDER BY blood_group`
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching blood group stats:', error);
    res.status(500).json({ error: 'Failed to fetch blood group stats.' });
  }
};

/**
 * Fetches patients with 'pending_verification' status for the Patients tab.
 */

export const getPatients = async (req, res) => {
  try {
    // --- THIS IS THE CORRECTED QUERY ---
    // Instead of a risky subquery, we use a LEFT JOIN. This is safer and more efficient.
    // It correctly handles the case where a patient has no bridge yet (member_count will be 0).
    const query = `
      SELECT 
        p.id, p.name, p.phone, p.blood_group, p.city, p.status, p.condition,
        p.last_transfusion_date, p.frequency_in_days,
        p.last_transfusion_date + (p.frequency_in_days || ' days')::interval AS next_due_date,
        COUNT(bm.id) as bridge_member_count
      FROM 
        patients p
      LEFT JOIN 
        blood_bridges bb ON p.id = bb.patient_id
      LEFT JOIN 
        bridge_members bm ON bb.id = bm.bridge_id
      GROUP BY
        p.id
      ORDER BY 
        p.created_at DESC
    `;
    // --- END OF CORRECTION ---
    
    const { rows } = await db.query(query);
    res.json(rows);
  } catch (error) {
    console.error('Error fetching patients:', error);
    res.status(500).json({ error: 'Failed to fetch patients.' });
  }
};

/**
 * Fetches all 'active' emergencies for the Emergencies tab.
 */
export const getActiveEmergencies = async (req, res) => {
  try {
    const { rows } = await db.query(
      "SELECT id, patient_name, blood_group, status, city FROM emergency_requests WHERE status = 'active' ORDER BY created_at DESC"
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching active emergencies:', error);
    res.status(500).json({ error: 'Failed to fetch active emergencies.' });
  }
};

/**
 * Fetches all created Blood Bridges for the Blood Bridges tab.
 */
export const getBloodBridges = async (req, res) => {
    try {
        const { rows } = await db.query(
            `SELECT bb.id, bb.blood_group, bb.city, p.name as patient_name
             FROM blood_bridges bb
             JOIN patients p ON bb.patient_id = p.id
             WHERE bb.active = true
             ORDER BY p.name`
        );
        res.json(rows);
    } catch (error) {
        console.error('Error fetching blood bridges:', error);
        res.status(500).json({ error: 'Failed to fetch blood bridges.' });
    }
};

/**
 * Fetches patients who are due for a transfusion.
 * Logic: Finds patients where today's date is past their last transfusion + frequency.
 */
export const getDuePatients = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT id, name, blood_group, city, last_transfusion_date, frequency_in_days
       FROM patients
       WHERE 
         status = 'bridged' AND 
         last_transfusion_date IS NOT NULL AND 
         frequency_in_days IS NOT NULL AND
         (last_transfusion_date + frequency_in_days * INTERVAL '1 day') <= NOW()`
    );
    res.json(rows);
  } catch (error){
    console.error('Error fetching due patients:', error);
    res.status(500).json({ error: 'Failed to fetch due patients.' });
  }
};

/**
 * Fetches the top 10 donors for the gamification leaderboard.
 */
export const getLeaderboard = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT name, gamification_points, city 
       FROM users 
       WHERE user_type = 'donor' 
       ORDER BY gamification_points DESC 
       LIMIT 10`
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching leaderboard:', error);
    res.status(500).json({ error: 'Failed to fetch leaderboard data.' });
  }
};

// --- Other Endpoints (Placeholders for now) ---
export const getConfig = async (req, res) => { res.json({ message: "Config placeholder" }); };
export const getInboxMessages = async (req, res) => {
  try {
    // This query selects all messages that an admin has not yet marked as 'resolved'.
    const { rows } = await db.query(
      "SELECT id, user_phone, user_message, reason, created_at FROM inbox_messages WHERE status = 'pending' ORDER BY created_at ASC"
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching inbox messages:', error);
    res.status(500).json({ error: 'Failed to fetch inbox messages.' });
  }
};
export const escalateEmergency = async (req, res) => {
  const { requestId } = req.params;
  try {
    const result = await emergencyService.escalateRequest(requestId);
    console.log(`ADMIN ACTION: Escalated emergency request ${requestId}`);
    res.json(result);
  } catch (error) {
    console.error(`Error escalating emergency ${requestId}:`, error);
    res.status(500).json({ error: error.message || 'Failed to escalate emergency.' });
  }
};
export const resolveInboxMessage = async (req, res) => { res.status(501).json({ message: "Not implemented" }); };

```

`backend/src/controllers/webhookController.js`

```javascript
// backend/src/controllers/webhookController.js

// Import required dependencies
import config from '../config/config.js';
import db from '../config/db.js';
import emergencyService from '../services/emergencyService.js';
import registrationService from '../services/registrationService.js';
import responseService from '../services/responseService.js';
import patientService from '../services/patientService.js';
import donorPreferenceService from '../services/donorPreferenceService.js';
import aiRouterService from '../services/aiRouterService.js';
import faqService from '../services/faqService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';


/**
 * Handles the GET request from Meta for webhook verification.
 * This is a one-time setup step.
 */
const verifyToken = (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  if (mode === 'subscribe' && token === config.whatsappVerifyToken) {
    console.log('✅ Webhook verified successfully!');
    return res.status(200).send(challenge);
  }

  console.warn('Webhook verification failed. Make sure your verify token is correct.');
  res.status(403).send('Verification failed');
};


/**
 * Processes a single, validated incoming WhatsApp message.
 * This function contains the main routing logic for the chatbot.
 * @param {object} messageData - The message object from the Meta webhook payload.
 */
const processMessage = async (messageData) => {
  // 1. Extract and Normalize Message Data
  const from = normalizePhoneNumber(messageData.from);
  if (messageData.type !== 'text') {
    console.log(`Ignoring non-text message of type '${messageData.type}' from ${from}.`);
    return;
  }
  const userMessage = messageData.text.body.trim();
  const lowerUserMessage = userMessage.toLowerCase();
  console.log(`--- Processing Message --- From: ${from}, Message: "${userMessage}"`);


  // 2. High-Priority Keyword & Pattern Matching
  if (await patientService.processOnboardingReply(userMessage, from)) {
    console.log(`✅ Message handled by: Patient Onboarding continuation.`);
    return;
  }
  if (lowerUserMessage === 'apply') {
    if(await patientService.startApplication(from)) {
      console.log(`✅ Message handled by: Patient Application start.`);
      return;
    }
  }
  if (/^\d{6}$/.test(userMessage)) {
    console.log(` OTP Detected. Passing to Response Service...`);
    await responseService.verifyOTPAndConfirm(from, userMessage);
    return;
  }
  const responseMatch = userMessage.match(/^(?:YES)\s+(\d{4})$/i);
  if (responseMatch) {
    console.log(` Donor Reply Detected. Passing to Response Service...`);
    await responseService.handleDonorReplyWithShortCode(from, responseMatch[1]);
    return;
  }
  
  // 3. Fallback to AI-Powered Intent Routing
  console.log(`No direct keyword match found. Routing to AI to determine intent...`);

  let userRole = 'Unregistered';
  const { rows: [user] } = await db.query('SELECT role FROM users WHERE phone = $1', [from]);
  if (user) userRole = user.role;
  
  const route = await aiRouterService.routeMessageWithContext(userMessage, userRole);

  if (route && route.tool) {
    console.log(`AI routed to tool: ${route.tool} with params:`, route.params);
    switch (route.tool) {
      case 'handle_emergency_request':
        await emergencyService.handleEmergencyRequest(userMessage, from);
        break;
      case 'handle_donor_registration':
        await registrationService.handleNewDonor(route.params, from);
        break;
      // Add other cases for other tools as they are defined in aiTools.js
      // e.g., case 'handle_snooze_request': ...

      default:
        // If the AI recommends a tool we haven't implemented a case for,
        // it's safer to treat it as a general question.
        console.log(`AI chose unhandled tool '${route.tool}'. Defaulting to FAQ.`);
        await faqService.handleFaq(userMessage, from);
        break;
    }
    console.log(`✅ Message handled by: AI-routed tool '${route.tool}'.`);
    return;
  }

  // 4. Final Fallback if no keywords or tools match
  console.log(`AI did not select a tool. Handling as a general FAQ.`);
  await faqService.handleFaq(userMessage, from);
  console.log(`✅ Message handled by: Fallback FAQ.`);
};


/**
 * The main entry point for the /webhook POST request.
 * It validates the message and then calls processMessage.
 */
const handleMessage = async (req, res) => {
  res.sendStatus(200); // Acknowledge receipt to Meta immediately

  try {
    const messageData = req.body.entry?.[0]?.changes?.[0]?.value?.messages?.[0];
    if (!messageData) {
      console.warn('Webhook received a payload that was not a message.', req.body);
      return;
    }

    const messageId = messageData.id;
    
    // Prevent duplicate processing
    const { rows } = await db.query('SELECT 1 FROM processed_messages WHERE message_id = $1', [messageId]);
    if (rows.length > 0) {
      console.warn(`Duplicate message ignored: ${messageId}`);
      return;
    }
    
    await db.query('INSERT INTO processed_messages(message_id) VALUES($1)', [messageId]);

    // Process the message
    await processMessage(messageData);

  } catch (error) {
    console.error('CRITICAL ERROR in handleMessage:', {
      message: error.message,
      stack: error.stack,
    });
  }
};

export default {
  verifyToken,
  handleMessage,
};

```

`backend/src/middleware/authMiddleware.js`

```javascript
// backend/src/middleware/authMiddleware.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';

// ✅ The function must be declared as a constant named 'authMiddleware'
const authMiddleware = (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authorization token is missing or malformed' });
  }

  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, config.jwtSecret);
    req.user = decoded;
    next();
  } catch (error) {
    console.error("JWT Verification Error:", error.message);
    return res.status(401).json({ message: 'Invalid or expired token' });
  }
};

// ✅ This line then exports that constant
export default authMiddleware;

```

`backend/src/middleware/checkRole.js`

```javascript
// backend/src/middleware/checkRole.js

const checkRole = (roles) => {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: 'Forbidden: No role assigned' });
    }
    const userRole = req.user.role;
    if (roles.includes(userRole)) {
      return next();
    }
    return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
  };
};

export default checkRole; // <-- CORRECTED LINE

```

`backend/src/middleware/verifyWebhook.js`

```javascript
// backend/src/middleware/verifyWebhook.js
import crypto from 'crypto';
import config from '../config/config.js';

/**
 * Middleware to verify WhatsApp webhook POST requests.
 * - Skips signature verification for GET (used by Meta for challenge verification).
 * - Validates signature for POST requests to ensure authenticity.
 */
export const verifyWebhook = (req, res, next) => {
  // Allow GET requests (Meta verification step) to pass through.
  if (req.method === 'GET') {
    return next();
  }

  // Get the signature from the request header.
  const signature = req.headers['x-hub-signature-256'];
  if (!signature) {
    console.warn('Signature missing for POST webhook');
    return res.status(401).json({ message: 'Signature missing' });
  }

  // --- THIS IS THE CORRECTED SECTION ---
  // Create an HMAC (Hash-based Message Authentication Code) using sha256.
  // We use the `whatsappAppSecret` as the key.
  const hmac = crypto.createHmac('sha256', config.whatsappAppSecret);

  // We MUST use the raw request body string that we saved earlier in server.js.
  // Using `req.body` here will fail because it's already parsed JSON.
  hmac.update(req.rawBody);
  const expectedSignature = `sha256=${hmac.digest('hex')}`;
  // --- END OF CORRECTION ---

  // Compare the signature from Meta with the one we calculated.
  // We use a timing-safe comparison to enhance security.
  // An invalid signature means the request might be forged.
  if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))) {
    console.warn('Signature mismatch for POST webhook. Check your WHATSAPP_APP_SECRET.');
    return res.status(401).json({ message: 'Invalid signature' });
  }

  // If the signatures match, the request is authentic. Proceed to the next middleware.
  next();
};

```

`backend/src/routes/adminRoutes.js`

```javascript
// backend/src/routes/adminRoutes.js
import express from 'express';
// --- FIX: Use named imports for all controller functions ---
import {
  login,
  createBridgeForPatient,
  closeEmergency,
  requestBridgeTransfusion,
  getDashboardStats,
  getBloodGroupStats,
  getPatients,
  getActiveEmergencies,
  getBloodBridges,
  getDuePatients,
  getLeaderboard,
  getInboxMessages,
  escalateEmergency,
  resolveInboxMessage,
  getConfig
} from '../controllers/adminController.js';
import authMiddleware from '../middleware/authMiddleware.js';
import checkRole from '../middleware/checkRole.js';

const router = express.Router();

// Public (no auth needed)
// --- FIX: Removed 'adminController.' prefix ---
router.post('/login', login);

// All routes below this require auth
router.use(authMiddleware);

// --- DASHBOARD GET ROUTES ---
// --- FIX: Removed 'adminController.' prefix from all routes below ---
router.get('/config', checkRole(['Admin']), getConfig);
router.get('/stats', checkRole(['Admin']), getDashboardStats);
router.get('/stats/blood-groups', checkRole(['Admin']), getBloodGroupStats);
router.get('/patients', checkRole(['Admin']), getPatients);
router.get('/patients/due', checkRole(['Admin']), getDuePatients);
router.get('/emergencies', checkRole(['Admin']), getActiveEmergencies);
router.get('/bridges', checkRole(['Admin']), getBloodBridges);
router.get('/leaderboard', checkRole(['Admin']), getLeaderboard);
router.get('/inbox', checkRole(['Admin']), getInboxMessages);

// --- ACTION ROUTES ---
router.post('/patients/:patientId/create-bridge', checkRole(['Admin']), createBridgeForPatient);
router.post('/emergencies/:requestId/close', checkRole(['Admin']), closeEmergency);
router.post('/emergencies/:requestId/escalate', checkRole(['Admin']), escalateEmergency);
router.post('/bridges/:bridgeId/request', checkRole(['Admin']), requestBridgeTransfusion);
router.post('/inbox/:messageId/resolve', checkRole(['Admin']), resolveInboxMessage);

export default router;

```

`backend/src/services/aiRouterService.js`

```javascript
// backend/src/services/aiRouterService.js
import { GoogleGenerativeAI } from '@google/generative-ai';
import { TOOL_DEFINITIONS } from './aiTools.js';
import config from '../config/config.js';

class AIRouterService {
  constructor() {
    if (!config.geminiApiKey) {
      throw new Error("GEMINI_API_KEY is not set.");
    }
    this.genAI = new GoogleGenerativeAI(config.geminiApiKey);
    this.model = this.genAI.getGenerativeModel({
      model: 'gemini-1.5-flash-latest',
      tools: { functionDeclarations: TOOL_DEFINITIONS }
    });
  }

  async routeMessageWithContext(userMessage, userRole) {
    const systemPrompt = `You are "Bridge AI", an AI assistant. Understand the user's message and call the appropriate function. The user's role is "${userRole}".`;
    const chatHistory = [
        { role: "user", parts: [{ text: systemPrompt }] },
        { role: "model", parts: [{ text: "Understood." }] },
    ];
    try {
      const chat = this.model.startChat({ history: chatHistory });
      const result = await chat.sendMessage(userMessage);
      const call = result.response.functionCalls()?.[0];
      
      if (call) {
        console.log(`AI decided to call tool: ${call.name} with params:`, call.args);
        return { tool: call.name, params: call.args };
      }
      console.log("AI did not call a specific tool for this message.");
      return null;
    } catch (error) {
      console.error('Error routing message with Gemini:', error.message);
      return null;
    }
  }
}

export default new AIRouterService();

```

`backend/src/services/aiTools.js`

```javascript
// backend/src/services/aiTools.js

/**
 * TOOL_DEFINITIONS is a manifest of functions the Gemini AI can call.
 * This is for the original, non-LangChain aiRouterService.
 * The descriptions are critical, as they tell the AI *when* to use each tool.
 */
export const TOOL_DEFINITIONS = [
  {
    name: 'handle_emergency_request',
    description: `Use for any urgent blood request. The message may contain details like blood group, city, or hospital. Extract these if present.`,
    parameters: {
      type: 'object',
      properties: {
        patient_name: { type: 'string', description: 'Name of the patient needing blood. If not mentioned, use "Unknown".' },
        blood_group: { type: 'string', description: 'The blood group needed, like A+, O-, AB+.' },
        city: { type: 'string', description: 'The city where the hospital is located.' }
      },
      required: ['blood_group', 'city']
    }
  },
  {
    name: 'handle_donor_registration',
    description: `Use this ONLY for messages where the user explicitly states they want to perform the ACTION of registering. This is the correct tool for phrases like "I want to donate blood", "register me as a donor", "sign me up", or "I want to become a Blood Warrior". DO NOT use this for general questions about donation requirements.`,
    parameters: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Full name of the new donor. Default to "Unknown" if not provided.' },
        blood_group: { type: 'string', description: 'The blood group of the person. Default to "Unknown" if not provided.' },
        city: { type: 'string', description: 'The city where the donor lives. Default to "Unknown" if not provided.' }
      },
      required: []
    }
  },
  {
    name: 'handle_snooze_request',
    description: 'Use when a donor wants to temporarily pause notifications. It can understand durations like "a month", "10 days", "2 weeks".',
    parameters: {
      type: 'object',
      properties: {
        duration: { type: 'integer', description: 'The number value for the duration (e.g., 10 for "10 days").' },
        unit: { type: 'string', enum: ['day', 'week', 'month'], description: 'The unit of time for the snooze.' }
      },
      required: ['duration', 'unit']
    }
  },
   {
    name: 'get_my_dashboard',
    description: 'Use this when a registered donor asks for their personal status, points, badges, or "mydashboard". It requires no parameters.',
    parameters: {
      type: 'object',
      properties: {},
      required: []
    }
  },
  {
    name: 'get_leaderboard',
    description: 'Use this when a user asks to see the "leaderboard", "top donors", or "rankings". It requires no parameters.',
    parameters: {
      type: 'object',
      properties: {},
      required: []
    }
  },
];

```

`backend/src/services/bridgeCoordinationService.js`

```javascript
// backend/src/services/bridgeCoordinationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateShortCode } from '../utils/otpHelper.js';

class BridgeCoordinationService {
  async requestTransfusion(bridgeId) {
    const { rows: [bridge] } = await db.query(
      `SELECT bb.*, p.name as patient_name
       FROM blood_bridges bb
       JOIN patients p ON bb.patient_id = p.id
       WHERE bb.id = $1`,
      [bridgeId]
    );
    if (!bridge) throw new Error(`Blood Bridge with ID ${bridgeId} not found.`);

    // --- NEW LOGIC: PREVENT DUPLICATE REQUESTS ---
    if (bridge.active_request_id) {
      throw new Error(`Request failed: Patient ${bridge.patient_name} already has an active bridge request.`);
    }
    // --- END NEW LOGIC ---

    const { rows: members } = await db.query(
      // Find the next donor who is currently 'available'
      `SELECT u.id, u.name, u.phone
       FROM bridge_members bm
       JOIN users u ON bm.donor_id = u.id
       WHERE bm.bridge_id = $1 AND bm.status = 'active' AND u.availability_status = 'available'
       ORDER BY bm.position ASC`,
      [bridgeId]
    );

    if (members.length === 0) {
      // This is a "Bridge Failure" scenario. We need to escalate.
      // For now, we'll throw an error that the admin will see.
      // In Task 4 (Escalation), we will automate this.
      throw new Error(`No available donors found in the bridge for ${bridge.patient_name}. Please escalate to a general emergency.`);
    }

    const donorToNotify = members[0]; // The SQL query now only returns available donors in order

    const shortCode = generateShortCode();
    // Create the request and get its ID back
    const { rows: [newRequest] } = await db.query(
      `INSERT INTO emergency_requests (patient_name, blood_group, city, requested_by_phone, short_code, request_type, bridge_id, units_needed)
       VALUES ($1, $2, $3, 'system', $4, 'bridge', $5, 1) RETURNING id;`,
      [bridge.patient_name, bridge.blood_group, bridge.city, shortCode, bridge.id]
    );

    // --- NEW LOGIC: LINK THE ACTIVE REQUEST TO THE BRIDGE ---
    await db.query(
        'UPDATE public.blood_bridges SET active_request_id = $1 WHERE id = $2',
        [newRequest.id, bridgeId]
    );
    // --- END NEW LOGIC ---

    const message = `Hi ${donorToNotify.name}, it's your turn in the Blood Bridge for patient *${bridge.patient_name}*.\n\nYour help is needed for their scheduled transfusion. Please reply with *YES ${shortCode}* to confirm your availability.`;
    await whatsappService.sendTextMessage(donorToNotify.phone, message);

    return { success: true, message: `Successfully notified ${donorToNotify.name} for patient ${bridge.patient_name}.` };
  }
  
  async rotateBridge(bridgeId, client = db) {
    // This function now does two things: rotates the position AND clears the active request ID.
    const { rows: [bridge] } = await client.query('SELECT rotation_position FROM blood_bridges WHERE id = $1', [bridgeId]);
    const { rows: [{ count }] } = await client.query('SELECT COUNT(*) FROM bridge_members WHERE bridge_id = $1 AND status = \'active\'', [bridgeId]);

    if (!bridge || count === '0') {
      console.error(`Cannot rotate bridge ${bridgeId}: Bridge or members not found.`);
      return;
    }

    const totalMembers = parseInt(count, 10);
    // We use the current position to find the next one, ensuring rotation
    const currentPositionInList = (bridge.rotation_position - 1);
    const nextPosition = (currentPositionInList % totalMembers) + 1;

    // Update bridge: clear active request and set new rotation position
    await client.query(
      'UPDATE blood_bridges SET rotation_position = $1, active_request_id = NULL WHERE id = $2',
      [nextPosition, bridgeId]
    );
    console.log(`Blood Bridge ${bridgeId} rotated successfully to position ${nextPosition} and cleared active request.`);
  }  // In backend/src/services/bridgeCoordinationService.js, inside the class

  /**
   * Finds all bridged patients who are due for a transfusion and initiates the request.
   * This is designed to be run automatically by a scheduler.
   */
  async triggerAutomaticBridgeRequests() {
    console.log('CRON JOB: Checking for due bridge patients...');
    try {
      // 1. Find all patients who are bridged and due for a transfusion today or in the past.
      const { rows: duePatients } = await db.query(
        `SELECT p.id, p.name, bb.id as bridge_id
         FROM patients p
         JOIN blood_bridges bb ON p.id = bb.patient_id
         WHERE 
           p.status = 'bridged' AND 
           p.last_transfusion_date IS NOT NULL AND 
           p.frequency_in_days IS NOT NULL AND
           (p.last_transfusion_date + p.frequency_in_days * INTERVAL '1 day') <= NOW() AND
           bb.active_request_id IS NULL -- IMPORTANT: Only trigger if there isn't one already active
        `
      );

      if (duePatients.length === 0) {
        console.log('CRON JOB: No patients are due for an automatic bridge request today.');
        return;
      }

      console.log(`CRON JOB: Found ${duePatients.length} patient(s) due for transfusion. Initiating requests...`);

      // 2. Loop through each due patient and call the existing requestTransfusion function.
      for (const patient of duePatients) {
        console.log(`CRON JOB: Initiating request for patient ${patient.name} (Bridge ID: ${patient.bridge_id})`);
        try {
          // We reuse the same logic that the admin dashboard button uses.
          await this.requestTransfusion(patient.bridge_id);
        } catch (error) {
          console.error(`CRON JOB: Failed to initiate request for bridge ${patient.bridge_id}. Reason: ${error.message}`);
          // In a production system, you might send an alert to an admin here.
        }
      }
    } catch (error) {
      console.error("CRITICAL ERROR in cron job triggerAutomaticBridgeRequests:", error);
    }
  }

/**
 * Finds all bridged patients who are due for a transfusion and initiates the request.
 * This is designed to be run automatically by a scheduler.
 */
async triggerAutomaticBridgeRequests() {
  console.log('CRON JOB: Checking for due bridge patients...');
  try {
    // 1. Find all patients who are bridged and due for a transfusion today or in the past.
    const { rows: duePatients } = await db.query(
      `SELECT p.id, p.name, bb.id as bridge_id
       FROM patients p
       JOIN blood_bridges bb ON p.id = bb.patient_id
       WHERE 
         p.status = 'bridged' AND 
         p.last_transfusion_date IS NOT NULL AND 
         p.frequency_in_days IS NOT NULL AND
         (p.last_transfusion_date + p.frequency_in_days * INTERVAL '1 day') <= NOW() AND
         bb.active_request_id IS NULL -- IMPORTANT: Only trigger if there isn't one already active
      `
    );

    if (duePatients.length === 0) {
      console.log('CRON JOB: No patients are due for an automatic bridge request today.');
      return;
    }

    console.log(`CRON JOB: Found ${duePatients.length} patient(s) due for transfusion. Initiating requests...`);

    // 2. Loop through each due patient and call the existing requestTransfusion function.
    for (const patient of duePatients) {
      console.log(`CRON JOB: Initiating request for patient ${patient.name} (Bridge ID: ${patient.bridge_id})`);
      try {
        // We reuse the same logic that the admin dashboard button uses.
        await this.requestTransfusion(patient.bridge_id);
      } catch (error) {
        console.error(`CRON JOB: Failed to initiate request for bridge ${patient.bridge_id}. Reason: ${error.message}`);
        // In a production system, you might send an alert to an admin here.
      }
    }
  } catch (error) {
    console.error("CRITICAL ERROR in cron job triggerAutomaticBridgeRequests:", error);
  }
}
}

export default new BridgeCoordinationService();

```

`backend/src/services/bridgeService.js`

```javascript
import db from '../config/db.js';

class BridgeService {
  // In backend/src/services/bridgeService.js
async populateNewBridge(bridgeId, city, bloodGroup, pincode) {
    try {
      console.log(`Populating bridge ${bridgeId} for city: ${city}, blood group: ${bloodGroup}, pincode: ${pincode}`);
      
      // --- THE FIX IS HERE ---
      // The SQL function `find_donors_for_bridge` returns two columns: `donor_id` and `final_score`.
      // We must select exactly those columns.
      const { rows: bestDonors } = await db.query(
        'SELECT donor_id, final_score FROM find_donors_for_bridge($1, $2, $3, $4)',
        [city, bloodGroup, pincode, 8] // We are populating with the top 8 donors
      );
      // --- END OF FIX ---

      if (!bestDonors || bestDonors.length === 0) {
        console.warn(`No donors found for bridge ${bridgeId}`);
        return { success: true, count: 0 };
      }

      // Use the donor_id from the function's result to insert into bridge_members
      const insertQueries = bestDonors.map((donor, index) =>
        db.query(
          'INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, $3)',
          [bridgeId, donor.donor_id, index + 1]
        )
      );

      await Promise.all(insertQueries);
      console.log(`Successfully populated bridge ${bridgeId} with ${bestDonors.length} donors`);
      return { success: true, count: bestDonors.length };

    } catch (error) {
      console.error(`Error populating bridge ${bridgeId}:`, {
        error: error.message,
        city,
        bloodGroup,
        pincode,
      });
      throw new Error(`Failed to populate bridge: ${error.message}`);
    }
}
}

export default new BridgeService();

```

`backend/src/services/donorPreferenceService.js`

```javascript
// backend/src/services/donorPreferenceService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class DonorPreferenceService {
  /**
   * Sets a snooze period for a donor, pausing notifications.
   * @param {string} phone - The donor's phone number.
   * @param {object} params - Parameters from the AI, e.g., { duration: 1, unit: 'week' }.
   */
  async handleSnooze(phone, params) {
    const { duration = 15, unit = 'day' } = params; // Default to 15 days if AI provides no params
    
    try {
      const interval = `${duration} ${unit}`;
      const { rows: [user] } = await db.query(
        "UPDATE users SET snooze_until = NOW() + $1::interval WHERE phone = $2 RETURNING snooze_until",
        [interval, phone]
      );

      if (user && user.snooze_until) {
        const snoozeDate = new Date(user.snooze_until).toLocaleDateString('en-IN');
        const message = `Got it. I've paused all non-critical notifications for you until ${snoozeDate}. We'll reach out again after that. Thank you for being a donor!`;
        await whatsappService.sendTextMessage(phone, message);
      }
    } catch (error) {
      console.error(`Error setting snooze for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while setting your preferences.");
    }
  }

  /**
   * Sets the Do Not Disturb (DND) status for a donor, permanently stopping notifications.
   * @param {string} phone - The donor's phone number.
   */
  async handleDnd(phone) {
    try {
      await db.query(
        "UPDATE users SET dnd_status = true, availability_status = 'unavailable' WHERE phone = $1",
        [phone]
      );
      const message = "You have been unsubscribed from all future notifications. We're sad to see you go, but we respect your decision. If you ever change your mind, just send 'Register' to sign up again.";
      await whatsappService.sendTextMessage(phone, message);
    } catch (error) {
      console.error(`Error setting DND for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while updating your DND status.");
    }
  }
}

export default new DonorPreferenceService();

```

`backend/src/services/emergencyService.js`

```javascript
// backend/src/services/emergencyService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import aiRouterService from './aiRouterService.js'; // <-- CORRECTLY IMPORTED
import mlService from './mlService.js';
import geocodingService from './geocodingService.js';
import { getDistanceInKm } from '../utils/distanceHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

const VALID_BLOOD_GROUPS = ['A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'];

class EmergencyService {
  /**
   * Handles the initial emergency message from a user. It uses the AI router
   * to parse details and then passes them to the creation function.
   * @param {string} userMessage - The raw text message from the user.
   * @param {string} requesterPhone - The user's phone number.
   */
  async handleEmergencyRequest(userMessage, requesterPhone) {
    const sanitizedPhone = normalizePhoneNumber(requesterPhone);
    try {
      // --- CORRECT LOGIC: USE AI ROUTER TO PARSE THE MESSAGE ---
      const route = await aiRouterService.routeMessageWithContext(userMessage, 'Unregistered');
      
      if (route && route.tool === 'handle_emergency_request' && route.params.blood_group && route.params.city) {
        console.log("AI successfully extracted details:", route.params);
        await this.createEmergencyRequest(route.params, sanitizedPhone);
      } else {
        console.log('AI could not extract necessary details. Prompting user.');
        const followupMessage = "I understand this is an emergency. To find a donor, please provide the patient's blood group (e.g., A+, O-) and the city where the hospital is located.";
        await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);
      }
      // --- END CORRECT LOGIC ---
    } catch (error) {
        console.error('CRITICAL ERROR in handleEmergencyRequest:', error);
        await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }

  /**
   * Creates the emergency request in the database after parameters have been validated.
   * @param {object} params - Clean parameters from the handleEmergencyRequest function.
   * @param {string} requesterPhone - The user's phone number.
   */
  async createEmergencyRequest(params, requesterPhone) {
    const { 
      patient_name = 'Unknown', 
      blood_group, 
      city, 
      hospital_name = 'Unknown', 
      units_needed = 1
    } = params;
    
    try {
      const normalizedBG = normalizeBloodGroup(blood_group);
      
      if (!VALID_BLOOD_GROUPS.includes(normalizedBG)) {
        console.warn(`Validation failed: AI provided invalid blood group '${blood_group}'`);
        const validationErrorMessage = `Sorry, "${blood_group}" is not a recognized blood group. Please use a valid one (e.g., O+, AB-).`;
        await whatsappService.sendTextMessage(requesterPhone, validationErrorMessage);
        return;
      }
      
      let coords = null;
      try {
        coords = await geocodingService.getCoords(hospital_name, city, null);
      } catch (geoError) {
        console.error("Geocoding service failed, but continuing without coordinates.", geoError);
      }

      const shortCode = Math.floor(1000 + Math.random() * 9000).toString();

      const { rows: [request] } = await db.query(
        `INSERT INTO emergency_requests (patient_name, blood_group, city, hospital_name, requested_by_phone, short_code, latitude, longitude, units_needed)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *;`,
        [patient_name, normalizedBG, city, hospital_name, requesterPhone, shortCode, coords?.latitude, coords?.longitude, units_needed]
      );
      
      console.log(`Successfully created emergency request ID: ${request.id}`);
      await whatsappService.sendTextMessage(requesterPhone, `✅ Emergency request active! We are now running a hyperlocal search for the best donor for *${patient_name}*.`);
      
      await this.findAndNotifyDonors(request);

    } catch (error) {
      console.error('CRITICAL ERROR creating emergency request in database:', error);
      await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }
  
   async escalateRequest(requestId) {
    // 1. Get the original emergency request details.
    const { rows: [request] } = await db.query(
      'SELECT * FROM emergency_requests WHERE id = $1 AND status = \'active\'',
      [requestId]
    );

    if (!request) {
      throw new Error('Active emergency request not found.');
    }

    // 2. Find all donors who have ALREADY been notified for this request.
    const { rows: notifiedDonors } = await db.query(
      'SELECT donor_id FROM donor_responses WHERE request_id = $1',
      [requestId]
    );
    const excludedDonorIds = notifiedDonors.map(d => d.donor_id);

    console.log(`Escalating request ${requestId}. Excluding ${excludedDonorIds.length} already-notified donor(s).`);

    // 3. Find the next batch of top-ranked donors, EXCLUDING the ones we already contacted.
    const nextDonors = await this.findAndRankGeneralDonors(
      request.blood_group,
      request.city,
      excludedDonorIds
    );

    if (nextDonors.length === 0) {
      // If there are no other donors to contact, inform the admin.
      console.warn(`Escalation failed for request ${requestId}: No new donors found.`);
      throw new Error('No additional available donors found in the network for this request.');
    }

    // 4. Notify the new best donor.
    const bestNextDonor = nextDonors[0];
    const notificationMessage = `🚨 URGENT (Escalated): You are the next top match!\n\nPatient *${request.patient_name}* needs your help (${request.blood_group}).\n\nReply *YES ${request.short_code}* to help.`;
    
    // We also need to add this new donor to the donor_responses table so we don't contact them again.
    // This is important for multiple escalations.
    await db.query(
        `INSERT INTO donor_responses (donor_id, request_id, response) VALUES ($1, $2, 'pending') ON CONFLICT (donor_id, request_id) DO NOTHING;`,
        [bestNextDonor.id, requestId]
    );

    await whatsappService.sendTextMessage(bestNextDonor.phone, notificationMessage);
    await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [bestNextDonor.id]);
    
    const adminMessage = `✅ Escalation successful. Notifying the next best match: *${bestNextDonor.name}* (Score: ${bestNextDonor.final_score.toFixed(1)}).`;
    await whatsappService.sendTextMessage(request.requested_by_phone, adminMessage);

    return { success: true, message: `Successfully escalated request and notified ${bestNextDonor.name}.` };
  }

  async findAndNotifyDonors(request) {
    const { id: requestId, blood_group, city, requested_by_phone, latitude: hospitalLat, longitude: hospitalLon } = request;
    
    try {
        let topScoredDonors = await this.findAndRankGeneralDonors(blood_group, city, []);

        if (topScoredDonors.length === 0) {
          await whatsappService.sendTextMessage(requested_by_phone, '⚠️ We searched our network but could not find any available donors at this moment.');
          return;
        }

        if (hospitalLat && hospitalLon) {
            topScoredDonors.forEach(donor => {
                donor.distance = donor.latitude ? getDistanceInKm(hospitalLat, hospitalLon, donor.latitude, donor.longitude) : Infinity;
            });
            topScoredDonors.sort((a, b) => a.distance - b.distance);
        }

        const bestDonor = topScoredDonors[0];
        const notificationMessage = `🚨 URGENT: You are a top-ranked match!\n\nPatient *${request.patient_name}* needs your help (${request.blood_group}) at ${request.hospital_name}.\n\nReply *YES ${request.short_code}* to help.`;
        
        await whatsappService.sendTextMessage(bestDonor.phone, notificationMessage);
        await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [bestDonor.id]);
        
        let adminMessage = `✅ Hyperlocal search complete. Notifying the best match: *${bestDonor.name}* (Score: ${bestDonor.final_score.toFixed(1)}, Dist: ${bestDonor.distance ? bestDonor.distance.toFixed(1) + ' km' : 'N/A'}).`;
        await whatsappService.sendTextMessage(requested_by_phone, adminMessage);
    } catch (error) {
        console.error(`CRITICAL ERROR in findAndNotifyDonors for request ${requestId}:`, error);
        await whatsappService.sendTextMessage(requested_by_phone, 'We encountered a system error while searching for donors. Our team has been notified.');
    }
  }
 async findAndRankGeneralDonors(bloodGroup, city, excludedDonorIds = []) {
    const { rows: availableDonors } = await db.query(
      `SELECT id, name, phone, last_donation, notifications_received, donations_confirmed, streak_count, latitude, longitude
       FROM users
       WHERE user_type = 'donor' AND blood_group = $1 AND city ILIKE $2
         AND availability_status = 'available' AND dnd_status = false
         AND (snooze_until IS NULL OR snooze_until < NOW())
         AND id NOT IN (SELECT unnest($3::uuid[]))
       LIMIT 50;`,
      [normalizeBloodGroup(bloodGroup), city, excludedDonorIds]
    );

    if (!availableDonors || availableDonors.length === 0) return [];
    
    const scoringPromises = availableDonors.map(donor => mlService.scoreSingleDonor(donor));
    const results = await Promise.allSettled(scoringPromises);

    const scoredDonors = availableDonors.map((donor, index) => {
        const score = results[index].status === 'fulfilled' ? results[index].value.final_score : 0;
        return { ...donor, final_score: score };
    });

    scoredDonors.sort((a, b) => b.final_score - a.final_score);
    return scoredDonors.slice(0, 5);
  }

}

export default new EmergencyService();

```

`backend/src/services/engagementService.js`

```javascript
// backend/src/services/engagementService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class EngagementService {
  /**
   * Finds donors whose 90-day cooldown period has ended and reminds them
   * that they are now eligible to donate again.
   */
  async sendEligibilityReminders() {
    console.log('CRON JOB: Running sendEligibilityReminders...');
    try {
      // 1. Find all donors who are ready to be re-activated.
      // - Their cooldown must have expired (cooldown_until <= NOW()).
      // - Their status must currently be 'unavailable' (from their last donation).
      // - They must not have opted out of all notifications (dnd_status = false).
      const { rows: eligibleDonors } = await db.query(
        `SELECT id, name, phone
         FROM users
         WHERE user_type = 'donor'
           AND availability_status = 'unavailable'
           AND dnd_status = false
           AND cooldown_until <= NOW()`
      );

      if (eligibleDonors.length === 0) {
        console.log('CRON JOB: No donors are newly eligible today.');
        return;
      }

      console.log(`CRON JOB: Found ${eligibleDonors.length} newly eligible donors. Preparing to send reminders.`);

      // 2. Prepare all the database updates.
      // We will collect all the user IDs to update their status in a single efficient query.
      const donorIdsToUpdate = eligibleDonors.map(donor => donor.id);
      const updatePromise = db.query(
        "UPDATE users SET availability_status = 'available' WHERE id = ANY($1::uuid[])",
        [donorIdsToUpdate]
      );

      // 3. Prepare all the WhatsApp messages.
      // We will send messages concurrently for maximum speed.
      const messagePromises = eligibleDonors.map(donor => {
        const message = `Hi ${donor.name}! 👋\n\nGreat news! Your 90-day waiting period is over, and you are now eligible to save a life again.\n\nYour status has been updated to "Available". Thank you for being a vital part of the BloodBridge community! ❤️`;
        return whatsappService.sendTextMessage(donor.phone, message);
      });

      // 4. Execute all promises (database updates and messages).
      // Promise.allSettled is used so that if one message fails, it doesn't stop the others.
      const results = await Promise.allSettled([updatePromise, ...messagePromises]);

      // 5. Log the results for monitoring.
      let successCount = 0;
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          if (index > 0) successCount++; // Don't count the DB update as a message
        } else {
          console.error(`CRON JOB: Failed to process reminder for donor ID ${donorIdsToUpdate[index - 1]}:`, result.reason);
        }
      });
      console.log(`CRON JOB: Successfully sent ${successCount} eligibility reminders.`);
      console.log(`CRON JOB: Updated ${donorIdsToUpdate.length} donors to 'available' status.`);

    } catch (error) {
      console.error('CRITICAL ERROR in cron job sendEligibilityReminders:', error);
    }
  }


   /**
   * Finds active, eligible donors who have not donated in a long time
   * and sends them a personalized re-engagement message.
   */
  async sendInactiveDonorNudges() {
    console.log('CRON JOB: Running Inactive Donor Nudge...');
    try {
      // 1. Find donors who are available but haven't donated in over 6 months (180 days).
      const { rows: inactiveDonors } = await db.query(
        `SELECT id, name, phone 
         FROM users
         WHERE 
           user_type = 'donor' AND
           availability_status = 'available' AND
           dnd_status = false AND
           (snooze_until IS NULL OR snooze_until < NOW()) AND
           (last_donation IS NULL OR last_donation < NOW() - INTERVAL '180 days')`
      );

      if (inactiveDonors.length === 0) {
        console.log('CRON JOB: No inactive donors to nudge this week.');
        return;
      }

      console.log(`CRON JOB: Found ${inactiveDonors.length} inactive donors. Sending nudges...`);
      for (const donor of inactiveDonors) {
        const nudgeMessage = `Hi ${donor.name}! We miss you. Patients in your area are still in need of heroes like you. We hope you'll consider donating again soon. Your support makes a huge difference!`;
        await whatsappService.sendTextMessage(donor.phone, nudgeMessage);
        // Add a small delay to avoid spamming the WhatsApp API
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    } catch (error) {
      console.error("CRITICAL ERROR in cron job sendInactiveDonorNudges:", error);
    }
  }
  // In backend/src/services/engagementService.js, inside the class

/**
 * Finds active, eligible donors who have not donated in a long time
 * and sends them a personalized re-engagement message.
 */
async sendInactiveDonorNudges() {
  console.log('CRON JOB: Running Inactive Donor Nudge...');
  try {
    // 1. Find donors who are available but haven't donated in over 6 months (180 days).
    const { rows: inactiveDonors } = await db.query(
      `SELECT id, name, phone 
       FROM users
       WHERE 
         user_type = 'donor' AND
         availability_status = 'available' AND
         dnd_status = false AND
         (snooze_until IS NULL OR snooze_until < NOW()) AND
         (last_donation IS NULL OR last_donation < NOW() - INTERVAL '180 days')`
    );

    if (inactiveDonors.length === 0) {
      console.log('CRON JOB: No inactive donors to nudge this week.');
      return;
    }

    console.log(`CRON JOB: Found ${inactiveDonors.length} inactive donors. Sending nudges...`);
    for (const donor of inactiveDonors) {
      const nudgeMessage = `Hi ${donor.name}! We miss you. Patients in your area are still in need of heroes like you. We hope you'll consider donating again soon. Your support makes a huge difference!`;
      await whatsappService.sendTextMessage(donor.phone, nudgeMessage);
    }
  } catch (error) {
    console.error("CRITICAL ERROR in cron job sendInactiveDonorNudges:", error);
  }
}
}

export default new EngagementService();

```

`backend/src/services/faqService.js`

```javascript
// backend/src/services/faqService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import mlService from './mlService.js'; // Use the mlService client

const SENSITIVE_KEYWORDS = ['problem', 'pain', 'issue', 'bad', 'reaction', 'scared', 'help me', 'confused', 'afraid'];

class FaqService {
  async handleFaq(query, phone) {
    console.log(`Getting RAG-powered FAQ answer for: "${query}"`);
    const disclaimer = "\n\n_Disclaimer: This is automated information. For medical advice, please consult a doctor._";
    
    try {
      const response = await mlService.client.post('/generate-faq-answer', { query });
      let answer = response.data?.answer || "Sorry, I couldn't find an answer to that question.";
      answer += disclaimer;
      await whatsappService.sendTextMessage(phone, answer);

      const lowerQuery = query.toLowerCase();
      if (SENSITIVE_KEYWORDS.some(keyword => lowerQuery.includes(keyword))) {
        console.log(`Sensitive keyword detected in "${query}". Escalating to admin inbox.`);
        await db.query( "INSERT INTO inbox_messages (user_phone, user_message, reason) VALUES ($1, $2, $3)", [phone, query, 'Sensitive Keyword Detected']);
        const escalationMessage = "It sounds like you might have a specific concern. I have notified an NGO volunteer, and they will contact you on this number shortly.";
        setTimeout(() => { whatsappService.sendTextMessage(phone, escalationMessage); }, 1500);
      }
    } catch (error) {
      console.error("Error calling FAQ service:", error.message);
      const fallbackMessage = "Thank you for your question. An NGO volunteer will get back to you shortly.";
      await whatsappService.sendTextMessage(phone, fallbackMessage);
    }
  }
}

export default new FaqService();

```

`backend/src/services/gamificationService.js`

```javascript
// backend/src/services/gamificationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

// A central place to define all possible achievements in the system.
const ACHIEVEMENTS = {
  FIRST_REGISTRATION: { name: 'Community Hero', points: 50, emoji: '❤️' },
  EMERGENCY_RESPONSE: { name: 'Life Saver', points: 100, emoji: '🚨' },
};

class GamificationService {
  /**
   * Awards points for a specific event, updates the user's total,
   * logs the achievement, and notifies the user.
   * @param {string} userId - The UUID of the user.
   * @param {string} event - The key for the achievement (e.g., 'FIRST_REGISTRATION').
   * @param {string} userPhone - The user's phone number for notification.
   */
  async awardPoints(userId, event, userPhone) {
    const achievement = ACHIEVEMENTS[event];
    if (!achievement) return;

    try {
      // Add points to the user's total score.
      const { rows: [user] } = await db.query(
        "UPDATE users SET gamification_points = gamification_points + $1 WHERE id = $2 RETURNING gamification_points",
        [achievement.points, userId]
      );

      if (!user) throw new Error("User not found or update failed.");

      // Log this specific achievement in the achievements table.
      await db.query(
        "INSERT INTO achievements(user_id, badge_type, points_awarded) VALUES($1, $2, $3)",
        [userId, achievement.name, achievement.points]
      );

      // Send a notification to the user.
      const notification = `🏆 Achievement Unlocked! 🏆\n\nYou've earned the *${achievement.name}* badge ${achievement.emoji} and received *${achievement.points} points*!\n\nYour new total is *${user.gamification_points} points*.`;
      await whatsappService.sendTextMessage(userPhone, notification);
    } catch (error) {
      console.error(`Error in awardPoints for user ${userId}:`, error);
    }
  }

  // --- THIS IS THE NEW, IMPLEMENTED FUNCTION ---
  /**
   * Fetches and formats a complete status report for a donor.
   * This is used by the 'get_my_dashboard' LangChain tool.
   * @param {string} phone - The donor's phone number.
   * @returns {string} A formatted message ready to be sent to the user.
   */
  async getDonorStatus(phone) {
    try {
      // 1. Get the user's main gamification data.
      const { rows: [user] } = await db.query(
        'SELECT id, name, gamification_points, last_donation FROM users WHERE phone = $1',
        [phone]
      );

      if (!user) {
        return "It looks like you're not registered as a donor yet. Reply with 'I want to register' to get started!";
      }

      // 2. Calculate the user's rank among all donors.
      const { rows: [rankData] } = await db.query(
        'SELECT count(*) FROM users WHERE user_type = \'donor\' AND gamification_points > $1',
        [user.gamification_points]
      );
      const rank = parseInt(rankData.count) + 1;

      // 3. Format the final message string.
      let statusMessage = `*📊 Your Donor Dashboard 📊*\n\n`;
      statusMessage += `*Name:* ${user.name}\n`;
      statusMessage += `*Points:* ${user.gamification_points} 🏅\n`;
      statusMessage += `*Current Rank:* #${rank} of all our heroes\n`;
      statusMessage += `*Last Donation:* ${user.last_donation ? new Date(user.last_donation).toLocaleDateString() : 'N/A'}`;
      
      // The function returns the complete string for the AI tool to use.
      return statusMessage;

    } catch (error) {
      console.error(`Error in getDonorStatus for phone ${phone}:`, error);
      return "Sorry, I couldn't fetch your status at this time. Please try again later.";
    }
  }
  // --- END OF NEW FUNCTION ---
}

export default new GamificationService();

```

`backend/src/services/geocodingService.js`

```javascript
// backend/src/services/geocodingService.js
import axios from 'axios';

class GeocodingService {
    async getCoords(address, city, pincode) {
        if (!address && !pincode) return null;
        const query = `${address || ''}, ${city || ''}, ${pincode || ''}`;
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
        try {
            const response = await axios.get(url, {
                headers: { 'User-Agent': 'BloodBridgeAI/1.0 (tech@bloodbridge.org)' }
            });
            if (response.data && response.data.length > 0) {
                const { lat, lon } = response.data[0];
                return { latitude: parseFloat(lat), longitude: parseFloat(lon) };
            }
            return null;
        } catch (error) {
            console.error('Error calling Geocoding API:', error.message);
            return null;
        }
    }
}

export default new GeocodingService();

```

`backend/src/services/mlService.js`

```javascript
// backend/src/services/mlService.js
import axios from 'axios';
import db from '../config/db.js';
import config from '../config/config.js';

const CACHE_DURATION_HOURS = 6;

class MLService {
    constructor() {
        this.client = axios.create({
            baseURL: config.mlServiceUrl,
            timeout: 8000,
        });
    }

    /**
     * Scores a single donor, using a cached score if available and not stale.
     */
    async scoreSingleDonor(donor) {
        // Check for a fresh score in the cache first.
        const { rows: [cachedData] } = await db.query(
            "SELECT last_ml_score, score_cached_at FROM users WHERE id = $1",
            [donor.id]
        );

        if (cachedData && cachedData.last_ml_score && cachedData.score_cached_at) {
            const cacheAgeHours = (new Date() - new Date(cachedData.score_cached_at)) / (1000 * 60 * 60);
            if (cacheAgeHours < CACHE_DURATION_HOURS) {
                console.log(`CACHE HIT: Using cached score for donor ${donor.id}`);
                return { final_score: cachedData.last_ml_score };
            }
        }

        console.log(`CACHE MISS: Calling ML service for donor ${donor.id}`);
        try {
            // If no fresh cache, call the Python ML service.
            const response = await this.client.post('/score-donor', {
                donor_id: donor.id,
                last_donation_date: donor.last_donation,
                streak_count: donor.streak_count || 0,
                notifications_received: donor.notifications_received || 0,
                donations_confirmed: donor.donations_confirmed || 0
            });
            
            const newScore = response.data.final_score;

            // Update the cache in the database with the new score.
            db.query(
                "UPDATE users SET last_ml_score = $1, score_cached_at = NOW() WHERE id = $2",
                [newScore, donor.id]
            ).catch(err => console.error(`Failed to cache ML score for donor ${donor.id}:`, err));

            return { final_score: newScore };

        } catch (error) {
            console.error(`🔴 ML Service Error for donor ${donor.id}:`, error.message);
            throw error; // Re-throw the error to be handled by the calling service.
        }
    }
}

export default new MLService();

```

`backend/src/services/patientService.js`

```javascript
// backend/src/services/patientService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class PatientService {
  /**
   * Handles the initial message from a potential patient.
   * Creates a pending record and asks them to opt-in by replying "APPLY".
   */
  async handleNewPatient(userMessage, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingPatient] } = await db.query("SELECT id FROM patients WHERE phone = $1", [sanitizedPhone]);
      if (existingPatient) {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back! Our records show you are already in our system. An admin will be in touch shortly.`);
        return;
      }

      // Create a blank, placeholder patient record to start the onboarding process.
      const patientName = 'Awaiting Input';
      const bloodGroup = 'N/A';
      const city = 'N/A';
      
      const { rows: [newPatient] } = await db.query(
        `INSERT INTO patients (name, phone, blood_group, city, status)
         VALUES ($1, $2, $3, $4, 'pending_opt_in') RETURNING id;`,
        [patientName, sanitizedPhone, bloodGroup, city]
      );
      
      console.log(`New patient lead logged. Patient ID: ${newPatient.id}`);
      
      // Always send the same opt-in message to start the conversation.
      await whatsappService.sendTextMessage(sanitizedPhone, `Thank you for reaching out. To begin your application for our Blood Bridge support program, please reply with: *APPLY*`);

    } catch (error) {
      console.error('Error in handleNewPatient:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'Sorry, we encountered an error logging your request.');
    }
  }
  
  /**
   * Starts the conversational form after the user replies "APPLY".
   */
  async startApplication(phone) {
      const { rows: [patient] } = await db.query("SELECT id FROM patients WHERE phone = $1 AND status = 'pending_opt_in'", [phone]);
      if (!patient) return false;

      await db.query("UPDATE patients SET status = 'pending_details' WHERE id = $1", [patient.id]);
      await this.continueOnboarding(patient.id, phone);
      return true;
  }

  /**
   * The "state machine" that asks the next question based on what info is missing.
   */
  async continueOnboarding(patientId, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE id = $1", [patientId]);
    if (!patient) return;

    if (patient.name === 'Awaiting Input') {
      await whatsappService.sendTextMessage(phone, "Great! Let's begin.\n\nFirst, what is the patient's full name?");
      return;
    }
    if (patient.blood_group === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Thank you. What is ${patient.name}'s blood group? (e.g., O+, AB-)`);
      return;
    }
    if (patient.city === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Got it. In which city does the patient receive treatment?`);
      return;
    }

    // All details are collected.
    await db.query("UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    const finalMessage = `Thank you! We have all the initial information we need for *${patient.name}*.\n\nAn admin has been notified and will contact you on this number to verify the details.`;
    await whatsappService.sendTextMessage(phone, finalMessage);
  }

  /**
   * Processes a user's reply during the conversational form.
   */
  async processOnboardingReply(message, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE phone = $1 AND status = 'pending_details'", [phone]);
    if (!patient) return false;

    let columnToUpdate = null;
    let valueToUpdate = message;
    
    if (patient.name === 'Awaiting Input') columnToUpdate = 'name';
    else if (patient.blood_group === 'N/A') {
      columnToUpdate = 'blood_group';
      valueToUpdate = normalizeBloodGroup(message);
    } else if (patient.city === 'N/A') columnToUpdate = 'city';
    
    if (columnToUpdate) {
        await db.query(`UPDATE patients SET ${columnToUpdate} = $1 WHERE id = $2`, [valueToUpdate, patient.id]);
        
        // Ask the next question after a short delay
        setTimeout(() => { this.continueOnboarding(patient.id, phone); }, 500);
        return true;
    }
    return false;
  }
}

export default new PatientService();

```

`backend/src/services/registrationService.js`

```javascript
// backend/src/services/registrationService.js
import db from '../config/db.js';
import whatsappService from '../services/whatsappService.js';
import gamificationService from './gamificationService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';

class RegistrationService {
  async handleNewDonor(params, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);

    try {
      const { rows: [existingUser] } = await db.query(
        "SELECT id, name, city, blood_group, registration_status FROM users WHERE phone = $1",
        [sanitizedPhone]
      );

      const { name, city, blood_group } = params;

      // ✅ CASE 1: Already registered
      if (existingUser && existingUser.registration_status === 'completed') {
        const msg = `Welcome back, ${existingUser.name}! You are already registered and ready to help.`;
        await whatsappService.sendTextMessage(sanitizedPhone, msg);
        return {
          status: 'complete',
          user: existingUser,
          needs: [],
          message: msg
        };
      }

      // ✅ CASE 2: User provides all details (complete registration in one go)
      if (name && city && blood_group) {
        const normalizedBG = normalizeBloodGroup(blood_group);
        let newUser;

        if (existingUser) {
          // Update pending → completed
          const { rows } = await db.query(
            `UPDATE users
             SET name = $1, city = $2, blood_group = $3,
                 registration_status = 'completed',
                 role = 'Emergency Donor',
                 user_type = 'donor'
             WHERE id = $4
             RETURNING *;`,
            [name, city, normalizedBG, existingUser.id]
          );
          newUser = rows[0];
        } else {
          // Fresh complete registration
          const { rows } = await db.query(
            `INSERT INTO users(name, city, blood_group, phone, user_type, registration_status, role)
             VALUES($1, $2, $3, $4, 'donor', 'completed', 'Emergency Donor')
             RETURNING *;`,
            [name, city, normalizedBG, sanitizedPhone]
          );
          newUser = rows[0];
        }

        const successMessage =
          `✅ Registration Complete!\n\nWelcome, ${newUser.name}! ` +
          `You are now a registered Blood Warrior in ${newUser.city}.`;

        await whatsappService.sendTextMessage(sanitizedPhone, successMessage);
        await gamificationService.awardPoints(newUser.id, 'FIRST_REGISTRATION', sanitizedPhone);

        return {
          status: 'complete',
          user: newUser,
          needs: [],
          message: successMessage
        };
      }

      // ✅ CASE 3: User says "I want to register" (no details)
      if (!existingUser) {
        // Only create placeholder if not already present
        console.log(`Creating a new 'pending' donor record for ${sanitizedPhone}.`);
        await db.query(
          `INSERT INTO users(name, phone, user_type, registration_status, role)
           VALUES ($1, $2, 'donor', 'pending', 'Unregistered')`,
          ['Pending User', sanitizedPhone]
        );
      }

      const followupMessage =
        "Thank you for your interest! To complete your registration, " +
        "please reply with your details in this format:\n\n" +
        "*Register: [Your Name], [Your City], [Your Blood Group]*";

      await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);

      return {
        status: 'partial',
        user: existingUser || { phone: sanitizedPhone, registration_status: 'pending' },
        needs: ['name', 'city', 'blood_group'],
        message: followupMessage
      };
    } catch (error) {
      console.error('Critical error in handleNewDonor:', error);

      const errMsg = 'We encountered an error during registration. Please try again later.';
      await whatsappService.sendTextMessage(sanitizedPhone, errMsg);

      return {
        status: 'error',
        user: null,
        needs: [],
        message: errMsg
      };
    }
  }
}

export default new RegistrationService();

```

`backend/src/services/responseService.js`

```javascript
// backend/src/services/responseService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateOTP } from '../utils/otpHelper.js';
import gamificationService from './gamificationService.js';
import bridgeService from './bridgeService.js';
import BridgeCoordinationService from './bridgeCoordinationService.js';

class ResponseService {
    /**
     * Handles the donor's initial reply (e.g., "YES 1234").
     * It validates the code and sends back a 6-digit OTP to verify.
     */
    async handleDonorReplyWithShortCode(donorPhone, shortCode) {
        try {
            const { rows: [request] } = await db.query(`SELECT id FROM emergency_requests WHERE short_code = $1 AND status = 'active'`, [shortCode]);
            if (!request) {
                await whatsappService.sendTextMessage(donorPhone, `Sorry, we couldn't find an active request with code ${shortCode}. It may have been fulfilled.`);
                return;
            }

            const { rows: [user] } = await db.query(`SELECT id FROM users WHERE phone = $1`, [donorPhone]);
            if (!user) {
                await whatsappService.sendTextMessage(donorPhone, "We couldn't find your registration. Please register first.");
                return;
            }

            const otp = generateOTP();
            await db.query(
                `INSERT INTO donor_responses (donor_id, request_id, response, otp, otp_expires_at)
                 VALUES ($1, $2, 'pending', $3, NOW() + INTERVAL '10 minutes')
                 ON CONFLICT (donor_id, request_id) DO UPDATE SET response = 'pending', otp = $3, otp_expires_at = NOW() + INTERVAL '10 minutes';`,
                [user.id, request.id, otp]
            );

            const otpMessage = `Thank you for your quick response! To finalize your confirmation, please reply with *only* the following 6-digit code:\n\n*${otp}*`;
            await whatsappService.sendTextMessage(donorPhone, otpMessage);
        } catch (error) {
            console.error('Error in handleDonorReplyWithShortCode:', error);
            await whatsappService.sendTextMessage(donorPhone, "There was a system error processing your reply.");
        }
    }

    /**
     * Verifies the 6-digit OTP and finalizes the donation confirmation.
     * This function uses a database transaction to ensure all updates succeed or none do.
     */
    // In responseService.js
async verifyOTPAndConfirm(donorPhone, otp) {
    const client = await db.pool.connect();
    try {
        await client.query('BEGIN');

        const { rows: [response] } = await client.query(
            // Add request_type and bridge_id to the SELECT statement
            `SELECT dr.id, dr.request_id, u.name as donor_name, u.id as donor_id, 
                    er.patient_name, er.requested_by_phone, er.request_type, er.bridge_id
             FROM donor_responses dr JOIN users u ON dr.donor_id = u.id JOIN emergency_requests er ON dr.request_id = er.id
             WHERE u.phone = $1 AND dr.otp = $2 AND dr.otp_expires_at > NOW() AND dr.response = 'pending' FOR UPDATE;`,
            [donorPhone, otp]
        );

        if (!response) {
            await whatsappService.sendTextMessage(donorPhone, "Invalid or expired OTP. Please try the 'YES [code]' step again.");
            await client.query('ROLLBACK');
            return;
        }

        // Perform all database updates
        await client.query(`UPDATE users SET last_donation = NOW(), availability_status = 'unavailable', cooldown_until = NOW() + INTERVAL '90 days', donations_confirmed = donations_confirmed + 1, streak_count = streak_count + 1 WHERE id = $1`, [response.donor_id]);
        await client.query("UPDATE donor_responses SET response = 'accepted', confirmed_at = NOW(), otp = NULL WHERE id = $1", [response.id]);
        await client.query("UPDATE emergency_requests SET status = 'fulfilled' WHERE id = $1", [response.request_id]);
        
        // --- NEW LOGIC: ROTATE THE BRIDGE IF APPLICABLE ---
        // We pass the active transaction client to the rotation function
        if (response.request_type === 'bridge' && response.bridge_id) {
            await bridgeCoordinationService.rotateBridge(response.bridge_id, client);
        }
        // --- END NEW LOGIC ---

        await client.query('COMMIT');

        // Send confirmations and award points
        const donorConfirmationMessage = `✅ Confirmed! Thank you, ${response.donor_name}!\n\nYour donation for *${response.patient_name}* is confirmed. Please coordinate with the hospital. You are a true hero!`;
        await whatsappService.sendTextMessage(donorPhone, donorConfirmationMessage);

        if (response.requested_by_phone && response.requested_by_phone !== 'system') {
            const requesterUpdate = `✅ Good News! A donor has been confirmed for your request for *${response.patient_name}*.`;
            await whatsappService.sendTextMessage(response.requested_by_phone, requesterUpdate);
        }
        gamificationService.awardPoints(response.donor_id, 'EMERGENCY_RESPONSE', donorPhone);

    } catch (error) {
        await client.query('ROLLBACK');
        console.error("Error verifying OTP:", error);
        await whatsappService.sendTextMessage(donorPhone, "A system error occurred during OTP verification.");
    } finally {
        client.release();
    }
}
}

export default new ResponseService();

```

`backend/src/services/whatsappService.js`

```javascript
// backend/src/services/whatsappService.js
import axios from 'axios';
import config from '../config/config.js';

class WhatsAppService {
  constructor() {
    this.token = config.whatsappToken;
    this.phoneNumberId = config.whatsappPhoneNumberId;

    if (!this.token || !this.phoneNumberId) {
      console.warn('WhatsApp token or Phone Number ID are missing from configuration. Messages will not be sent.');
    }

    this.client = axios.create({
      baseURL: `https://graph.facebook.com/v18.0/${this.phoneNumberId}`,
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Content-Type': 'application/json'
      }
    });
  }

  /**
   * Sends a text message.
   * @param {string} to - The recipient's phone number (e.g., '918000000000').
   * @param {string} text - The message body.
   */
  async sendTextMessage(to, text) {
    if (!this.token) return { success: false, error: "WhatsApp service not configured." };

    const payload = {
      messaging_product: 'whatsapp',
      to: to,
      type: 'text',
      text: { body: text }
    };
    try {
      const response = await this.client.post('/messages', payload);
      console.log(`✅ Message sent successfully to ${to}.`);
      return { success: true, data: response.data };
    } catch (error) {
      console.error(`🔴 FAILED to send message to ${to}.`);
      if (error.response) {
        console.error(`Error Details: ${error.response.data.error?.message}`);
      }
      return { success: false, error: error.message };
    }
  }
}

export default new WhatsAppService();

```

`backend/src/utils/dataSanitizer.js`

```javascript
// backend/src/utils/dataSanitizer.js
export const normalizeBloodGroup = (group) => {
  if (!group) return 'Unknown';
  const upperGroup = group.toUpperCase();
  let normalized = upperGroup.replace(/\s/g, '').replace('POSITIVE', '+').replace('NEGATIVE', '-');
  if (normalized.endsWith('POS')) normalized = normalized.replace('POS', '+');
  if (normalized.endsWith('NEG')) normalized = normalized.replace('NEG', '-');
  return normalized.slice(0, 5);
};

```

`backend/src/utils/distanceHelper.js`

```javascript
// backend/src/utils/distanceHelper.js
/**
 * Calculates distance between two lat/lng points in km using the Haversine formula.
 */
export const getDistanceInKm = (lat1, lon1, lat2, lon2) => {
    if ((lat1 == lat2) && (lon1 == lon2)) {
        return 0;
    }
    const R = 6371; // Radius of the earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        0.5 - Math.cos(dLat) / 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        (1 - Math.cos(dLon)) / 2;
    return R * 2 * Math.asin(Math.sqrt(a));
};

```

`backend/src/utils/otpHelper.js`

```javascript
// backend/src/utils/otpHelper.js

/**
 * Generates a 4-digit numeric code for donors to reply with.
 * @returns {string} A 4-digit string.
 */
export const generateShortCode = () => {
  return Math.floor(1000 + Math.random() * 9000).toString();
};

/**
 * Generates a 6-digit numeric OTP for final confirmation.
 * @returns {string} A 6-digit string.
 */
export const generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

```

`backend/src/utils/phoneHelper.js`

```javascript
// backend/src/utils/phoneHelper.js
export const normalizePhoneNumber = (phone) => {
  if (!phone || typeof phone !== 'string') return null;
  let digits = phone.replace(/\D/g, '');
  if (digits.startsWith('91') && digits.length === 12) {
    return `+${digits}`;
  } else if (digits.length === 10) {
    return `+91${digits}`;
  }
  return `+${digits}`;
};

```

`code.txt`

```
`admin-dashboard/code2.txt`

```
`code.txt`

```
`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`src/App.jsx`

```javascript
// src/App.jsx

import React, { useState } from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import LoginPage from './LoginPage.jsx';
import Dashboard from './Dashboard.jsx';
import theme from './theme.js';

/**
 * The main App component.
 * It acts as the root of the application, managing authentication state
 * and providing the global MUI theme.
 */
function App() {
  // State to track if the user is logged in. Default is false.
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  // Function to be passed to LoginPage to handle successful login
  const handleLogin = () => {
    setIsLoggedIn(true);
  };

  // Function to be passed to Dashboard to handle logout
  const handleLogout = () => {
    setIsLoggedIn(false);
  };

  return (
    // ThemeProvider applies the custom theme to all descendant components.
    // CssBaseline provides a consistent baseline style across browsers.
    <ThemeProvider theme={theme}>
      <CssBaseline />
      {/* Conditionally render Dashboard or LoginPage based on login state */}
      {isLoggedIn ? (
        <Dashboard onLogout={handleLogout} />
      ) : (
        <LoginPage onLogin={handleLogin} />
      )}
    </ThemeProvider>
  );
}

export default App;

```

`src/Dashboard.jsx`

```javascript
// src/Dashboard.jsx

import React, { useState, useEffect } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Grid, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress,
  Button,
} from "@mui/material";

import { Bloodtype, LocationCity, AddLink, Close } from "@mui/icons-material";

// ✅ Dummy API functions (replace with real API calls)
const fetchPendingPatients = async () =>
  Promise.resolve([
    { id: 1, name: "John Doe", blood_group: "A+", city: "Delhi" },
    { id: 2, name: "Jane Smith", blood_group: "O-", city: "Mumbai" },
  ]);

const fetchActiveEmergencies = async () =>
  Promise.resolve([
    { id: 3, patient_name: "Alex", blood_group: "B+", status: "Urgent" },
    { id: 4, patient_name: "Maria", blood_group: "AB-", status: "Open" },
  ]);

const Dashboard = ({ onLogout }) => {
  const [tabValue, setTabValue] = useState(0);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm")); // <600px
  const isTablet = useMediaQuery(theme.breakpoints.between("sm", "md")); // 600-900px
  const isLaptop = useMediaQuery(theme.breakpoints.between("md", "lg")); // 900-1200px

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      const apiCall = tabValue === 0 ? fetchPendingPatients : fetchActiveEmergencies;
      const result = await apiCall();
      setData(result);
      setLoading(false);
    };
    loadData();
  }, [tabValue]);

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // ✅ Card list for small & medium screens
  const renderCardList = () => (
    <Grid container spacing={2}>
      {data.map((item) => (
        <Grid item xs={12} sm={6} md={4} key={item.id}>
          <Card variant="outlined" sx={{ height: "100%" }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                {tabValue === 0 ? item.name : item.patient_name}
              </Typography>
              <Stack direction="column" spacing={1}>
                <Chip
                  icon={<Bloodtype />}
                  label={`Blood Group: ${item.blood_group}`}
                  size="small"
                />
                {tabValue === 0 ? (
                  <Chip
                    icon={<LocationCity />}
                    label={`City: ${item.city}`}
                    size="small"
                  />
                ) : (
                  <Chip label={`Status: ${item.status}`} color="warning" size="small" />
                )}
              </Stack>
            </CardContent>
            <CardActions sx={{ justifyContent: "flex-end" }}>
              {tabValue === 0 ? (
                <Button variant="contained" size="small" startIcon={<AddLink />}>
                  Create Bridge
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="secondary"
                  size="small"
                  startIcon={<Close />}
                >
                  Close Request
                </Button>
              )}
            </CardActions>
          </Card>
        </Grid>
      ))}
    </Grid>
  );

  // ✅ Table for larger screens (Laptop & Desktop)
  const renderTable = () => (
    <TableContainer>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>{tabValue === 0 ? "Name" : "Patient Name"}</TableCell>
            <TableCell>Blood Group</TableCell>
            <TableCell>{tabValue === 0 ? "City" : "Status"}</TableCell>
            <TableCell align="right">Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {data.map((item) => (
            <TableRow hover key={item.id}>
              <TableCell>{tabValue === 0 ? item.name : item.patient_name}</TableCell>
              <TableCell>
                <Chip
                  label={item.blood_group}
                  color="primary"
                  variant="outlined"
                  size="small"
                />
              </TableCell>
              <TableCell>
                {tabValue === 0 ? (
                  item.city
                ) : (
                  <Chip label={item.status} color="warning" size="small" />
                )}
              </TableCell>
              <TableCell align="right">
                {tabValue === 0 ? (
                  <Button variant="contained" size="small" startIcon={<AddLink />}>
                    Create Bridge
                  </Button>
                ) : (
                  <Button
                    variant="contained"
                    color="secondary"
                    size="small"
                    startIcon={<Close />}
                  >
                    Close Request
                  </Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );

// inside src/Dashboard.jsx — modify the JSX return where Container is used:

  return (
    <Box
      sx={{
        flexGrow: 1,
        backgroundColor: theme.palette.background.default,
        minHeight: "100vh",
      }}
    >
      {/* AppBar stays full width of viewport */}
      <AppBar position="static" sx={{ boxShadow: 1 }}>
        <Toolbar sx={{ px: { xs: 2, md: 4 } }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            🩸 BloodBridge AI
          </Typography>
          <Button color="inherit" onClick={onLogout}>
            Logout
          </Button>
        </Toolbar>
      </AppBar>

      {/* Make container span full width but keep inner content centered with a maxWidth */}
      <Container
        maxWidth={false}
        disableGutters
        sx={{
          px: { xs: 2, md: 4 },
          py: 4,
        }}
      >
        {/* center the page content while allowing it to be fluid on small screens */}
        <Box sx={{ width: "100%", maxWidth: 1100, mx: "auto" }}>
          <Typography variant="h4" gutterBottom>
            Admin Dashboard
          </Typography>

          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Box sx={{ borderBottom: 1, borderColor: "divider", mb: 3 }}>
              <Tabs value={tabValue} onChange={handleTabChange}>
                <Tab label="Pending Patients" />
                <Tab label="Active Emergencies" />
              </Tabs>
            </Box>

            {loading ? (
              <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
                <CircularProgress />
              </Box>
            ) : (
              // responsive decision: cards for small/tablet, table for larger screens
              (isMobile || isTablet) ? renderCardList() : renderTable()
            )}
          </Paper>
        </Box>
      </Container>
    </Box>
  );

};

export default Dashboard;

```

`src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`src/LoginPage.jsx`

```javascript
// src/LoginPage.jsx

import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert } from '@mui/material';

/**
 * The LoginPage component.
 * It displays a simple login form and validates the password.
 * On successful validation, it calls the onLogin prop function.
 */
const LoginPage = ({ onLogin }) => {
  // State to hold the password input value
  const [password, setPassword] = useState('');
  // State to hold any login error messages
  const [error, setError] = useState('');

  // Handles the form submission
  const handleSubmit = (event) => {
    event.preventDefault(); // Prevent default form submission behavior

    // Simple validation: check if the password is "admin"
    if (password === 'admin') {
      setError(''); // Clear any previous errors
      onLogin(); // Call the parent component's login handler
    } else {
      // Set an error message for incorrect password
      setError('Incorrect password. Hint: try "admin"');
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Typography component="h1" variant="h5">
          🩸 BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {/* Display an error alert if the error state is not empty */}
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2 }}
          >
            Sign In
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;   

```

`src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

// It's good practice to have a minimal CSS reset or base styles.
// You can leave the default index.css or make it an empty file for now.
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

`src/mockApi.js`

```javascript
// src/mockApi.js

/**
 * This file acts as a fake backend API.
 * The functions here simulate network requests by returning a Promise
 * that resolves with mock data after a 500ms delay.
 */

// Mock data for the "Pending Patients" tab
const mockPendingPatients = [
  { "id": "p1", "name": "Aarav Sharma", "blood_group": "A+", "city": "Delhi" },
  { "id": "p2", "name": "Saanvi Gupta", "blood_group": "O-", "city": "Mumbai" },
  { "id": "p3", "name": "Vihaan Reddy", "blood_group": "B+", "city": "Bangalore" },
  { "id": "p4", "name": "Diya Singh", "blood_group": "AB-", "city": "Kolkata" }
];

// Mock data for the "Active Emergencies" tab
const mockActiveEmergencies = [
  { "id": "e1", "patient_name": "Isha Patel", "blood_group": "AB+", "status": "Searching" },
  { "id": "e2", "patient_name": "Rohan Kumar", "blood_group": "O+", "status": "Partially Fulfilled" },
  { "id": "e3", "patient_name": "Ananya Joshi", "blood_group": "A-", "status": "Critical" }
];

/**
 * Fetches a list of pending patients.
 * @returns {Promise<Array<Object>>} A promise that resolves to the patient list.
 */
export const fetchPendingPatients = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockPendingPatients);
    }, 500); // 500ms delay to simulate network latency
  });
};

/**
 * Fetches a list of active emergencies.
 * @returns {Promise<Array<Object>>} A promise that resolves to the emergencies list.
 */
export const fetchActiveEmergencies = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockActiveEmergencies);
    }, 500); // 500ms delay to simulate network latency
  });
};

```

`src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

```

`admin-dashboard/eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`admin-dashboard/index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`admin-dashboard/src/api/apiClient.js`

```javascript
// src/api/apiClient.js
import axios from 'axios';

const BASE = (import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001').replace(/\/$/, '');

const apiClient = axios.create({
  baseURL: BASE,
  headers: { 'Content-Type': 'application/json' },
  timeout: 20000,
});

// simple map to avoid spamming same error repeatedly
const loggedUrls = new Set();

apiClient.interceptors.request.use((config) => {
  const url = config.url || '';
  // attach token for everything except login/register
  if (!url.includes('/login') && !url.includes('/register')) {
    const token = localStorage.getItem('token');
    if (token && typeof token === 'string' && token.split('.').length === 3) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }
  return config;
});

apiClient.interceptors.response.use(
  (res) => res,
  (err) => {
    const out = {
      url: err.config?.url,
      status: err.response?.status,
      message: err.message,
      data: err.response?.data,
    };

    // Log each failing URL once to reduce noise
    if (!loggedUrls.has(out.url)) {
      loggedUrls.add(out.url);
      console.error('API request failed:', out);
    }

    const normalized = new Error(out.message || 'API error');
    normalized.url = out.url;
    normalized.status = out.status;
    normalized.data = out.data;
    return Promise.reject(normalized);
  }
);

export default apiClient;

```

`admin-dashboard/src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`admin-dashboard/src/App.jsx`

```javascript
// admin-dashboard/src/App.jsx
import React from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import { AuthProvider } from './context/AuthContext.jsx';
import { Routes, Route, Navigate } from 'react-router-dom'; // ✅ IMPORT ROUTER COMPONENTS
import theme from './theme.js';
import LoginPage from './pages/LoginPage.jsx';
import DashboardPage from './pages/Dashboard.jsx';
import { useAuth } from './hooks/useAuth.js';

/**
 * A protected route component. If the user is not logged in,
 * it redirects them to the login page.
 */
const ProtectedRoute = ({ children }) => {
  const { isLoggedIn } = useAuth();
  return isLoggedIn ? children : <Navigate to="/" />;
};

/**
 * The main App component, now with a proper routing structure.
 */
function App() {
  return (
    <AuthProvider>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <Routes>
          <Route path="/" element={<LoginPage />} />
          <Route 
            path="/dashboard" 
            element={
              <ProtectedRoute>
                <DashboardPage />
              </ProtectedRoute>
            } 
          />
        </Routes>
      </ThemeProvider>
    </AuthProvider>
  );
}

export default App;

```

`admin-dashboard/src/components/common/ConfirmationDialog.jsx`

```javascript
// src/components/common/ConfirmationDialog.jsx
import React, { useState, useCallback } from 'react';
import PropTypes from 'prop-types';
import {
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from '@mui/material';

/**
 * Reusable confirmation dialog.
 * - Awaits async onConfirm handlers before closing.
 * - Disables buttons while processing to avoid duplicate calls.
 */
const ConfirmationDialog = ({ open, onClose, onConfirm, title, message, confirmText = 'Confirm', cancelText = 'Cancel' }) => {
  const [processing, setProcessing] = useState(false);

  const handleConfirm = useCallback(async () => {
    if (processing) return;
    setProcessing(true);
    try {
      if (typeof onConfirm === 'function') {
        // Call handler and await if it returns a promise
        const result = onConfirm();
        if (result && typeof result.then === 'function') {
          await result;
        }
      }
    } catch (err) {
      // Log — parent can set error state if needed
      // Avoid swallowing errors silently in prod; you may surface this to UI
      // eslint-disable-next-line no-console
      console.error('ConfirmationDialog onConfirm error:', err);
    } finally {
      setProcessing(false);
      if (typeof onClose === 'function') onClose();
    }
  }, [onConfirm, onClose, processing]);

  return (
    <Dialog
      open={Boolean(open)}
      onClose={() => {
        if (!processing && typeof onClose === 'function') onClose();
      }}
      aria-labelledby="confirmation-dialog-title"
      aria-describedby="confirmation-dialog-description"
      fullWidth
      maxWidth="xs"
    >
      <DialogTitle id="confirmation-dialog-title">{title}</DialogTitle>
      <DialogContent>
        <DialogContentText id="confirmation-dialog-description">
          {message}
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={() => { if (!processing && typeof onClose === 'function') onClose(); }} disabled={processing}>
          {cancelText}
        </Button>

        <Button
          onClick={handleConfirm}
          color="primary"
          variant="contained"
          autoFocus
          disabled={processing}
        >
          {confirmText}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

ConfirmationDialog.propTypes = {
  open: PropTypes.bool,
  onClose: PropTypes.func,
  onConfirm: PropTypes.func,
  title: PropTypes.string,
  message: PropTypes.string,
  confirmText: PropTypes.string,
  cancelText: PropTypes.string,
};

ConfirmationDialog.defaultProps = {
  open: false,
  onClose: () => {},
  onConfirm: null,
  title: 'Confirm',
  message: '',
  confirmText: 'Confirm',
  cancelText: 'Cancel',
};

export default React.memo(ConfirmationDialog);

```

`admin-dashboard/src/components/dashboard/BloodGroupChart.jsx`

```javascript
// src/components/dashboard/BloodGroupChart.jsx
import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
} from 'recharts';
import { Box, Typography, useTheme } from '@mui/material';

/**
 * A responsive bar chart to display blood group distribution.
 * Expects data shape: [{ blood_group: 'A+', count: 10 }, ...]
 */
const BloodGroupChart = ({ data }) => {
  const theme = useTheme();

  // Defensive: normalize/sort data so chart is stable
  const prepared = useMemo(() => {
    if (!Array.isArray(data)) return [];
    // ensure numeric counts and stable ordering (by blood_group)
    return [...data]
      .map((d) => ({ blood_group: d.blood_group ?? 'Unknown', count: Number(d.count) || 0 }))
      .sort((a, b) => {
        // you can sort by count desc: return b.count - a.count;
        // here we sort by blood_group for predictable axis order
        return a.blood_group.localeCompare(b.blood_group);
      });
  }, [data]);

  if (!prepared || prepared.length === 0) {
    return (
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: 300 }}>
        <Typography color="text.secondary">No chart data available.</Typography>
      </Box>
    );
  }

  return (
    // aria-label helps screen readers understand this visual
    <Box role="img" aria-label="Donor distribution by blood group">
      <ResponsiveContainer width="100%" height={300}>
        <BarChart
          data={prepared}
          margin={{ top: 6, right: 16, left: -12, bottom: 6 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke={theme.palette.divider} />
          <XAxis dataKey="blood_group" stroke={theme.palette.text.secondary} />
          <YAxis stroke={theme.palette.text.secondary} allowDecimals={false} />
          <Tooltip
            contentStyle={{
              backgroundColor: theme.palette.background.paper,
              borderColor: theme.palette.divider,
            }}
            formatter={(value) => [value, 'Donors']}
          />
          <Legend />
          <Bar dataKey="count" name="Total Donors" fill={theme.palette.primary.main} />
        </BarChart>
      </ResponsiveContainer>
    </Box>
  );
};

BloodGroupChart.propTypes = {
  data: PropTypes.arrayOf(
    PropTypes.shape({
      blood_group: PropTypes.string,
      count: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    })
  ),
};

BloodGroupChart.defaultProps = {
  data: [],
};

export default React.memo(BloodGroupChart);

```

`admin-dashboard/src/components/dashboard/StatCard.jsx`

```javascript
// src/components/dashboard/StatCard.jsx
import React from "react";
import PropTypes from "prop-types";
import { Paper, Box, Typography, Avatar, useTheme } from "@mui/material";

/**
 * A reusable component to display a single dashboard statistic.
 *
 * Props:
 * - icon: React node shown inside the Avatar
 * - title: short label for the stat
 * - value: numeric or string value to display
 * - color: theme token or CSS color for Avatar background (e.g. "primary.main")
 */
const StatCard = ({ icon, title, value, color = "primary.main" }) => {
  const theme = useTheme();

  // Resolve theme token like "primary.main" to an actual color string
  const resolvedColor = (() => {
    if (!color) return undefined;
    // if color contains a dot, treat as theme token
    if (typeof color === "string" && color.includes(".")) {
      const [paletteKey, shade] = color.split(".");
      return theme.palette?.[paletteKey]?.[shade] ?? color;
    }
    return color;
  })();

  // Format numbers nicely (1000 -> 1,000)
  const formattedValue =
    typeof value === "number"
      ? new Intl.NumberFormat().format(value)
      : value ?? "—";

  return (
    <Paper
      elevation={3}
      sx={{
        p: 2,
        display: "flex",
        alignItems: "center",
        height: "100%",
      }}
      role="region"
      aria-label={`${title} stat`}
      title={`${title}: ${formattedValue}`}
    >
      <Avatar
        sx={{
          bgcolor: resolvedColor,
          width: 56,
          height: 56,
          mr: 2,
          color: (theme.palette.getContrastText
            ? theme.palette.getContrastText(resolvedColor)
            : "#fff"),
        }}
        aria-hidden="true"
      >
        {icon}
      </Avatar>

      <Box sx={{ minWidth: 0 }}>
        <Typography color="text.secondary" noWrap variant="caption">
          {title}
        </Typography>
        <Typography variant="h5" component="div" fontWeight="bold" noWrap>
          {formattedValue}
        </Typography>
      </Box>
    </Paper>
  );
};

StatCard.propTypes = {
  icon: PropTypes.node,
  title: PropTypes.string.isRequired,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  color: PropTypes.string,
};

StatCard.defaultProps = {
  icon: null,
  value: "0",
  color: "primary.main",
};

export default React.memo(StatCard);

```

`admin-dashboard/src/context/AuthContext.jsx`

```javascript
// src/context/AuthContext.jsx
import React, { createContext, useState } from 'react';

// 1. Create the context
// This object will be used by other components to access the auth state.
export const AuthContext = createContext(null);

// 2. Create the Provider component
// This component will wrap our application and provide the auth state.
export const AuthProvider = ({ children }) => {
  // Initialize the token state by reading from localStorage.
  // This ensures that the user remains logged in even after a page refresh.
  const [token, setToken] = useState(localStorage.getItem('token'));

  // The login function saves the token to both localStorage and the state.
  const login = (newToken) => {
    localStorage.setItem('token', newToken);
    setToken(newToken);
  };

  // The logout function removes the token from localStorage and the state.
  const logout = () => {
    localStorage.removeItem('token');
    setToken(null);
  };

  // 3. Define the value to be provided by the context
  // We derive `isLoggedIn` directly from the presence of a token.
  const value = {
    token,
    isLoggedIn: !!token,
    login,
    logout,
  };

  // 4. Return the provider with the value, wrapping any child components.
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

```

`admin-dashboard/src/hooks/useAuth.js`

```javascript
// src/hooks/useAuth.js
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext.jsx';

/**
 * A custom hook for accessing the AuthContext.
 * This simplifies the process in any component that needs auth data,
 * as we can just call `useAuth()` instead of `useContext(AuthContext)`.
 */
export const useAuth = () => {
  return useContext(AuthContext);
};

```

`admin-dashboard/src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`admin-dashboard/src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom'; // <-- 1. IMPORT THE ROUTER
import App from './App.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    {/* 2. WRAP YOUR APP WITH THE ROUTER */}
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

```

`admin-dashboard/src/pages/Dashboard.jsx`

```javascript
// admin-dashboard/src/pages/Dashboard.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress, Button, Alert,
  Badge, Grid, Snackbar
} from "@mui/material";
import {
  Bloodtype, LocationCity, AddLink, Close, Logout,
  PeopleAlt, Favorite, Healing, Warning,
  Dashboard as DashboardIcon, Inbox as InboxIcon,
  People as PeopleIcon, Emergency as EmergencyIcon,
  Hub as HubIcon, ShowChart as ShowChartIcon,
  CheckCircleOutline as CheckCircleOutlineIcon,
  NotificationImportant as EscalationIcon,
  AddCircleOutline as AddCircleOutlineIcon
} from "@mui/icons-material";
import { createClient } from '@supabase/supabase-js';

import { useAuth } from "../hooks/useAuth.js";
import apiClient from "../api/apiClient.js";
import StatCard from "../components/dashboard/StatCard.jsx";
import BloodGroupChart from "../components/dashboard/BloodGroupChart.jsx";
import ConfirmationDialog from "../components/common/ConfirmationDialog.jsx";

// --- INITIALIZE SUPABASE CLIENT ---
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseAnonKey);

const normalizeList = (res) => {
  if (!res) return [];
  if (Array.isArray(res)) return res;
  const d = res.data;
  if (Array.isArray(d)) return d;
  if (d && Array.isArray(d.data)) return d.data;
  return [];
};

const TabPanel = ({ children, value, index, ...other }) => (
  <div role="tabpanel" hidden={value !== index} {...other}>
    {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
  </div>
);

const getDueDateInfo = (dueDate) => {
  if (!dueDate) return { text: 'N/A', color: 'text.secondary', days: Infinity };
  const today = new Date();
  const nextDate = new Date(dueDate);
  today.setHours(0, 0, 0, 0);
  nextDate.setHours(0, 0, 0, 0);
  const diffTime = nextDate - today;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays < 0) return { text: `OVERDUE by ${Math.abs(diffDays)} days`, color: 'error.main', days: diffDays };
  if (diffDays === 0) return { text: 'DUE TODAY', color: 'error.main', days: diffDays };
  if (diffDays <= 7) return { text: `Due in ${diffDays} days`, color: 'warning.main', days: diffDays };
  return { text: `Due in ${diffDays} days`, color: 'text.primary', days: diffDays };
};

const DashboardPage = () => {
  const { logout } = useAuth();
  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down("md"));
  const [currentTab, setCurrentTab] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [snackbar, setSnackbar] = useState({ open: false, message: '' });
  const [dialogConfig, setDialogConfig] = useState({ open: false, title: '', message: '', onConfirm: () => {} });

  const [stats, setStats] = useState({});
  const [bloodGroupData, setBloodGroupData] = useState([]);
  const [inboxMessages, setInboxMessages] = useState([]);
  const [pendingPatients, setPendingPatients] = useState([]);
  const [monitoredPatients, setMonitoredPatients] = useState([]);
  const [emergencies, setEmergencies] = useState([]);
  const [bridges, setBridges] = useState([]);
  const [leaderboard, setLeaderboard] = useState([]);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError('');
    try {
      const [
        statsRes, 
        bloodGroupRes, 
        patientsRes, 
        emergenciesRes, 
        bridgesRes, 
        inboxRes,
        leaderboardRes
      ] = await Promise.all([
        apiClient.get('/api/admin/stats'),
        apiClient.get('/api/admin/stats/blood-groups'),
        apiClient.get('/api/admin/patients'),
        apiClient.get('/api/admin/emergencies'),
        apiClient.get('/api/admin/bridges'),
        apiClient.get('/api/admin/inbox'),
        apiClient.get('/api/admin/leaderboard')
      ]);

      setStats(statsRes.data || {});
      setBloodGroupData(bloodGroupRes.data || []);
      setEmergencies(normalizeList(emergenciesRes));
      setBridges(normalizeList(bridgesRes));
      setInboxMessages(normalizeList(inboxRes));
      setLeaderboard(normalizeList(leaderboardRes));

      const allPatients = normalizeList(patientsRes);
      const PENDING_STATUSES = ['pending', 'pending_opt_in', 'pending_details', 'pending_verification'];
      setPendingPatients(allPatients.filter(p => PENDING_STATUSES.includes(p.status)));
      
      const bridged = allPatients.filter(p => p.status === 'bridged');
      bridged.sort((a, b) => getDueDateInfo(a.next_due_date).days - getDueDateInfo(b.next_due_date).days);
      setMonitoredPatients(bridged);
    } catch (err) {
      setError('Failed to fetch data. Your session may have expired.');
      if (err.response && err.response.status === 401) logout();
    } finally {
      setLoading(false);
    }
  }, [logout]);

  useEffect(() => {
    fetchData();
    if (supabaseUrl && supabaseAnonKey) {
      const channel = supabase.channel('public-db-changes')
        .on('postgres_changes', { event: '*', schema: 'public' }, () => {
          console.log('Real-time change detected, refetching data...');
          fetchData();
        })
        .subscribe();
      
      return () => { supabase.removeChannel(channel); };
    }
  }, [fetchData]);

  const handleApiAction = async (action, successMessage) => {
    try {
      const response = await action();
      setSnackbar({ open: true, message: response.data.message || successMessage });
      fetchData();
    } catch (err) {
      setSnackbar({ open: true, message: err.response?.data?.error || 'Action failed!' });
    }
    setDialogConfig({ ...dialogConfig, open: false });
  };

  const confirmAction = (title, message, action, successMessage) => {
    setDialogConfig({ open: true, title, message, onConfirm: () => handleApiAction(action, successMessage) });
  };

  const renderLeaderboard = () => {
    if (loading && leaderboard.length === 0) {
      return <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}><CircularProgress /></Box>;
    }
    if (!leaderboard || leaderboard.length === 0) {
      return <Typography sx={{ p: 3, textAlign: 'center', height: '100%' }}>No donor data for leaderboard.</Typography>;
    }
    return (
      <TableContainer>
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell>Rank</TableCell>
              <TableCell>Name</TableCell>
              <TableCell align="right">Points</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {leaderboard.map((donor, index) => (
              <TableRow key={index}>
                <TableCell>{index + 1}</TableCell>
                <TableCell>{donor.name}</TableCell>
                <TableCell align="right">{donor.gamification_points}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  const renderDuePatientsAlert = () => {
    const duePatients = monitoredPatients.filter(p => getDueDateInfo(p.next_due_date).days <= 7);
    
    if (duePatients.length === 0) return null;
    
    return (
      <Paper elevation={3} sx={{ p: { xs: 2, md: 3 }, mb: 4, border: 2, borderColor: 'error.main' }}>
        <Typography variant="h6" color="error.main" gutterBottom>
          Action Required: Patients Due for Transfusion
        </Typography>
        <TableContainer>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Name</TableCell>
                <TableCell>Due Date</TableCell>
                <TableCell>Status</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {duePatients.map((p) => {
                const dueInfo = getDueDateInfo(p.next_due_date);
                return (
                  <TableRow key={p.id} hover>
                    <TableCell>{p.name}</TableCell>
                    <TableCell>{p.next_due_date ? new Date(p.next_due_date).toLocaleDateString() : 'N/A'}</TableCell>
                    <TableCell sx={{ color: dueInfo.color }}>{dueInfo.text}</TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
    );
  };

  const renderTabContent = () => {
    switch (currentTab) {
      case 0: // Analytics
        return (
          <Grid container spacing={3} sx={{ mt: 1 }}>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<PeopleIcon />} title="Total Donors" value={stats.total_donors} />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Favorite />} title="Active & Eligible" value={stats.active_donors} color="success.main" />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Warning />} title="Patients Due Soon" value={stats.patients_at_risk} color="warning.main" />
            </Grid>
            <Grid item sx={{ width: { xs: '100%', sm: '50%', md: '25%' } }}>
              <StatCard icon={<Healing />} title="Pending Patients" value={stats.pending_patients} color="info.main" />
            </Grid>
            
            <Grid item sx={{ width: { xs: '100%', lg: '66%' } }}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>Donor Blood Groups</Typography>
                <Box sx={{ height: 320 }}>
                  <BloodGroupChart data={bloodGroupData} />
                </Box>
              </Paper>
            </Grid>
            <Grid item sx={{ width: { xs: '100%', lg: '34%' } }}>
              <Paper sx={{ p: 2, height: '100%' }}>
                <Typography variant="h6" gutterBottom>Top Donors Leaderboard</Typography>
                {renderLeaderboard()}
              </Paper>
            </Grid>
          </Grid>
        );
      
      case 1: // Inbox
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>User Phone</TableCell>
                  <TableCell>Message</TableCell>
                  <TableCell>Reason</TableCell>
                  <TableCell align="right">Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {inboxMessages.map((msg) => (
                  <TableRow key={msg.id}>
                    <TableCell>{msg.user_phone}</TableCell>
                    <TableCell>{msg.user_message}</TableCell>
                    <TableCell><Chip label={msg.reason} color="warning" size="small" /></TableCell>
                    <TableCell align="right">
                      <Button 
                        onClick={() => confirmAction(
                          'Confirm Resolution', 
                          `Mark message from ${msg.user_phone} as resolved?`, 
                          () => apiClient.post(`/api/admin/inbox/${msg.id}/resolve`), 
                          'Message Resolved!'
                        )} 
                        startIcon={<CheckCircleOutlineIcon />}
                      >
                        Resolve
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 2: // Pending Patients
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Name</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {pendingPatients.map((p) => (
                  <TableRow key={p.id}>
                    <TableCell>{p.name}</TableCell>
                    <TableCell><Chip label={p.status} size="small" /></TableCell>
                    <TableCell>
                      <Button 
                        onClick={() => confirmAction(
                          'Confirm Bridge Creation', 
                          `Create a bridge for ${p.name}?`, 
                          () => apiClient.post(`/api/admin/patients/${p.id}/create-bridge`), 
                          'Bridge Created!'
                        )} 
                        startIcon={<AddCircleOutlineIcon />}
                      >
                        Create Bridge
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 3: // Patient Monitor
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Patient Name</TableCell>
                  <TableCell>Next Transfusion</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {monitoredPatients.map((p) => { 
                  const ddi = getDueDateInfo(p.next_due_date); 
                  return (
                    <TableRow key={p.id} sx={{ backgroundColor: ddi.days < 0 ? 'rgba(255, 0, 0, 0.1)' : 'transparent' }}>
                      <TableCell>{p.name}</TableCell>
                      <TableCell sx={{ color: ddi.color }}>{ddi.text}</TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 4: // Active Emergencies
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Patient</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {emergencies.map((req) => (
                  <TableRow key={req.id}>
                    <TableCell>{req.patient_name}</TableCell>
                    <TableCell>{req.status}</TableCell>
                    <TableCell>
                      <Stack direction="row" spacing={1}>
                        <Button 
                          size="small" 
                          onClick={() => confirmAction(
                            'Confirm Closure', 
                            `Close request for ${req.patient_name}?`, 
                            () => apiClient.post(`/api/admin/emergencies/${req.id}/close`), 
                            'Request Closed!'
                          )} 
                          startIcon={<Close />}
                        >
                          Close
                        </Button>
                        <Button 
                          size="small" 
                          color="warning" 
                          onClick={() => confirmAction(
                            'Confirm Escalation', 
                            `Escalate request for ${req.patient_name}?`, 
                            () => apiClient.post(`/api/admin/emergencies/${req.id}/escalate`), 
                            'Escalation Initiated!'
                          )} 
                          startIcon={<EscalationIcon />}
                        >
                          Escalate
                        </Button>
                      </Stack>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      case 5: // Bridge Monitor
        return (
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Bridge Name</TableCell>
                  <TableCell>Patient</TableCell>
                  <TableCell>Members</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {bridges.map((b) => (
                  <TableRow key={b.id}>
                    <TableCell>{b.name}</TableCell>
                    <TableCell>{b.patient_name}</TableCell>
                    <TableCell>{b.member_count}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        );
      
      default:
        return <div>Select a tab</div>;
    }
  };

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', bgcolor: 'background.default' }}>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>🩸 BloodBridge AI Dashboard</Typography>
          <Button color="inherit" onClick={logout} startIcon={<Logout />}>Logout</Button>
        </Toolbar>
      </AppBar>

      <Container maxWidth="xl" sx={{ mt: 2, mb: 4, flexGrow: 1, overflowY: 'auto' }}>
        {renderDuePatientsAlert()}
        
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        <Paper sx={{ p: 2 }}>
          <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
            <Tabs 
              value={currentTab} 
              onChange={(e, val) => setCurrentTab(val)} 
              variant="scrollable" 
              scrollButtons="auto"
            >
              <Tab icon={<ShowChartIcon />} label="Analytics" />
              <Tab icon={<InboxIcon />} label={
                <Badge badgeContent={inboxMessages.length} color="error">
                  Inbox
                </Badge>
              } />
              <Tab icon={<PeopleIcon />} label={
                <Badge badgeContent={pendingPatients.length} color="primary">
                  Pending Patients
                </Badge>
              } />
              <Tab icon={<PeopleIcon />} label="Patient Monitor" />
              <Tab icon={<EmergencyIcon />} label="Active Emergencies" />
              <Tab icon={<HubIcon />} label="Bridge Monitor" />
            </Tabs>
          </Box>

          {loading ? (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
              <CircularProgress />
            </Box>
          ) : (
            renderTabContent()
          )}
        </Paper>
      </Container>

      <ConfirmationDialog 
        {...dialogConfig} 
        onClose={() => setDialogConfig({ ...dialogConfig, open: false })} 
      />
      
      <Snackbar 
        open={snackbar.open} 
        autoHideDuration={6000} 
        onClose={() => setSnackbar({ ...snackbar, open: false })} 
        message={snackbar.message} 
      />
    </Box>
  );
};

export default DashboardPage;

```

`admin-dashboard/src/pages/LoginPage.jsx`

```javascript
// admin-dashboard/src/pages/LoginPage.jsx
import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert, CircularProgress } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth.js';
import apiClient from '../api/apiClient.js';

const LoginPage = () => {
  const { login } = useAuth();
  const navigate = useNavigate();

  // --- MODIFICATION: Hardcode the phone number for the demo user ---
  // We no longer need a state for the phone number.
  const phone = '+918000000000';
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleLogin = async (event) => {
    event.preventDefault();
    setError('');
    
    // Simple password validation
    if (!password) {
        setError('Password is required.');
        return;
    }

    setLoading(true);
    try {
      // The component now sends the hardcoded phone number and the entered password.
      console.log('Attempting login with:', { phone, password });
      const response = await apiClient.post('/api/admin/login', { phone, password });

      if (response.data?.token) {
        console.log('Login successful, token:', response.data.token);
        // Using localStorage to persist the token across browser sessions.
        localStorage.setItem('token', response.data.token);
        login(response.data.token);
        navigate('/dashboard');
      } else {
        // This case is unlikely if the backend is structured correctly, but good to have.
        setError('Login failed: No token received from server.');
      }
    } catch (err) {
      console.error('Login error:', {
        message: err.message,
        status: err.response?.status,
        data: err.response?.data,
      });

      // Provide more specific feedback to the user.
      if (err.response?.status === 401) {
        setError('Invalid password. Hint: try "admin123"');
      } else if (err.code === 'ECONNABORTED' || !err.response) {
        setError('Cannot connect to the server. Please ensure it is running.');
      } else {
        setError(err.response?.data?.message || 'An unknown error occurred.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box sx={{ mt: 8, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Typography component="h1" variant="h5">
          🩸 BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleLogin} sx={{ mt: 3, width: '100%' }}>
          {/* --- MODIFICATION: The phone number input field has been removed --- */}
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="current-password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            disabled={loading}
            sx={{ mt: 3, mb: 2 }}
          >
            {loading ? <CircularProgress size={24} color="inherit" /> : 'Sign In'}
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;

```

`admin-dashboard/src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`admin-dashboard/vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

`backend/.env`

```
# ----------------------------------
# SERVER CONFIGURATION
# ----------------------------------
PORT=3001

# ----------------------------------
# SECURITY
# ----------------------------------
# Generate a new random string from https://www.uuidgenerator.net/ and paste it here
JWT_SECRET="eb4db4a414678902613083784a04ec9de45570856d8ced1dbe6fdd4a545ff715"

# ----------------------------------
# DATABASE (CONNECTION POOLER)
# ----------------------------------
# Replace the ENTIRE line below with your Connection Pooler URI from Supabase
DATABASE_URL="postgresql://postgres.psussvygzgzkkwdjqbwp:asdfusahdfuu3842r7gdsfh@aws-1-ap-southeast-1.pooler.supabase.com:6543/postgres"

# ----------------------------------
# THIRD-PARTY APIs
# ----------------------------------
# Paste your Gemini API key from Google AI Studio
GEMINI_API_KEY="AIzaSyBvD9N56Z5PWeVZHSHNPKkYM3A1JlhO09w"

# For the local Python service
ML_SERVICE_URL="http://localhost:8000"

# ----------------------------------
# WHATSAPP (FROM YOUR META APP)
# ----------------------------------
# Paste your own credentials from your Meta for Developers App
WHATSAPP_TOKEN="EAAY5EGe8MHkBPWtYv6S5oJtPBWCXNu6Ym4sZCadC7c4uONUhsQ4ZAAlEwKMcIyAGowxW64NrWfPpKF7zi3Xd8VQSAQA3tEV1ao5pqwLB2z7aSRnUo5ZCyQQXpsz87ZA6DpbgyX8i2Mk7CVIUZAneZCAfQusHLjLEofU0Szu7PWZAqALCSL7Dss3Fov6Pcwgtj5XAbk3MCmmZAXa7OxZAPqiZBsW3ssAN5Dk9rC8AYhhbbWkwZDZD"
WHATSAPP_PHONE_NUMBER_ID="729824143554882"
WHATSAPP_APP_SECRET="e94bd0c1a5619ee68b105222b0185dc6"
WHATSAPP_VERIFY_TOKEN="inquilab_bloodai-123-2025-hackathon"

# ----------------------------------
# DEMO & ADMIN
# ----------------------------------
ADMIN_DEMO_PHONE="+918000000000"
DEMO_VERIFIED_PHONE_NUMBERS=""


```

`backend/server.js`

```javascript
// backend/server.js

// Import required dependencies
import express from 'express'; // Express framework for building the server
import cors from 'cors'; // Middleware for enabling CORS
import morgan from 'morgan'; // Middleware for request logging
import config from './src/config/config.js'; // Configuration settings
import adminRoutes from './src/routes/adminRoutes.js'; // Admin dashboard routes
import { verifyWebhook } from './src/middleware/verifyWebhook.js'; // Webhook signature verification
import webhookController from './src/controllers/webhookController.js'; // Webhook handling controller
import BridgeCoordinationService from './src/services/bridgeCoordinationService.js';

// --- PHASE 1: PREDICTIVE ENGAGEMENT ---
import cron from 'node-cron'; // Import the cron scheduler library
import EngagementService from './src/services/engagementService.js'; // Import our new engagement service
// --- END PHASE 1 ---

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3001; // Use environment PORT or default to 3001

// Middleware setup
app.use(cors()); // Enable CORS for all routes
app.use(morgan('tiny')); // Log HTTP requests in 'tiny' format

// API and Health Routes
app.get('/health', (req, res) => {
  // Health check endpoint to verify server status
  res.status(200).json({ status: 'healthy', now: new Date().toISOString() });
});

// Admin routes with JSON body parser
app.use('/api/admin', express.json({ limit: '1mb' }), adminRoutes);

// Webhook Routes
app.get('/webhook', webhookController.verifyToken); // Handle Meta webhook verification (GET)

app.post(
  '/webhook',
  express.json({
    verify: (req, res, buf) => {
req.rawBody = buf.toString();     }
  }),
  verifyWebhook, // This middleware will now use req.rawBody
  webhookController.handleMessage // This controller will use the parsed req.body
);

// Global Error Handling
app.use((err, req, res, next) => {
  // Handle errors from middleware or routes
  console.error('[ERROR HANDLER]', err.stack);
  res.status(500).json({ message: 'An internal server error occurred.' });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason) => {
  console.error('Unhandled Rejection:', reason);
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
});


// --- PHASE 1: PREDICTIVE ENGAGEMENT SCHEDULER ---
// This task is scheduled to run at 9:00 AM every day in the Asia/Kolkata timezone.
// It will automatically find donors who are now eligible to donate again and send them a reminder.
console.log('🕒 Cron job for eligibility reminders scheduled to run every day at 9:00 AM.');
cron.schedule('0 9 * * *', () => {
  console.log('⏰ It is 9:00 AM. Triggering the eligibility reminder cron job...');
  // We create a new instance to ensure it's a fresh run
  const engagementService = new EngagementService();
  engagementService.sendEligibilityReminders();
}, {
  scheduled: true,
  timezone: "Asia/Kolkata" // IMPORTANT: Set to your target timezone
});

console.log('🕒 Cron job for automatic bridge requests scheduled to run every day at 8:00 AM.');
cron.schedule('0 8 * * *', () => {
  console.log('⏰ It is 8:00 AM. Triggering automatic bridge requests...');
  const bridgeService = new BridgeCoordinationService();
  bridgeService.triggerAutomaticBridgeRequests();
}, {
  scheduled: true,
  timezone: "Asia/Kolkata"
});

// '0 10 * * 0' means at minute 0, hour 10, on day-of-week 0 (Sunday).
console.log('🕒 Cron job for inactive donor nudges scheduled to run every Sunday at 10:00 AM.');
cron.schedule('0 10 * * 0', () => {
    console.log('⏰ It is Sunday 10:00 AM. Triggering inactive donor nudge...');
    const engagementService = new EngagementService();
    engagementService.sendInactiveDonorNudges();
}, {
    scheduled: true,
    timezone: "Asia/Kolkata"
});
// --- END PHASE 1 ---


// Start the server
app.listen(PORT, () => {
  console.log(`✅ BloodBridge AI backend is running on port ${PORT}`);
});

```

`backend/src/config/config.js`

```javascript
// backend/src/config/config.js
import 'dotenv/config'; // Loads variables from .env into process.env

// This object maps environment variables to a clean, accessible config object.
const config = {
    port: process.env.PORT,
    jwtSecret: process.env.JWT_SECRET,
    databaseUrl: process.env.DATABASE_URL,
    geminiApiKey: process.env.GEMINI_API_KEY,
    mlServiceUrl: process.env.ML_SERVICE_URL,
    whatsappToken: process.env.WHATSAPP_TOKEN,
    whatsappPhoneNumberId: process.env.WHATSAPP_PHONE_NUMBER_ID,
    whatsappAppSecret: process.env.WHATSAPP_APP_SECRET,
    whatsappVerifyToken: process.env.WHATSAPP_VERIFY_TOKEN,
    adminDemoPhone: process.env.ADMIN_DEMO_PHONE,
    demoVerifiedPhoneNumbers: process.env.DEMO_VERIFIED_PHONE_NUMBERS
};

// This validation step ensures the application fails fast if critical secrets are missing.
// It's a crucial security and stability feature.
const requiredConfig = ['port', 'jwtSecret', 'databaseUrl'];
const missingConfig = requiredConfig.filter(key => !config[key]);

if (missingConfig.length > 0) {
    console.error(`🔴 FATAL ERROR: Missing required environment variables: ${missingConfig.join(', ')}`);
    // Exit the application with an error code.
    process.exit(1);
}

export default config;

```

`backend/src/config/db.js`

```javascript
// backend/src/config/db.js
import { Pool } from 'pg';
import config from './config.js';

/**
 * Creates a new connection pool.
 * The pool manages multiple client connections to the database,
 * reusing them to improve performance and stability.
 */
const pool = new Pool({
  connectionString: config.databaseUrl,
});

/**
 * A helper function to execute a simple query.
 * @param {string} text - The SQL query string.
 * @param {Array} params - The parameters to pass to the query.
 * @returns {Promise<QueryResult>} The result from the database.
 */
const query = (text, params) => pool.query(text, params);

// We export the entire pool so we can use it for transactions later,
// and the query function for convenience.
const db = {
  query,
  pool,
};

export default db;

```

`backend/src/controllers/adminController.js`

```javascript
// backend/src/controllers/adminController.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import db from '../config/db.js';
import bridgeService from '../services/bridgeService.js';
import bridgeCoordinationService from '../services/bridgeCoordinationService.js'; 
import emergencyService from '../services/emergencyService.js';

/**
 * Admin Login
 */
export const login = async (req, res) => {
  const { phone, password } = req.body;
  if (!phone || !password) {
    return res.status(400).json({ message: 'Phone and password are required' });
  }
  try {
    // Demo admin login (for prototype)
    if (phone === config.adminDemoPhone && password === 'admin123') {
      const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
      console.log(`Login successful for demo admin: ${phone}`);
      return res.json({ token });
    }
    // In a real app, you would have hashed password validation here
    const { rows } = await db.query(
      'SELECT * FROM users WHERE phone = $1 AND role = $2',
      [phone, 'Admin']
    );
    if (rows.length === 0 || rows[0].password !== password) {
      console.warn('Login failed for phone:', phone);
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
    console.log(`Login successful for user: ${phone}`);
    return res.json({ token });

  } catch (err) {
    console.error('Login error:', { error: err.message, phone });
    return res.status(500).json({ message: 'Server error during login' });
  }
};

/**
 * Create a Blood Bridge for a Patient
 */
export const createBridgeForPatient = async (req, res) => {
  const { patientId } = req.params;
  try {
    const { rows: [patient] } = await db.query(
      'SELECT * FROM patients WHERE id = $1',
      [patientId]
    );

    if (!patient) {
      return res.status(404).json({ message: 'Patient not found' });
    }
    if (patient.status === 'bridged') {
      return res.status(400).json({ message: 'Patient already has a bridge.' });
    }

    const { rows: [bridge] } = await db.query(
      'INSERT INTO blood_bridges (patient_id, name, blood_group, city) VALUES ($1, $2, $3, $4) RETURNING id',
      [patient.id, `${patient.name}'s Bridge`, patient.blood_group, patient.city]
    );

    const result = await bridgeService.populateNewBridge(
      bridge.id,
      patient.city,
      patient.blood_group,
      patient.pincode
    );

    await db.query(
      "UPDATE patients SET status = 'bridged' WHERE id = $1",
      [patientId]
    );
    console.log(`ADMIN ACTION: Created and populated Bridge ${bridge.id} with ${result.count} members.`);
    res.json({
      success: true,
      message: `Blood Bridge created and populated with ${result.count} top donors.`
    });
  } catch (error) {
    console.error('Error creating bridge for patient:', error);
    await db.query( "UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    res.status(500).json({ error: 'Failed to create and populate bridge.' });
  }
};

/**
 * Close Emergency Request
 */
export const closeEmergency = async (req, res) => {
  const { requestId } = req.params;
  try {
    const { rowCount } = await db.query(
      "UPDATE emergency_requests SET status = 'closed' WHERE id = $1 AND status = 'active'",
      [requestId]
    );
    if (rowCount === 0) {
      return res.status(404).json({ message: "Active request not found or already closed."})
    }
    console.log(`ADMIN ACTION: Closed emergency request ${requestId}`);
    res.json({ success: true, message: 'Request successfully closed.' });
  } catch (error) {
    console.error(`Error closing emergency ${requestId}:`, error);
    res.status(500).json({ error: 'Failed to close request.' });
  }
};

/**
 * Triggers a transfusion request for a patient in a Blood Bridge.requestBridgeTransfusion
 */
export const requestBridgeTransfusion = async (req, res) => {
  const { bridgeId } = req.params;
  try {
    // Use the imported instance directly
    const result = await bridgeCoordinationService.requestTransfusion(bridgeId);
  // --- END OF FIX ---
    console.log(`ADMIN ACTION: Triggered transfusion request for bridge ${bridgeId}`);
    res.json(result);
  } catch (error) {
    console.error(`Error requesting bridge transfusion for ${bridgeId}:`, error);
    res.status(500).json({ error: error.message || 'Failed to send bridge request.' });
  }
};

/**
 * Fetches the four main statistics for the StatCards on the dashboard.
 */
export const getDashboardStats = async (req, res) => {
  try {
    const [
      { rows: [totalDonors] },
      { rows: [activeDonors] },
      { rows: [pendingPatients] },
      { rows: [atRisk] }
    ] = await Promise.all([
      db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor'"),
      db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor' AND availability_status = 'available'"),
      db.query("SELECT COUNT(*) as count FROM patients WHERE status = 'pending_verification'"),
      db.query("SELECT COUNT(*) as count FROM emergency_requests WHERE status = 'active'")
    ]);
    
    res.json({
      total_donors: parseInt(totalDonors.count, 10),
      active_donors: parseInt(activeDonors.count, 10),
      pending_patients: parseInt(pendingPatients.count, 10),
      patients_at_risk: parseInt(atRisk.count, 10),
    });
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({ error: 'Failed to fetch dashboard stats.' });
  }
};

/**
 * Fetches the count of donors for each blood group for the chart.
 */
export const getBloodGroupStats = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT blood_group, COUNT(*) as count 
       FROM users 
       WHERE user_type = 'donor' AND blood_group IS NOT NULL AND blood_group != 'Unknown'
       GROUP BY blood_group 
       ORDER BY blood_group`
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching blood group stats:', error);
    res.status(500).json({ error: 'Failed to fetch blood group stats.' });
  }
};

/**
 * Fetches patients with 'pending_verification' status for the Patients tab.
 */

export const getPatients = async (req, res) => {
  try {
    // --- THIS IS THE CORRECTED QUERY ---
    // Instead of a risky subquery, we use a LEFT JOIN. This is safer and more efficient.
    // It correctly handles the case where a patient has no bridge yet (member_count will be 0).
    const query = `
      SELECT 
        p.id, p.name, p.phone, p.blood_group, p.city, p.status, p.condition,
        p.last_transfusion_date, p.frequency_in_days,
        p.last_transfusion_date + (p.frequency_in_days || ' days')::interval AS next_due_date,
        COUNT(bm.id) as bridge_member_count
      FROM 
        patients p
      LEFT JOIN 
        blood_bridges bb ON p.id = bb.patient_id
      LEFT JOIN 
        bridge_members bm ON bb.id = bm.bridge_id
      GROUP BY
        p.id
      ORDER BY 
        p.created_at DESC
    `;
    // --- END OF CORRECTION ---
    
    const { rows } = await db.query(query);
    res.json(rows);
  } catch (error) {
    console.error('Error fetching patients:', error);
    res.status(500).json({ error: 'Failed to fetch patients.' });
  }
};

/**
 * Fetches all 'active' emergencies for the Emergencies tab.
 */
export const getActiveEmergencies = async (req, res) => {
  try {
    const { rows } = await db.query(
      "SELECT id, patient_name, blood_group, status, city FROM emergency_requests WHERE status = 'active' ORDER BY created_at DESC"
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching active emergencies:', error);
    res.status(500).json({ error: 'Failed to fetch active emergencies.' });
  }
};

/**
 * Fetches all created Blood Bridges for the Blood Bridges tab.
 */
export const getBloodBridges = async (req, res) => {
    try {
        const { rows } = await db.query(
            `SELECT bb.id, bb.blood_group, bb.city, p.name as patient_name
             FROM blood_bridges bb
             JOIN patients p ON bb.patient_id = p.id
             WHERE bb.active = true
             ORDER BY p.name`
        );
        res.json(rows);
    } catch (error) {
        console.error('Error fetching blood bridges:', error);
        res.status(500).json({ error: 'Failed to fetch blood bridges.' });
    }
};

/**
 * Fetches patients who are due for a transfusion.
 * Logic: Finds patients where today's date is past their last transfusion + frequency.
 */
export const getDuePatients = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT id, name, blood_group, city, last_transfusion_date, frequency_in_days
       FROM patients
       WHERE 
         status = 'bridged' AND 
         last_transfusion_date IS NOT NULL AND 
         frequency_in_days IS NOT NULL AND
         (last_transfusion_date + frequency_in_days * INTERVAL '1 day') <= NOW()`
    );
    res.json(rows);
  } catch (error){
    console.error('Error fetching due patients:', error);
    res.status(500).json({ error: 'Failed to fetch due patients.' });
  }
};

/**
 * Fetches the top 10 donors for the gamification leaderboard.
 */
export const getLeaderboard = async (req, res) => {
  try {
    const { rows } = await db.query(
      `SELECT name, gamification_points, city 
       FROM users 
       WHERE user_type = 'donor' 
       ORDER BY gamification_points DESC 
       LIMIT 10`
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching leaderboard:', error);
    res.status(500).json({ error: 'Failed to fetch leaderboard data.' });
  }
};

// --- Other Endpoints (Placeholders for now) ---
export const getConfig = async (req, res) => { res.json({ message: "Config placeholder" }); };
export const getInboxMessages = async (req, res) => {
  try {
    // This query selects all messages that an admin has not yet marked as 'resolved'.
    const { rows } = await db.query(
      "SELECT id, user_phone, user_message, reason, created_at FROM inbox_messages WHERE status = 'pending' ORDER BY created_at ASC"
    );
    res.json(rows);
  } catch (error) {
    console.error('Error fetching inbox messages:', error);
    res.status(500).json({ error: 'Failed to fetch inbox messages.' });
  }
};
export const escalateEmergency = async (req, res) => {
  const { requestId } = req.params;
  try {
    const result = await emergencyService.escalateRequest(requestId);
    console.log(`ADMIN ACTION: Escalated emergency request ${requestId}`);
    res.json(result);
  } catch (error) {
    console.error(`Error escalating emergency ${requestId}:`, error);
    res.status(500).json({ error: error.message || 'Failed to escalate emergency.' });
  }
};
export const resolveInboxMessage = async (req, res) => { res.status(501).json({ message: "Not implemented" }); };

```

`backend/src/controllers/webhookController.js`

```javascript
// backend/src/controllers/webhookController.js

// Import required dependencies
import config from '../config/config.js';
import db from '../config/db.js';
import emergencyService from '../services/emergencyService.js';
import registrationService from '../services/registrationService.js';
import responseService from '../services/responseService.js';
import patientService from '../services/patientService.js';
import donorPreferenceService from '../services/donorPreferenceService.js';
import aiRouterService from '../services/aiRouterService.js';
import faqService from '../services/faqService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';


/**
 * Handles the GET request from Meta for webhook verification.
 * This is a one-time setup step.
 */
const verifyToken = (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];

  if (mode === 'subscribe' && token === config.whatsappVerifyToken) {
    console.log('✅ Webhook verified successfully!');
    return res.status(200).send(challenge);
  }

  console.warn('Webhook verification failed. Make sure your verify token is correct.');
  res.status(403).send('Verification failed');
};


/**
 * Processes a single, validated incoming WhatsApp message.
 * This function contains the main routing logic for the chatbot.
 * @param {object} messageData - The message object from the Meta webhook payload.
 */
const processMessage = async (messageData) => {
  // 1. Extract and Normalize Message Data
  const from = normalizePhoneNumber(messageData.from);
  if (messageData.type !== 'text') {
    console.log(`Ignoring non-text message of type '${messageData.type}' from ${from}.`);
    return;
  }
  const userMessage = messageData.text.body.trim();
  const lowerUserMessage = userMessage.toLowerCase();
  console.log(`--- Processing Message --- From: ${from}, Message: "${userMessage}"`);


  // 2. High-Priority Keyword & Pattern Matching
  if (await patientService.processOnboardingReply(userMessage, from)) {
    console.log(`✅ Message handled by: Patient Onboarding continuation.`);
    return;
  }
  if (lowerUserMessage === 'apply') {
    if(await patientService.startApplication(from)) {
      console.log(`✅ Message handled by: Patient Application start.`);
      return;
    }
  }
  if (/^\d{6}$/.test(userMessage)) {
    console.log(` OTP Detected. Passing to Response Service...`);
    await responseService.verifyOTPAndConfirm(from, userMessage);
    return;
  }
  const responseMatch = userMessage.match(/^(?:YES)\s+(\d{4})$/i);
  if (responseMatch) {
    console.log(` Donor Reply Detected. Passing to Response Service...`);
    await responseService.handleDonorReplyWithShortCode(from, responseMatch[1]);
    return;
  }
  
  // 3. Fallback to AI-Powered Intent Routing
  console.log(`No direct keyword match found. Routing to AI to determine intent...`);

  let userRole = 'Unregistered';
  const { rows: [user] } = await db.query('SELECT role FROM users WHERE phone = $1', [from]);
  if (user) userRole = user.role;
  
  const route = await aiRouterService.routeMessageWithContext(userMessage, userRole);

  if (route && route.tool) {
    console.log(`AI routed to tool: ${route.tool} with params:`, route.params);
    switch (route.tool) {
      case 'handle_emergency_request':
        await emergencyService.handleEmergencyRequest(userMessage, from);
        break;
      case 'handle_donor_registration':
        await registrationService.handleNewDonor(route.params, from);
        break;
      // Add other cases for other tools as they are defined in aiTools.js
      // e.g., case 'handle_snooze_request': ...

      default:
        // If the AI recommends a tool we haven't implemented a case for,
        // it's safer to treat it as a general question.
        console.log(`AI chose unhandled tool '${route.tool}'. Defaulting to FAQ.`);
        await faqService.handleFaq(userMessage, from);
        break;
    }
    console.log(`✅ Message handled by: AI-routed tool '${route.tool}'.`);
    return;
  }

  // 4. Final Fallback if no keywords or tools match
  console.log(`AI did not select a tool. Handling as a general FAQ.`);
  await faqService.handleFaq(userMessage, from);
  console.log(`✅ Message handled by: Fallback FAQ.`);
};


/**
 * The main entry point for the /webhook POST request.
 * It validates the message and then calls processMessage.
 */
const handleMessage = async (req, res) => {
  res.sendStatus(200); // Acknowledge receipt to Meta immediately

  try {
    const messageData = req.body.entry?.[0]?.changes?.[0]?.value?.messages?.[0];
    if (!messageData) {
      console.warn('Webhook received a payload that was not a message.', req.body);
      return;
    }

    const messageId = messageData.id;
    
    // Prevent duplicate processing
    const { rows } = await db.query('SELECT 1 FROM processed_messages WHERE message_id = $1', [messageId]);
    if (rows.length > 0) {
      console.warn(`Duplicate message ignored: ${messageId}`);
      return;
    }
    
    await db.query('INSERT INTO processed_messages(message_id) VALUES($1)', [messageId]);

    // Process the message
    await processMessage(messageData);

  } catch (error) {
    console.error('CRITICAL ERROR in handleMessage:', {
      message: error.message,
      stack: error.stack,
    });
  }
};

export default {
  verifyToken,
  handleMessage,
};

```

`backend/src/middleware/authMiddleware.js`

```javascript
// backend/src/middleware/authMiddleware.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';

// ✅ The function must be declared as a constant named 'authMiddleware'
const authMiddleware = (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authorization token is missing or malformed' });
  }

  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, config.jwtSecret);
    req.user = decoded;
    next();
  } catch (error) {
    console.error("JWT Verification Error:", error.message);
    return res.status(401).json({ message: 'Invalid or expired token' });
  }
};

// ✅ This line then exports that constant
export default authMiddleware;

```

`backend/src/middleware/checkRole.js`

```javascript
// backend/src/middleware/checkRole.js

const checkRole = (roles) => {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: 'Forbidden: No role assigned' });
    }
    const userRole = req.user.role;
    if (roles.includes(userRole)) {
      return next();
    }
    return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
  };
};

export default checkRole; // <-- CORRECTED LINE

```

`backend/src/middleware/verifyWebhook.js`

```javascript
// backend/src/middleware/verifyWebhook.js
import crypto from 'crypto';
import config from '../config/config.js';

/**
 * Middleware to verify WhatsApp webhook POST requests.
 * - Skips signature verification for GET (used by Meta for challenge verification).
 * - Validates signature for POST requests to ensure authenticity.
 */
export const verifyWebhook = (req, res, next) => {
  // Allow GET requests (Meta verification step) to pass through.
  if (req.method === 'GET') {
    return next();
  }

  // Get the signature from the request header.
  const signature = req.headers['x-hub-signature-256'];
  if (!signature) {
    console.warn('Signature missing for POST webhook');
    return res.status(401).json({ message: 'Signature missing' });
  }

  // --- THIS IS THE CORRECTED SECTION ---
  // Create an HMAC (Hash-based Message Authentication Code) using sha256.
  // We use the `whatsappAppSecret` as the key.
  const hmac = crypto.createHmac('sha256', config.whatsappAppSecret);

  // We MUST use the raw request body string that we saved earlier in server.js.
  // Using `req.body` here will fail because it's already parsed JSON.
  hmac.update(req.rawBody);
  const expectedSignature = `sha256=${hmac.digest('hex')}`;
  // --- END OF CORRECTION ---

  // Compare the signature from Meta with the one we calculated.
  // We use a timing-safe comparison to enhance security.
  // An invalid signature means the request might be forged.
  if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))) {
    console.warn('Signature mismatch for POST webhook. Check your WHATSAPP_APP_SECRET.');
    return res.status(401).json({ message: 'Invalid signature' });
  }

  // If the signatures match, the request is authentic. Proceed to the next middleware.
  next();
};

```

`backend/src/routes/adminRoutes.js`

```javascript
// backend/src/routes/adminRoutes.js
import express from 'express';
// --- FIX: Use named imports for all controller functions ---
import {
  login,
  createBridgeForPatient,
  closeEmergency,
  requestBridgeTransfusion,
  getDashboardStats,
  getBloodGroupStats,
  getPatients,
  getActiveEmergencies,
  getBloodBridges,
  getDuePatients,
  getLeaderboard,
  getInboxMessages,
  escalateEmergency,
  resolveInboxMessage,
  getConfig
} from '../controllers/adminController.js';
import authMiddleware from '../middleware/authMiddleware.js';
import checkRole from '../middleware/checkRole.js';

const router = express.Router();

// Public (no auth needed)
// --- FIX: Removed 'adminController.' prefix ---
router.post('/login', login);

// All routes below this require auth
router.use(authMiddleware);

// --- DASHBOARD GET ROUTES ---
// --- FIX: Removed 'adminController.' prefix from all routes below ---
router.get('/config', checkRole(['Admin']), getConfig);
router.get('/stats', checkRole(['Admin']), getDashboardStats);
router.get('/stats/blood-groups', checkRole(['Admin']), getBloodGroupStats);
router.get('/patients', checkRole(['Admin']), getPatients);
router.get('/patients/due', checkRole(['Admin']), getDuePatients);
router.get('/emergencies', checkRole(['Admin']), getActiveEmergencies);
router.get('/bridges', checkRole(['Admin']), getBloodBridges);
router.get('/leaderboard', checkRole(['Admin']), getLeaderboard);
router.get('/inbox', checkRole(['Admin']), getInboxMessages);

// --- ACTION ROUTES ---
router.post('/patients/:patientId/create-bridge', checkRole(['Admin']), createBridgeForPatient);
router.post('/emergencies/:requestId/close', checkRole(['Admin']), closeEmergency);
router.post('/emergencies/:requestId/escalate', checkRole(['Admin']), escalateEmergency);
router.post('/bridges/:bridgeId/request', checkRole(['Admin']), requestBridgeTransfusion);
router.post('/inbox/:messageId/resolve', checkRole(['Admin']), resolveInboxMessage);

export default router;

```

`backend/src/services/aiRouterService.js`

```javascript
// backend/src/services/aiRouterService.js
import { GoogleGenerativeAI } from '@google/generative-ai';
import { TOOL_DEFINITIONS } from './aiTools.js';
import config from '../config/config.js';

class AIRouterService {
  constructor() {
    if (!config.geminiApiKey) {
      throw new Error("GEMINI_API_KEY is not set.");
    }
    this.genAI = new GoogleGenerativeAI(config.geminiApiKey);
    this.model = this.genAI.getGenerativeModel({
      model: 'gemini-1.5-flash-latest',
      tools: { functionDeclarations: TOOL_DEFINITIONS }
    });
  }

  async routeMessageWithContext(userMessage, userRole) {
    const systemPrompt = `You are "Bridge AI", an AI assistant. Understand the user's message and call the appropriate function. The user's role is "${userRole}".`;
    const chatHistory = [
        { role: "user", parts: [{ text: systemPrompt }] },
        { role: "model", parts: [{ text: "Understood." }] },
    ];
    try {
      const chat = this.model.startChat({ history: chatHistory });
      const result = await chat.sendMessage(userMessage);
      const call = result.response.functionCalls()?.[0];
      
      if (call) {
        console.log(`AI decided to call tool: ${call.name} with params:`, call.args);
        return { tool: call.name, params: call.args };
      }
      console.log("AI did not call a specific tool for this message.");
      return null;
    } catch (error) {
      console.error('Error routing message with Gemini:', error.message);
      return null;
    }
  }
}

export default new AIRouterService();

```

`backend/src/services/aiTools.js`

```javascript
// backend/src/services/aiTools.js

/**
 * TOOL_DEFINITIONS is a manifest of functions the Gemini AI can call.
 * This is for the original, non-LangChain aiRouterService.
 * The descriptions are critical, as they tell the AI *when* to use each tool.
 */
export const TOOL_DEFINITIONS = [
  {
    name: 'handle_emergency_request',
    description: `Use for any urgent blood request. The message may contain details like blood group, city, or hospital. Extract these if present.`,
    parameters: {
      type: 'object',
      properties: {
        patient_name: { type: 'string', description: 'Name of the patient needing blood. If not mentioned, use "Unknown".' },
        blood_group: { type: 'string', description: 'The blood group needed, like A+, O-, AB+.' },
        city: { type: 'string', description: 'The city where the hospital is located.' }
      },
      required: ['blood_group', 'city']
    }
  },
  {
    name: 'handle_donor_registration',
    description: `Use this ONLY for messages where the user explicitly states they want to perform the ACTION of registering. This is the correct tool for phrases like "I want to donate blood", "register me as a donor", "sign me up", or "I want to become a Blood Warrior". DO NOT use this for general questions about donation requirements.`,
    parameters: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Full name of the new donor. Default to "Unknown" if not provided.' },
        blood_group: { type: 'string', description: 'The blood group of the person. Default to "Unknown" if not provided.' },
        city: { type: 'string', description: 'The city where the donor lives. Default to "Unknown" if not provided.' }
      },
      required: []
    }
  },
  {
    name: 'handle_snooze_request',
    description: 'Use when a donor wants to temporarily pause notifications. It can understand durations like "a month", "10 days", "2 weeks".',
    parameters: {
      type: 'object',
      properties: {
        duration: { type: 'integer', description: 'The number value for the duration (e.g., 10 for "10 days").' },
        unit: { type: 'string', enum: ['day', 'week', 'month'], description: 'The unit of time for the snooze.' }
      },
      required: ['duration', 'unit']
    }
  },
   {
    name: 'get_my_dashboard',
    description: 'Use this when a registered donor asks for their personal status, points, badges, or "mydashboard". It requires no parameters.',
    parameters: {
      type: 'object',
      properties: {},
      required: []
    }
  },
  {
    name: 'get_leaderboard',
    description: 'Use this when a user asks to see the "leaderboard", "top donors", or "rankings". It requires no parameters.',
    parameters: {
      type: 'object',
      properties: {},
      required: []
    }
  },
];

```

`backend/src/services/bridgeCoordinationService.js`

```javascript
// backend/src/services/bridgeCoordinationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateShortCode } from '../utils/otpHelper.js';

class BridgeCoordinationService {
  async requestTransfusion(bridgeId) {
    const { rows: [bridge] } = await db.query(
      `SELECT bb.*, p.name as patient_name
       FROM blood_bridges bb
       JOIN patients p ON bb.patient_id = p.id
       WHERE bb.id = $1`,
      [bridgeId]
    );
    if (!bridge) throw new Error(`Blood Bridge with ID ${bridgeId} not found.`);

    // --- NEW LOGIC: PREVENT DUPLICATE REQUESTS ---
    if (bridge.active_request_id) {
      throw new Error(`Request failed: Patient ${bridge.patient_name} already has an active bridge request.`);
    }
    // --- END NEW LOGIC ---

    const { rows: members } = await db.query(
      // Find the next donor who is currently 'available'
      `SELECT u.id, u.name, u.phone
       FROM bridge_members bm
       JOIN users u ON bm.donor_id = u.id
       WHERE bm.bridge_id = $1 AND bm.status = 'active' AND u.availability_status = 'available'
       ORDER BY bm.position ASC`,
      [bridgeId]
    );

    if (members.length === 0) {
      // This is a "Bridge Failure" scenario. We need to escalate.
      // For now, we'll throw an error that the admin will see.
      // In Task 4 (Escalation), we will automate this.
      throw new Error(`No available donors found in the bridge for ${bridge.patient_name}. Please escalate to a general emergency.`);
    }

    const donorToNotify = members[0]; // The SQL query now only returns available donors in order

    const shortCode = generateShortCode();
    // Create the request and get its ID back
    const { rows: [newRequest] } = await db.query(
      `INSERT INTO emergency_requests (patient_name, blood_group, city, requested_by_phone, short_code, request_type, bridge_id, units_needed)
       VALUES ($1, $2, $3, 'system', $4, 'bridge', $5, 1) RETURNING id;`,
      [bridge.patient_name, bridge.blood_group, bridge.city, shortCode, bridge.id]
    );

    // --- NEW LOGIC: LINK THE ACTIVE REQUEST TO THE BRIDGE ---
    await db.query(
        'UPDATE public.blood_bridges SET active_request_id = $1 WHERE id = $2',
        [newRequest.id, bridgeId]
    );
    // --- END NEW LOGIC ---

    const message = `Hi ${donorToNotify.name}, it's your turn in the Blood Bridge for patient *${bridge.patient_name}*.\n\nYour help is needed for their scheduled transfusion. Please reply with *YES ${shortCode}* to confirm your availability.`;
    await whatsappService.sendTextMessage(donorToNotify.phone, message);

    return { success: true, message: `Successfully notified ${donorToNotify.name} for patient ${bridge.patient_name}.` };
  }
  
  async rotateBridge(bridgeId, client = db) {
    // This function now does two things: rotates the position AND clears the active request ID.
    const { rows: [bridge] } = await client.query('SELECT rotation_position FROM blood_bridges WHERE id = $1', [bridgeId]);
    const { rows: [{ count }] } = await client.query('SELECT COUNT(*) FROM bridge_members WHERE bridge_id = $1 AND status = \'active\'', [bridgeId]);

    if (!bridge || count === '0') {
      console.error(`Cannot rotate bridge ${bridgeId}: Bridge or members not found.`);
      return;
    }

    const totalMembers = parseInt(count, 10);
    // We use the current position to find the next one, ensuring rotation
    const currentPositionInList = (bridge.rotation_position - 1);
    const nextPosition = (currentPositionInList % totalMembers) + 1;

    // Update bridge: clear active request and set new rotation position
    await client.query(
      'UPDATE blood_bridges SET rotation_position = $1, active_request_id = NULL WHERE id = $2',
      [nextPosition, bridgeId]
    );
    console.log(`Blood Bridge ${bridgeId} rotated successfully to position ${nextPosition} and cleared active request.`);
  }  // In backend/src/services/bridgeCoordinationService.js, inside the class

  /**
   * Finds all bridged patients who are due for a transfusion and initiates the request.
   * This is designed to be run automatically by a scheduler.
   */
  async triggerAutomaticBridgeRequests() {
    console.log('CRON JOB: Checking for due bridge patients...');
    try {
      // 1. Find all patients who are bridged and due for a transfusion today or in the past.
      const { rows: duePatients } = await db.query(
        `SELECT p.id, p.name, bb.id as bridge_id
         FROM patients p
         JOIN blood_bridges bb ON p.id = bb.patient_id
         WHERE 
           p.status = 'bridged' AND 
           p.last_transfusion_date IS NOT NULL AND 
           p.frequency_in_days IS NOT NULL AND
           (p.last_transfusion_date + p.frequency_in_days * INTERVAL '1 day') <= NOW() AND
           bb.active_request_id IS NULL -- IMPORTANT: Only trigger if there isn't one already active
        `
      );

      if (duePatients.length === 0) {
        console.log('CRON JOB: No patients are due for an automatic bridge request today.');
        return;
      }

      console.log(`CRON JOB: Found ${duePatients.length} patient(s) due for transfusion. Initiating requests...`);

      // 2. Loop through each due patient and call the existing requestTransfusion function.
      for (const patient of duePatients) {
        console.log(`CRON JOB: Initiating request for patient ${patient.name} (Bridge ID: ${patient.bridge_id})`);
        try {
          // We reuse the same logic that the admin dashboard button uses.
          await this.requestTransfusion(patient.bridge_id);
        } catch (error) {
          console.error(`CRON JOB: Failed to initiate request for bridge ${patient.bridge_id}. Reason: ${error.message}`);
          // In a production system, you might send an alert to an admin here.
        }
      }
    } catch (error) {
      console.error("CRITICAL ERROR in cron job triggerAutomaticBridgeRequests:", error);
    }
  }

/**
 * Finds all bridged patients who are due for a transfusion and initiates the request.
 * This is designed to be run automatically by a scheduler.
 */
async triggerAutomaticBridgeRequests() {
  console.log('CRON JOB: Checking for due bridge patients...');
  try {
    // 1. Find all patients who are bridged and due for a transfusion today or in the past.
    const { rows: duePatients } = await db.query(
      `SELECT p.id, p.name, bb.id as bridge_id
       FROM patients p
       JOIN blood_bridges bb ON p.id = bb.patient_id
       WHERE 
         p.status = 'bridged' AND 
         p.last_transfusion_date IS NOT NULL AND 
         p.frequency_in_days IS NOT NULL AND
         (p.last_transfusion_date + p.frequency_in_days * INTERVAL '1 day') <= NOW() AND
         bb.active_request_id IS NULL -- IMPORTANT: Only trigger if there isn't one already active
      `
    );

    if (duePatients.length === 0) {
      console.log('CRON JOB: No patients are due for an automatic bridge request today.');
      return;
    }

    console.log(`CRON JOB: Found ${duePatients.length} patient(s) due for transfusion. Initiating requests...`);

    // 2. Loop through each due patient and call the existing requestTransfusion function.
    for (const patient of duePatients) {
      console.log(`CRON JOB: Initiating request for patient ${patient.name} (Bridge ID: ${patient.bridge_id})`);
      try {
        // We reuse the same logic that the admin dashboard button uses.
        await this.requestTransfusion(patient.bridge_id);
      } catch (error) {
        console.error(`CRON JOB: Failed to initiate request for bridge ${patient.bridge_id}. Reason: ${error.message}`);
        // In a production system, you might send an alert to an admin here.
      }
    }
  } catch (error) {
    console.error("CRITICAL ERROR in cron job triggerAutomaticBridgeRequests:", error);
  }
}
}

export default new BridgeCoordinationService();

```

`backend/src/services/bridgeService.js`

```javascript
import db from '../config/db.js';

class BridgeService {
  // In backend/src/services/bridgeService.js
async populateNewBridge(bridgeId, city, bloodGroup, pincode) {
    try {
      console.log(`Populating bridge ${bridgeId} for city: ${city}, blood group: ${bloodGroup}, pincode: ${pincode}`);
      
      // --- THE FIX IS HERE ---
      // The SQL function `find_donors_for_bridge` returns two columns: `donor_id` and `final_score`.
      // We must select exactly those columns.
      const { rows: bestDonors } = await db.query(
        'SELECT donor_id, final_score FROM find_donors_for_bridge($1, $2, $3, $4)',
        [city, bloodGroup, pincode, 8] // We are populating with the top 8 donors
      );
      // --- END OF FIX ---

      if (!bestDonors || bestDonors.length === 0) {
        console.warn(`No donors found for bridge ${bridgeId}`);
        return { success: true, count: 0 };
      }

      // Use the donor_id from the function's result to insert into bridge_members
      const insertQueries = bestDonors.map((donor, index) =>
        db.query(
          'INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, $3)',
          [bridgeId, donor.donor_id, index + 1]
        )
      );

      await Promise.all(insertQueries);
      console.log(`Successfully populated bridge ${bridgeId} with ${bestDonors.length} donors`);
      return { success: true, count: bestDonors.length };

    } catch (error) {
      console.error(`Error populating bridge ${bridgeId}:`, {
        error: error.message,
        city,
        bloodGroup,
        pincode,
      });
      throw new Error(`Failed to populate bridge: ${error.message}`);
    }
}
}

export default new BridgeService();

```

`backend/src/services/donorPreferenceService.js`

```javascript
// backend/src/services/donorPreferenceService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class DonorPreferenceService {
  /**
   * Sets a snooze period for a donor, pausing notifications.
   * @param {string} phone - The donor's phone number.
   * @param {object} params - Parameters from the AI, e.g., { duration: 1, unit: 'week' }.
   */
  async handleSnooze(phone, params) {
    const { duration = 15, unit = 'day' } = params; // Default to 15 days if AI provides no params
    
    try {
      const interval = `${duration} ${unit}`;
      const { rows: [user] } = await db.query(
        "UPDATE users SET snooze_until = NOW() + $1::interval WHERE phone = $2 RETURNING snooze_until",
        [interval, phone]
      );

      if (user && user.snooze_until) {
        const snoozeDate = new Date(user.snooze_until).toLocaleDateString('en-IN');
        const message = `Got it. I've paused all non-critical notifications for you until ${snoozeDate}. We'll reach out again after that. Thank you for being a donor!`;
        await whatsappService.sendTextMessage(phone, message);
      }
    } catch (error) {
      console.error(`Error setting snooze for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while setting your preferences.");
    }
  }

  /**
   * Sets the Do Not Disturb (DND) status for a donor, permanently stopping notifications.
   * @param {string} phone - The donor's phone number.
   */
  async handleDnd(phone) {
    try {
      await db.query(
        "UPDATE users SET dnd_status = true, availability_status = 'unavailable' WHERE phone = $1",
        [phone]
      );
      const message = "You have been unsubscribed from all future notifications. We're sad to see you go, but we respect your decision. If you ever change your mind, just send 'Register' to sign up again.";
      await whatsappService.sendTextMessage(phone, message);
    } catch (error) {
      console.error(`Error setting DND for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while updating your DND status.");
    }
  }
}

export default new DonorPreferenceService();

```

`backend/src/services/emergencyService.js`

```javascript
// backend/src/services/emergencyService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import aiRouterService from './aiRouterService.js'; // <-- CORRECTLY IMPORTED
import mlService from './mlService.js';
import geocodingService from './geocodingService.js';
import { getDistanceInKm } from '../utils/distanceHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

const VALID_BLOOD_GROUPS = ['A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'];

class EmergencyService {
  /**
   * Handles the initial emergency message from a user. It uses the AI router
   * to parse details and then passes them to the creation function.
   * @param {string} userMessage - The raw text message from the user.
   * @param {string} requesterPhone - The user's phone number.
   */
  async handleEmergencyRequest(userMessage, requesterPhone) {
    const sanitizedPhone = normalizePhoneNumber(requesterPhone);
    try {
      // --- CORRECT LOGIC: USE AI ROUTER TO PARSE THE MESSAGE ---
      const route = await aiRouterService.routeMessageWithContext(userMessage, 'Unregistered');
      
      if (route && route.tool === 'handle_emergency_request' && route.params.blood_group && route.params.city) {
        console.log("AI successfully extracted details:", route.params);
        await this.createEmergencyRequest(route.params, sanitizedPhone);
      } else {
        console.log('AI could not extract necessary details. Prompting user.');
        const followupMessage = "I understand this is an emergency. To find a donor, please provide the patient's blood group (e.g., A+, O-) and the city where the hospital is located.";
        await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);
      }
      // --- END CORRECT LOGIC ---
    } catch (error) {
        console.error('CRITICAL ERROR in handleEmergencyRequest:', error);
        await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }

  /**
   * Creates the emergency request in the database after parameters have been validated.
   * @param {object} params - Clean parameters from the handleEmergencyRequest function.
   * @param {string} requesterPhone - The user's phone number.
   */
  async createEmergencyRequest(params, requesterPhone) {
    const { 
      patient_name = 'Unknown', 
      blood_group, 
      city, 
      hospital_name = 'Unknown', 
      units_needed = 1
    } = params;
    
    try {
      const normalizedBG = normalizeBloodGroup(blood_group);
      
      if (!VALID_BLOOD_GROUPS.includes(normalizedBG)) {
        console.warn(`Validation failed: AI provided invalid blood group '${blood_group}'`);
        const validationErrorMessage = `Sorry, "${blood_group}" is not a recognized blood group. Please use a valid one (e.g., O+, AB-).`;
        await whatsappService.sendTextMessage(requesterPhone, validationErrorMessage);
        return;
      }
      
      let coords = null;
      try {
        coords = await geocodingService.getCoords(hospital_name, city, null);
      } catch (geoError) {
        console.error("Geocoding service failed, but continuing without coordinates.", geoError);
      }

      const shortCode = Math.floor(1000 + Math.random() * 9000).toString();

      const { rows: [request] } = await db.query(
        `INSERT INTO emergency_requests (patient_name, blood_group, city, hospital_name, requested_by_phone, short_code, latitude, longitude, units_needed)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *;`,
        [patient_name, normalizedBG, city, hospital_name, requesterPhone, shortCode, coords?.latitude, coords?.longitude, units_needed]
      );
      
      console.log(`Successfully created emergency request ID: ${request.id}`);
      await whatsappService.sendTextMessage(requesterPhone, `✅ Emergency request active! We are now running a hyperlocal search for the best donor for *${patient_name}*.`);
      
      await this.findAndNotifyDonors(request);

    } catch (error) {
      console.error('CRITICAL ERROR creating emergency request in database:', error);
      await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }
  
   async escalateRequest(requestId) {
    // 1. Get the original emergency request details.
    const { rows: [request] } = await db.query(
      'SELECT * FROM emergency_requests WHERE id = $1 AND status = \'active\'',
      [requestId]
    );

    if (!request) {
      throw new Error('Active emergency request not found.');
    }

    // 2. Find all donors who have ALREADY been notified for this request.
    const { rows: notifiedDonors } = await db.query(
      'SELECT donor_id FROM donor_responses WHERE request_id = $1',
      [requestId]
    );
    const excludedDonorIds = notifiedDonors.map(d => d.donor_id);

    console.log(`Escalating request ${requestId}. Excluding ${excludedDonorIds.length} already-notified donor(s).`);

    // 3. Find the next batch of top-ranked donors, EXCLUDING the ones we already contacted.
    const nextDonors = await this.findAndRankGeneralDonors(
      request.blood_group,
      request.city,
      excludedDonorIds
    );

    if (nextDonors.length === 0) {
      // If there are no other donors to contact, inform the admin.
      console.warn(`Escalation failed for request ${requestId}: No new donors found.`);
      throw new Error('No additional available donors found in the network for this request.');
    }

    // 4. Notify the new best donor.
    const bestNextDonor = nextDonors[0];
    const notificationMessage = `🚨 URGENT (Escalated): You are the next top match!\n\nPatient *${request.patient_name}* needs your help (${request.blood_group}).\n\nReply *YES ${request.short_code}* to help.`;
    
    // We also need to add this new donor to the donor_responses table so we don't contact them again.
    // This is important for multiple escalations.
    await db.query(
        `INSERT INTO donor_responses (donor_id, request_id, response) VALUES ($1, $2, 'pending') ON CONFLICT (donor_id, request_id) DO NOTHING;`,
        [bestNextDonor.id, requestId]
    );

    await whatsappService.sendTextMessage(bestNextDonor.phone, notificationMessage);
    await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [bestNextDonor.id]);
    
    const adminMessage = `✅ Escalation successful. Notifying the next best match: *${bestNextDonor.name}* (Score: ${bestNextDonor.final_score.toFixed(1)}).`;
    await whatsappService.sendTextMessage(request.requested_by_phone, adminMessage);

    return { success: true, message: `Successfully escalated request and notified ${bestNextDonor.name}.` };
  }

  async findAndNotifyDonors(request) {
    const { id: requestId, blood_group, city, requested_by_phone, latitude: hospitalLat, longitude: hospitalLon } = request;
    
    try {
        let topScoredDonors = await this.findAndRankGeneralDonors(blood_group, city, []);

        if (topScoredDonors.length === 0) {
          await whatsappService.sendTextMessage(requested_by_phone, '⚠️ We searched our network but could not find any available donors at this moment.');
          return;
        }

        if (hospitalLat && hospitalLon) {
            topScoredDonors.forEach(donor => {
                donor.distance = donor.latitude ? getDistanceInKm(hospitalLat, hospitalLon, donor.latitude, donor.longitude) : Infinity;
            });
            topScoredDonors.sort((a, b) => a.distance - b.distance);
        }

        const bestDonor = topScoredDonors[0];
        const notificationMessage = `🚨 URGENT: You are a top-ranked match!\n\nPatient *${request.patient_name}* needs your help (${request.blood_group}) at ${request.hospital_name}.\n\nReply *YES ${request.short_code}* to help.`;
        
        await whatsappService.sendTextMessage(bestDonor.phone, notificationMessage);
        await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [bestDonor.id]);
        
        let adminMessage = `✅ Hyperlocal search complete. Notifying the best match: *${bestDonor.name}* (Score: ${bestDonor.final_score.toFixed(1)}, Dist: ${bestDonor.distance ? bestDonor.distance.toFixed(1) + ' km' : 'N/A'}).`;
        await whatsappService.sendTextMessage(requested_by_phone, adminMessage);
    } catch (error) {
        console.error(`CRITICAL ERROR in findAndNotifyDonors for request ${requestId}:`, error);
        await whatsappService.sendTextMessage(requested_by_phone, 'We encountered a system error while searching for donors. Our team has been notified.');
    }
  }
 async findAndRankGeneralDonors(bloodGroup, city, excludedDonorIds = []) {
    const { rows: availableDonors } = await db.query(
      `SELECT id, name, phone, last_donation, notifications_received, donations_confirmed, streak_count, latitude, longitude
       FROM users
       WHERE user_type = 'donor' AND blood_group = $1 AND city ILIKE $2
         AND availability_status = 'available' AND dnd_status = false
         AND (snooze_until IS NULL OR snooze_until < NOW())
         AND id NOT IN (SELECT unnest($3::uuid[]))
       LIMIT 50;`,
      [normalizeBloodGroup(bloodGroup), city, excludedDonorIds]
    );

    if (!availableDonors || availableDonors.length === 0) return [];
    
    const scoringPromises = availableDonors.map(donor => mlService.scoreSingleDonor(donor));
    const results = await Promise.allSettled(scoringPromises);

    const scoredDonors = availableDonors.map((donor, index) => {
        const score = results[index].status === 'fulfilled' ? results[index].value.final_score : 0;
        return { ...donor, final_score: score };
    });

    scoredDonors.sort((a, b) => b.final_score - a.final_score);
    return scoredDonors.slice(0, 5);
  }

}

export default new EmergencyService();

```

`backend/src/services/engagementService.js`

```javascript
// backend/src/services/engagementService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class EngagementService {
  /**
   * Finds donors whose 90-day cooldown period has ended and reminds them
   * that they are now eligible to donate again.
   */
  async sendEligibilityReminders() {
    console.log('CRON JOB: Running sendEligibilityReminders...');
    try {
      // 1. Find all donors who are ready to be re-activated.
      // - Their cooldown must have expired (cooldown_until <= NOW()).
      // - Their status must currently be 'unavailable' (from their last donation).
      // - They must not have opted out of all notifications (dnd_status = false).
      const { rows: eligibleDonors } = await db.query(
        `SELECT id, name, phone
         FROM users
         WHERE user_type = 'donor'
           AND availability_status = 'unavailable'
           AND dnd_status = false
           AND cooldown_until <= NOW()`
      );

      if (eligibleDonors.length === 0) {
        console.log('CRON JOB: No donors are newly eligible today.');
        return;
      }

      console.log(`CRON JOB: Found ${eligibleDonors.length} newly eligible donors. Preparing to send reminders.`);

      // 2. Prepare all the database updates.
      // We will collect all the user IDs to update their status in a single efficient query.
      const donorIdsToUpdate = eligibleDonors.map(donor => donor.id);
      const updatePromise = db.query(
        "UPDATE users SET availability_status = 'available' WHERE id = ANY($1::uuid[])",
        [donorIdsToUpdate]
      );

      // 3. Prepare all the WhatsApp messages.
      // We will send messages concurrently for maximum speed.
      const messagePromises = eligibleDonors.map(donor => {
        const message = `Hi ${donor.name}! 👋\n\nGreat news! Your 90-day waiting period is over, and you are now eligible to save a life again.\n\nYour status has been updated to "Available". Thank you for being a vital part of the BloodBridge community! ❤️`;
        return whatsappService.sendTextMessage(donor.phone, message);
      });

      // 4. Execute all promises (database updates and messages).
      // Promise.allSettled is used so that if one message fails, it doesn't stop the others.
      const results = await Promise.allSettled([updatePromise, ...messagePromises]);

      // 5. Log the results for monitoring.
      let successCount = 0;
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          if (index > 0) successCount++; // Don't count the DB update as a message
        } else {
          console.error(`CRON JOB: Failed to process reminder for donor ID ${donorIdsToUpdate[index - 1]}:`, result.reason);
        }
      });
      console.log(`CRON JOB: Successfully sent ${successCount} eligibility reminders.`);
      console.log(`CRON JOB: Updated ${donorIdsToUpdate.length} donors to 'available' status.`);

    } catch (error) {
      console.error('CRITICAL ERROR in cron job sendEligibilityReminders:', error);
    }
  }


   /**
   * Finds active, eligible donors who have not donated in a long time
   * and sends them a personalized re-engagement message.
   */
  async sendInactiveDonorNudges() {
    console.log('CRON JOB: Running Inactive Donor Nudge...');
    try {
      // 1. Find donors who are available but haven't donated in over 6 months (180 days).
      const { rows: inactiveDonors } = await db.query(
        `SELECT id, name, phone 
         FROM users
         WHERE 
           user_type = 'donor' AND
           availability_status = 'available' AND
           dnd_status = false AND
           (snooze_until IS NULL OR snooze_until < NOW()) AND
           (last_donation IS NULL OR last_donation < NOW() - INTERVAL '180 days')`
      );

      if (inactiveDonors.length === 0) {
        console.log('CRON JOB: No inactive donors to nudge this week.');
        return;
      }

      console.log(`CRON JOB: Found ${inactiveDonors.length} inactive donors. Sending nudges...`);
      for (const donor of inactiveDonors) {
        const nudgeMessage = `Hi ${donor.name}! We miss you. Patients in your area are still in need of heroes like you. We hope you'll consider donating again soon. Your support makes a huge difference!`;
        await whatsappService.sendTextMessage(donor.phone, nudgeMessage);
        // Add a small delay to avoid spamming the WhatsApp API
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    } catch (error) {
      console.error("CRITICAL ERROR in cron job sendInactiveDonorNudges:", error);
    }
  }
  // In backend/src/services/engagementService.js, inside the class

/**
 * Finds active, eligible donors who have not donated in a long time
 * and sends them a personalized re-engagement message.
 */
async sendInactiveDonorNudges() {
  console.log('CRON JOB: Running Inactive Donor Nudge...');
  try {
    // 1. Find donors who are available but haven't donated in over 6 months (180 days).
    const { rows: inactiveDonors } = await db.query(
      `SELECT id, name, phone 
       FROM users
       WHERE 
         user_type = 'donor' AND
         availability_status = 'available' AND
         dnd_status = false AND
         (snooze_until IS NULL OR snooze_until < NOW()) AND
         (last_donation IS NULL OR last_donation < NOW() - INTERVAL '180 days')`
    );

    if (inactiveDonors.length === 0) {
      console.log('CRON JOB: No inactive donors to nudge this week.');
      return;
    }

    console.log(`CRON JOB: Found ${inactiveDonors.length} inactive donors. Sending nudges...`);
    for (const donor of inactiveDonors) {
      const nudgeMessage = `Hi ${donor.name}! We miss you. Patients in your area are still in need of heroes like you. We hope you'll consider donating again soon. Your support makes a huge difference!`;
      await whatsappService.sendTextMessage(donor.phone, nudgeMessage);
    }
  } catch (error) {
    console.error("CRITICAL ERROR in cron job sendInactiveDonorNudges:", error);
  }
}
}

export default new EngagementService();

```

`backend/src/services/faqService.js`

```javascript
// backend/src/services/faqService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import mlService from './mlService.js'; // Use the mlService client

const SENSITIVE_KEYWORDS = ['problem', 'pain', 'issue', 'bad', 'reaction', 'scared', 'help me', 'confused', 'afraid'];

class FaqService {
  async handleFaq(query, phone) {
    console.log(`Getting RAG-powered FAQ answer for: "${query}"`);
    const disclaimer = "\n\n_Disclaimer: This is automated information. For medical advice, please consult a doctor._";
    
    try {
      const response = await mlService.client.post('/generate-faq-answer', { query });
      let answer = response.data?.answer || "Sorry, I couldn't find an answer to that question.";
      answer += disclaimer;
      await whatsappService.sendTextMessage(phone, answer);

      const lowerQuery = query.toLowerCase();
      if (SENSITIVE_KEYWORDS.some(keyword => lowerQuery.includes(keyword))) {
        console.log(`Sensitive keyword detected in "${query}". Escalating to admin inbox.`);
        await db.query( "INSERT INTO inbox_messages (user_phone, user_message, reason) VALUES ($1, $2, $3)", [phone, query, 'Sensitive Keyword Detected']);
        const escalationMessage = "It sounds like you might have a specific concern. I have notified an NGO volunteer, and they will contact you on this number shortly.";
        setTimeout(() => { whatsappService.sendTextMessage(phone, escalationMessage); }, 1500);
      }
    } catch (error) {
      console.error("Error calling FAQ service:", error.message);
      const fallbackMessage = "Thank you for your question. An NGO volunteer will get back to you shortly.";
      await whatsappService.sendTextMessage(phone, fallbackMessage);
    }
  }
}

export default new FaqService();

```

`backend/src/services/gamificationService.js`

```javascript
// backend/src/services/gamificationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

// A central place to define all possible achievements in the system.
const ACHIEVEMENTS = {
  FIRST_REGISTRATION: { name: 'Community Hero', points: 50, emoji: '❤️' },
  EMERGENCY_RESPONSE: { name: 'Life Saver', points: 100, emoji: '🚨' },
};

class GamificationService {
  /**
   * Awards points for a specific event, updates the user's total,
   * logs the achievement, and notifies the user.
   * @param {string} userId - The UUID of the user.
   * @param {string} event - The key for the achievement (e.g., 'FIRST_REGISTRATION').
   * @param {string} userPhone - The user's phone number for notification.
   */
  async awardPoints(userId, event, userPhone) {
    const achievement = ACHIEVEMENTS[event];
    if (!achievement) return;

    try {
      // Add points to the user's total score.
      const { rows: [user] } = await db.query(
        "UPDATE users SET gamification_points = gamification_points + $1 WHERE id = $2 RETURNING gamification_points",
        [achievement.points, userId]
      );

      if (!user) throw new Error("User not found or update failed.");

      // Log this specific achievement in the achievements table.
      await db.query(
        "INSERT INTO achievements(user_id, badge_type, points_awarded) VALUES($1, $2, $3)",
        [userId, achievement.name, achievement.points]
      );

      // Send a notification to the user.
      const notification = `🏆 Achievement Unlocked! 🏆\n\nYou've earned the *${achievement.name}* badge ${achievement.emoji} and received *${achievement.points} points*!\n\nYour new total is *${user.gamification_points} points*.`;
      await whatsappService.sendTextMessage(userPhone, notification);
    } catch (error) {
      console.error(`Error in awardPoints for user ${userId}:`, error);
    }
  }

  // --- THIS IS THE NEW, IMPLEMENTED FUNCTION ---
  /**
   * Fetches and formats a complete status report for a donor.
   * This is used by the 'get_my_dashboard' LangChain tool.
   * @param {string} phone - The donor's phone number.
   * @returns {string} A formatted message ready to be sent to the user.
   */
  async getDonorStatus(phone) {
    try {
      // 1. Get the user's main gamification data.
      const { rows: [user] } = await db.query(
        'SELECT id, name, gamification_points, last_donation FROM users WHERE phone = $1',
        [phone]
      );

      if (!user) {
        return "It looks like you're not registered as a donor yet. Reply with 'I want to register' to get started!";
      }

      // 2. Calculate the user's rank among all donors.
      const { rows: [rankData] } = await db.query(
        'SELECT count(*) FROM users WHERE user_type = \'donor\' AND gamification_points > $1',
        [user.gamification_points]
      );
      const rank = parseInt(rankData.count) + 1;

      // 3. Format the final message string.
      let statusMessage = `*📊 Your Donor Dashboard 📊*\n\n`;
      statusMessage += `*Name:* ${user.name}\n`;
      statusMessage += `*Points:* ${user.gamification_points} 🏅\n`;
      statusMessage += `*Current Rank:* #${rank} of all our heroes\n`;
      statusMessage += `*Last Donation:* ${user.last_donation ? new Date(user.last_donation).toLocaleDateString() : 'N/A'}`;
      
      // The function returns the complete string for the AI tool to use.
      return statusMessage;

    } catch (error) {
      console.error(`Error in getDonorStatus for phone ${phone}:`, error);
      return "Sorry, I couldn't fetch your status at this time. Please try again later.";
    }
  }
  // --- END OF NEW FUNCTION ---
}

export default new GamificationService();

```

`backend/src/services/geocodingService.js`

```javascript
// backend/src/services/geocodingService.js
import axios from 'axios';

class GeocodingService {
    async getCoords(address, city, pincode) {
        if (!address && !pincode) return null;
        const query = `${address || ''}, ${city || ''}, ${pincode || ''}`;
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
        try {
            const response = await axios.get(url, {
                headers: { 'User-Agent': 'BloodBridgeAI/1.0 (tech@bloodbridge.org)' }
            });
            if (response.data && response.data.length > 0) {
                const { lat, lon } = response.data[0];
                return { latitude: parseFloat(lat), longitude: parseFloat(lon) };
            }
            return null;
        } catch (error) {
            console.error('Error calling Geocoding API:', error.message);
            return null;
        }
    }
}

export default new GeocodingService();

```

`backend/src/services/mlService.js`

```javascript
// backend/src/services/mlService.js
import axios from 'axios';
import db from '../config/db.js';
import config from '../config/config.js';

const CACHE_DURATION_HOURS = 6;

class MLService {
    constructor() {
        this.client = axios.create({
            baseURL: config.mlServiceUrl,
            timeout: 8000,
        });
    }

    /**
     * Scores a single donor, using a cached score if available and not stale.
     */
    async scoreSingleDonor(donor) {
        // Check for a fresh score in the cache first.
        const { rows: [cachedData] } = await db.query(
            "SELECT last_ml_score, score_cached_at FROM users WHERE id = $1",
            [donor.id]
        );

        if (cachedData && cachedData.last_ml_score && cachedData.score_cached_at) {
            const cacheAgeHours = (new Date() - new Date(cachedData.score_cached_at)) / (1000 * 60 * 60);
            if (cacheAgeHours < CACHE_DURATION_HOURS) {
                console.log(`CACHE HIT: Using cached score for donor ${donor.id}`);
                return { final_score: cachedData.last_ml_score };
            }
        }

        console.log(`CACHE MISS: Calling ML service for donor ${donor.id}`);
        try {
            // If no fresh cache, call the Python ML service.
            const response = await this.client.post('/score-donor', {
                donor_id: donor.id,
                last_donation_date: donor.last_donation,
                streak_count: donor.streak_count || 0,
                notifications_received: donor.notifications_received || 0,
                donations_confirmed: donor.donations_confirmed || 0
            });
            
            const newScore = response.data.final_score;

            // Update the cache in the database with the new score.
            db.query(
                "UPDATE users SET last_ml_score = $1, score_cached_at = NOW() WHERE id = $2",
                [newScore, donor.id]
            ).catch(err => console.error(`Failed to cache ML score for donor ${donor.id}:`, err));

            return { final_score: newScore };

        } catch (error) {
            console.error(`🔴 ML Service Error for donor ${donor.id}:`, error.message);
            throw error; // Re-throw the error to be handled by the calling service.
        }
    }
}

export default new MLService();

```

`backend/src/services/patientService.js`

```javascript
// backend/src/services/patientService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class PatientService {
  /**
   * Handles the initial message from a potential patient.
   * Creates a pending record and asks them to opt-in by replying "APPLY".
   */
  async handleNewPatient(userMessage, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingPatient] } = await db.query("SELECT id FROM patients WHERE phone = $1", [sanitizedPhone]);
      if (existingPatient) {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back! Our records show you are already in our system. An admin will be in touch shortly.`);
        return;
      }

      // Create a blank, placeholder patient record to start the onboarding process.
      const patientName = 'Awaiting Input';
      const bloodGroup = 'N/A';
      const city = 'N/A';
      
      const { rows: [newPatient] } = await db.query(
        `INSERT INTO patients (name, phone, blood_group, city, status)
         VALUES ($1, $2, $3, $4, 'pending_opt_in') RETURNING id;`,
        [patientName, sanitizedPhone, bloodGroup, city]
      );
      
      console.log(`New patient lead logged. Patient ID: ${newPatient.id}`);
      
      // Always send the same opt-in message to start the conversation.
      await whatsappService.sendTextMessage(sanitizedPhone, `Thank you for reaching out. To begin your application for our Blood Bridge support program, please reply with: *APPLY*`);

    } catch (error) {
      console.error('Error in handleNewPatient:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'Sorry, we encountered an error logging your request.');
    }
  }
  
  /**
   * Starts the conversational form after the user replies "APPLY".
   */
  async startApplication(phone) {
      const { rows: [patient] } = await db.query("SELECT id FROM patients WHERE phone = $1 AND status = 'pending_opt_in'", [phone]);
      if (!patient) return false;

      await db.query("UPDATE patients SET status = 'pending_details' WHERE id = $1", [patient.id]);
      await this.continueOnboarding(patient.id, phone);
      return true;
  }

  /**
   * The "state machine" that asks the next question based on what info is missing.
   */
  async continueOnboarding(patientId, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE id = $1", [patientId]);
    if (!patient) return;

    if (patient.name === 'Awaiting Input') {
      await whatsappService.sendTextMessage(phone, "Great! Let's begin.\n\nFirst, what is the patient's full name?");
      return;
    }
    if (patient.blood_group === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Thank you. What is ${patient.name}'s blood group? (e.g., O+, AB-)`);
      return;
    }
    if (patient.city === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Got it. In which city does the patient receive treatment?`);
      return;
    }

    // All details are collected.
    await db.query("UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    const finalMessage = `Thank you! We have all the initial information we need for *${patient.name}*.\n\nAn admin has been notified and will contact you on this number to verify the details.`;
    await whatsappService.sendTextMessage(phone, finalMessage);
  }

  /**
   * Processes a user's reply during the conversational form.
   */
  async processOnboardingReply(message, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE phone = $1 AND status = 'pending_details'", [phone]);
    if (!patient) return false;

    let columnToUpdate = null;
    let valueToUpdate = message;
    
    if (patient.name === 'Awaiting Input') columnToUpdate = 'name';
    else if (patient.blood_group === 'N/A') {
      columnToUpdate = 'blood_group';
      valueToUpdate = normalizeBloodGroup(message);
    } else if (patient.city === 'N/A') columnToUpdate = 'city';
    
    if (columnToUpdate) {
        await db.query(`UPDATE patients SET ${columnToUpdate} = $1 WHERE id = $2`, [valueToUpdate, patient.id]);
        
        // Ask the next question after a short delay
        setTimeout(() => { this.continueOnboarding(patient.id, phone); }, 500);
        return true;
    }
    return false;
  }
}

export default new PatientService();

```

`backend/src/services/registrationService.js`

```javascript
// backend/src/services/registrationService.js
import db from '../config/db.js';
import whatsappService from '../services/whatsappService.js';
import gamificationService from './gamificationService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';

class RegistrationService {
  async handleNewDonor(params, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);

    try {
      const { rows: [existingUser] } = await db.query(
        "SELECT id, name, city, blood_group, registration_status FROM users WHERE phone = $1",
        [sanitizedPhone]
      );

      const { name, city, blood_group } = params;

      // ✅ CASE 1: Already registered
      if (existingUser && existingUser.registration_status === 'completed') {
        const msg = `Welcome back, ${existingUser.name}! You are already registered and ready to help.`;
        await whatsappService.sendTextMessage(sanitizedPhone, msg);
        return {
          status: 'complete',
          user: existingUser,
          needs: [],
          message: msg
        };
      }

      // ✅ CASE 2: User provides all details (complete registration in one go)
      if (name && city && blood_group) {
        const normalizedBG = normalizeBloodGroup(blood_group);
        let newUser;

        if (existingUser) {
          // Update pending → completed
          const { rows } = await db.query(
            `UPDATE users
             SET name = $1, city = $2, blood_group = $3,
                 registration_status = 'completed',
                 role = 'Emergency Donor',
                 user_type = 'donor'
             WHERE id = $4
             RETURNING *;`,
            [name, city, normalizedBG, existingUser.id]
          );
          newUser = rows[0];
        } else {
          // Fresh complete registration
          const { rows } = await db.query(
            `INSERT INTO users(name, city, blood_group, phone, user_type, registration_status, role)
             VALUES($1, $2, $3, $4, 'donor', 'completed', 'Emergency Donor')
             RETURNING *;`,
            [name, city, normalizedBG, sanitizedPhone]
          );
          newUser = rows[0];
        }

        const successMessage =
          `✅ Registration Complete!\n\nWelcome, ${newUser.name}! ` +
          `You are now a registered Blood Warrior in ${newUser.city}.`;

        await whatsappService.sendTextMessage(sanitizedPhone, successMessage);
        await gamificationService.awardPoints(newUser.id, 'FIRST_REGISTRATION', sanitizedPhone);

        return {
          status: 'complete',
          user: newUser,
          needs: [],
          message: successMessage
        };
      }

      // ✅ CASE 3: User says "I want to register" (no details)
      if (!existingUser) {
        // Only create placeholder if not already present
        console.log(`Creating a new 'pending' donor record for ${sanitizedPhone}.`);
        await db.query(
          `INSERT INTO users(name, phone, user_type, registration_status, role)
           VALUES ($1, $2, 'donor', 'pending', 'Unregistered')`,
          ['Pending User', sanitizedPhone]
        );
      }

      const followupMessage =
        "Thank you for your interest! To complete your registration, " +
        "please reply with your details in this format:\n\n" +
        "*Register: [Your Name], [Your City], [Your Blood Group]*";

      await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);

      return {
        status: 'partial',
        user: existingUser || { phone: sanitizedPhone, registration_status: 'pending' },
        needs: ['name', 'city', 'blood_group'],
        message: followupMessage
      };
    } catch (error) {
      console.error('Critical error in handleNewDonor:', error);

      const errMsg = 'We encountered an error during registration. Please try again later.';
      await whatsappService.sendTextMessage(sanitizedPhone, errMsg);

      return {
        status: 'error',
        user: null,
        needs: [],
        message: errMsg
      };
    }
  }
}

export default new RegistrationService();

```

`backend/src/services/responseService.js`

```javascript
// backend/src/services/responseService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateOTP } from '../utils/otpHelper.js';
import gamificationService from './gamificationService.js';
import bridgeService from './bridgeService.js';
import BridgeCoordinationService from './bridgeCoordinationService.js';

class ResponseService {
    /**
     * Handles the donor's initial reply (e.g., "YES 1234").
     * It validates the code and sends back a 6-digit OTP to verify.
     */
    async handleDonorReplyWithShortCode(donorPhone, shortCode) {
        try {
            const { rows: [request] } = await db.query(`SELECT id FROM emergency_requests WHERE short_code = $1 AND status = 'active'`, [shortCode]);
            if (!request) {
                await whatsappService.sendTextMessage(donorPhone, `Sorry, we couldn't find an active request with code ${shortCode}. It may have been fulfilled.`);
                return;
            }

            const { rows: [user] } = await db.query(`SELECT id FROM users WHERE phone = $1`, [donorPhone]);
            if (!user) {
                await whatsappService.sendTextMessage(donorPhone, "We couldn't find your registration. Please register first.");
                return;
            }

            const otp = generateOTP();
            await db.query(
                `INSERT INTO donor_responses (donor_id, request_id, response, otp, otp_expires_at)
                 VALUES ($1, $2, 'pending', $3, NOW() + INTERVAL '10 minutes')
                 ON CONFLICT (donor_id, request_id) DO UPDATE SET response = 'pending', otp = $3, otp_expires_at = NOW() + INTERVAL '10 minutes';`,
                [user.id, request.id, otp]
            );

            const otpMessage = `Thank you for your quick response! To finalize your confirmation, please reply with *only* the following 6-digit code:\n\n*${otp}*`;
            await whatsappService.sendTextMessage(donorPhone, otpMessage);
        } catch (error) {
            console.error('Error in handleDonorReplyWithShortCode:', error);
            await whatsappService.sendTextMessage(donorPhone, "There was a system error processing your reply.");
        }
    }

    /**
     * Verifies the 6-digit OTP and finalizes the donation confirmation.
     * This function uses a database transaction to ensure all updates succeed or none do.
     */
    // In responseService.js
async verifyOTPAndConfirm(donorPhone, otp) {
    const client = await db.pool.connect();
    try {
        await client.query('BEGIN');

        const { rows: [response] } = await client.query(
            // Add request_type and bridge_id to the SELECT statement
            `SELECT dr.id, dr.request_id, u.name as donor_name, u.id as donor_id, 
                    er.patient_name, er.requested_by_phone, er.request_type, er.bridge_id
             FROM donor_responses dr JOIN users u ON dr.donor_id = u.id JOIN emergency_requests er ON dr.request_id = er.id
             WHERE u.phone = $1 AND dr.otp = $2 AND dr.otp_expires_at > NOW() AND dr.response = 'pending' FOR UPDATE;`,
            [donorPhone, otp]
        );

        if (!response) {
            await whatsappService.sendTextMessage(donorPhone, "Invalid or expired OTP. Please try the 'YES [code]' step again.");
            await client.query('ROLLBACK');
            return;
        }

        // Perform all database updates
        await client.query(`UPDATE users SET last_donation = NOW(), availability_status = 'unavailable', cooldown_until = NOW() + INTERVAL '90 days', donations_confirmed = donations_confirmed + 1, streak_count = streak_count + 1 WHERE id = $1`, [response.donor_id]);
        await client.query("UPDATE donor_responses SET response = 'accepted', confirmed_at = NOW(), otp = NULL WHERE id = $1", [response.id]);
        await client.query("UPDATE emergency_requests SET status = 'fulfilled' WHERE id = $1", [response.request_id]);
        
        // --- NEW LOGIC: ROTATE THE BRIDGE IF APPLICABLE ---
        // We pass the active transaction client to the rotation function
        if (response.request_type === 'bridge' && response.bridge_id) {
            await bridgeCoordinationService.rotateBridge(response.bridge_id, client);
        }
        // --- END NEW LOGIC ---

        await client.query('COMMIT');

        // Send confirmations and award points
        const donorConfirmationMessage = `✅ Confirmed! Thank you, ${response.donor_name}!\n\nYour donation for *${response.patient_name}* is confirmed. Please coordinate with the hospital. You are a true hero!`;
        await whatsappService.sendTextMessage(donorPhone, donorConfirmationMessage);

        if (response.requested_by_phone && response.requested_by_phone !== 'system') {
            const requesterUpdate = `✅ Good News! A donor has been confirmed for your request for *${response.patient_name}*.`;
            await whatsappService.sendTextMessage(response.requested_by_phone, requesterUpdate);
        }
        gamificationService.awardPoints(response.donor_id, 'EMERGENCY_RESPONSE', donorPhone);

    } catch (error) {
        await client.query('ROLLBACK');
        console.error("Error verifying OTP:", error);
        await whatsappService.sendTextMessage(donorPhone, "A system error occurred during OTP verification.");
    } finally {
        client.release();
    }
}
}

export default new ResponseService();

```

`backend/src/services/whatsappService.js`

```javascript
// backend/src/services/whatsappService.js
import axios from 'axios';
import config from '../config/config.js';

class WhatsAppService {
  constructor() {
    this.token = config.whatsappToken;
    this.phoneNumberId = config.whatsappPhoneNumberId;

    if (!this.token || !this.phoneNumberId) {
      console.warn('WhatsApp token or Phone Number ID are missing from configuration. Messages will not be sent.');
    }

    this.client = axios.create({
      baseURL: `https://graph.facebook.com/v18.0/${this.phoneNumberId}`,
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Content-Type': 'application/json'
      }
    });
  }

  /**
   * Sends a text message.
   * @param {string} to - The recipient's phone number (e.g., '918000000000').
   * @param {string} text - The message body.
   */
  async sendTextMessage(to, text) {
    if (!this.token) return { success: false, error: "WhatsApp service not configured." };

    const payload = {
      messaging_product: 'whatsapp',
      to: to,
      type: 'text',
      text: { body: text }
    };
    try {
      const response = await this.client.post('/messages', payload);
      console.log(`✅ Message sent successfully to ${to}.`);
      return { success: true, data: response.data };
    } catch (error) {
      console.error(`🔴 FAILED to send message to ${to}.`);
      if (error.response) {
        console.error(`Error Details: ${error.response.data.error?.message}`);
      }
      return { success: false, error: error.message };
    }
  }
}

export default new WhatsAppService();

```

`backend/src/utils/dataSanitizer.js`

```javascript
// backend/src/utils/dataSanitizer.js
export const normalizeBloodGroup = (group) => {
  if (!group) return 'Unknown';
  const upperGroup = group.toUpperCase();
  let normalized = upperGroup.replace(/\s/g, '').replace('POSITIVE', '+').replace('NEGATIVE', '-');
  if (normalized.endsWith('POS')) normalized = normalized.replace('POS', '+');
  if (normalized.endsWith('NEG')) normalized = normalized.replace('NEG', '-');
  return normalized.slice(0, 5);
};

```

`backend/src/utils/distanceHelper.js`

```javascript
// backend/src/utils/distanceHelper.js
/**
 * Calculates distance between two lat/lng points in km using the Haversine formula.
 */
export const getDistanceInKm = (lat1, lon1, lat2, lon2) => {
    if ((lat1 == lat2) && (lon1 == lon2)) {
        return 0;
    }
    const R = 6371; // Radius of the earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        0.5 - Math.cos(dLat) / 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        (1 - Math.cos(dLon)) / 2;
    return R * 2 * Math.asin(Math.sqrt(a));
};

```

`backend/src/utils/otpHelper.js`

```javascript
// backend/src/utils/otpHelper.js

/**
 * Generates a 4-digit numeric code for donors to reply with.
 * @returns {string} A 4-digit string.
 */
export const generateShortCode = () => {
  return Math.floor(1000 + Math.random() * 9000).toString();
};

/**
 * Generates a 6-digit numeric OTP for final confirmation.
 * @returns {string} A 6-digit string.
 */
export const generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

```

`backend/src/utils/phoneHelper.js`

```javascript
// backend/src/utils/phoneHelper.js
export const normalizePhoneNumber = (phone) => {
  if (!phone || typeof phone !== 'string') return null;
  let digits = phone.replace(/\D/g, '');
  if (digits.startsWith('91') && digits.length === 12) {
    return `+${digits}`;
  } else if (digits.length === 10) {
    return `+91${digits}`;
  }
  return `+${digits}`;
};

```

`code.txt`

```

```

`db.txt`

```

-- Create users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    phone VARCHAR(15) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    password VARCHAR(255), -- For admin login
    blood_group VARCHAR(5), -- e.g., 'A+', 'O-', 'AB+'
    city VARCHAR(100),
    pincode VARCHAR(10),
    user_type VARCHAR(50) NOT NULL CHECK (user_type IN ('donor', 'patient', 'admin')),
    role VARCHAR(50) DEFAULT 'Emergency Donor',
    registration_status VARCHAR(50) DEFAULT 'completed' CHECK (registration_status IN ('pending', 'completed')),
    availability_status VARCHAR(50) DEFAULT 'available' CHECK (availability_status IN ('available', 'unavailable', 'on_hold')),
    dnd_status BOOLEAN DEFAULT false,
    snooze_until TIMESTAMPTZ,
    cooldown_until TIMESTAMPTZ,
    last_donation DATE,
    donations_till_date INTEGER DEFAULT 0 CHECK (donations_till_date >= 0),
    gamification_points INTEGER DEFAULT 0 CHECK (gamification_points >= 0),
    streak_count INTEGER DEFAULT 0 CHECK (streak_count >= 0),
    last_ml_score REAL,
    score_cached_at TIMESTAMPTZ,
    last_request_short_code VARCHAR(4),
    quiet_hours_start TIME,
    quiet_hours_end TIME,
    inactive_trigger_comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT valid_blood_group CHECK (blood_group IN ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-', 'Unknown'))
);

-- Create patients table (standalone, no user_id foreign key)
CREATE TABLE patients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    phone VARCHAR(15) NOT NULL UNIQUE,
    blood_group VARCHAR(5) NOT NULL,
    city VARCHAR(100) NOT NULL,
    pincode VARCHAR(10),
    condition TEXT, -- e.g., 'thalassemia'
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'pending_verification', 'bridged', 'active')),
    last_transfusion_date DATE,
    frequency_in_days INTEGER CHECK (frequency_in_days > 0),
    quantity_required INTEGER DEFAULT 1 CHECK (quantity_required > 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT valid_blood_group CHECK (blood_group IN ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'))
);

-- Create emergency_requests table
CREATE TABLE emergency_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    patient_name VARCHAR(255) NOT NULL,
    blood_group VARCHAR(5) NOT NULL,
    units_needed INTEGER NOT NULL CHECK (units_needed > 0),
    hospital_name VARCHAR(255) NOT NULL,
    hospital_contact VARCHAR(15),
    city VARCHAR(100) NOT NULL,
    urgency_level VARCHAR(50) DEFAULT 'high' CHECK (urgency_level IN ('critical', 'high', 'medium')),
    status VARCHAR(50) DEFAULT 'active' CHECK (status IN ('active', 'fulfilled', 'closed', 'escalated')),
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    requested_by_phone VARCHAR(15) NOT NULL,
    short_code VARCHAR(4) UNIQUE,
    units_confirmed INTEGER DEFAULT 0 CHECK (units_confirmed >= 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    fulfilled_at TIMESTAMPTZ,
    CONSTRAINT valid_blood_group CHECK (blood_group IN ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'))
);

-- Create blood_bridges table
CREATE TABLE blood_bridges (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    patient_id UUID REFERENCES patients(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    blood_group VARCHAR(5) NOT NULL,
    city VARCHAR(100) NOT NULL,
    rotation_position INTEGER DEFAULT 1 CHECK (rotation_position >= 1),
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT valid_blood_group CHECK (blood_group IN ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'))
);

-- Create bridge_members table
CREATE TABLE bridge_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    bridge_id UUID REFERENCES blood_bridges(id) ON DELETE CASCADE,
    donor_id UUID REFERENCES users(id) ON DELETE CASCADE,
    position INTEGER NOT NULL CHECK (position >= 0),
    status VARCHAR(50) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'skipped')),
    joined_at TIMESTAMPTZ DEFAULT NOW(),
    rotation_order INTEGER,
    UNIQUE(bridge_id, donor_id)
);

-- Create donor_responses table
CREATE TABLE donor_responses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    donor_id UUID REFERENCES users(id) ON DELETE CASCADE,
    request_id UUID REFERENCES emergency_requests(id) ON DELETE CASCADE,
    response VARCHAR(50) NOT NULL CHECK (response IN ('pending', 'accepted', 'declined')),
    otp VARCHAR(6),
    otp_expires_at TIMESTAMPTZ,
    confirmed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(donor_id, request_id)
);

-- Create inbox_messages table
CREATE TABLE inbox_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_phone VARCHAR(15) NOT NULL,
    user_message TEXT NOT NULL,
    reason VARCHAR(255) NOT NULL,
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'resolved')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    resolved_at TIMESTAMPTZ
);

-- Create processed_messages table
CREATE TABLE processed_messages (
    message_id VARCHAR(255) PRIMARY KEY,
    processed_at TIMESTAMPTZ DEFAULT NOW(),
    payload JSONB
);

-- Create achievements table
CREATE TABLE achievements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    badge_type VARCHAR(255) NOT NULL,
    points_awarded INTEGER DEFAULT 0 CHECK (points_awarded >= 0),
    earned_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create knowledge_base table
CREATE TABLE knowledge_base (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    category VARCHAR(255),
    embedding VECTOR -- Requires pgvector extension
);

-- Create schema_migrations table
CREATE TABLE schema_migrations (
    version VARCHAR(255) PRIMARY KEY,
    applied_at TIMESTAMPTZ DEFAULT NOW(),
    description TEXT
);

-- Create conversations table
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    message TEXT NOT NULL,
    response TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create optimized donor search function
CREATE OR REPLACE FUNCTION find_donors_for_bridge(
    p_city VARCHAR,
    p_blood_group VARCHAR,
    p_pincode VARCHAR,
    p_limit INTEGER
)
RETURNS TABLE (donor_id UUID, final_score FLOAT) AS $$
BEGIN
    RETURN QUERY
    SELECT
        u.id AS donor_id,
        COALESCE(u.last_ml_score, 0.0) AS final_score
    FROM users u
    WHERE
        u.user_type = 'donor'
        AND u.city ILIKE p_city
        AND u.blood_group = p_blood_group
        AND u.availability_status = 'available'
        AND u.dnd_status = false
        AND (u.snooze_until IS NULL OR u.snooze_until < NOW())
        AND u.registration_status = 'completed'
        AND u.id NOT IN (
            SELECT bm.donor_id 
            FROM bridge_members bm 
            JOIN blood_bridges bb ON bm.bridge_id = bb.id 
            WHERE bb.active = true
        )
    ORDER BY
        COALESCE(u.last_ml_score, 0.0) DESC,
        u.created_at ASC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Create indexes for performance
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_blood_group ON users(blood_group);
CREATE INDEX idx_users_city ON users(city);
CREATE INDEX idx_users_user_type ON users(user_type);
CREATE INDEX idx_patients_phone ON patients(phone);
CREATE INDEX idx_emergency_requests_short_code ON emergency_requests(short_code);
CREATE INDEX idx_bridge_members_bridge_id ON bridge_members(bridge_id);
CREATE INDEX idx_donor_responses_donor_id ON donor_responses(donor_id);
CREATE INDEX idx_knowledge_base_category ON knowledge_base(category);

-- Enable Row-Level Security (RLS)
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE patients ENABLE ROW LEVEL SECURITY;
ALTER TABLE emergency_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE blood_bridges ENABLE ROW LEVEL SECURITY;
ALTER TABLE bridge_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE donor_responses ENABLE ROW LEVEL SECURITY;
ALTER TABLE inbox_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE processed_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE knowledge_base ENABLE ROW LEVEL SECURITY;
ALTER TABLE schema_migrations ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- Insert test data
INSERT INTO users (
    name, phone, password, blood_group, city, pincode, user_type, 
    role, registration_status, availability_status
) VALUES (
    'Admin User', '+918000000000', 'admin123', NULL, NULL, NULL, 
    'admin', 'admin', 'completed', 'available'
), (
    'Test Donor', '+911234567890', NULL, 'O+', 'Hyderabad', '500001', 
    'donor', 'Emergency Donor', 'completed', 'available'
) ON CONFLICT (phone) DO NOTHING;

INSERT INTO patients (
    name, phone, blood_group, city, pincode, status
) VALUES (
    'John Doe', '+919876543210', 'A+', 'Delhi', '110001', 'pending_verification'
) ON CONFLICT (phone) DO NOTHING;

-- Insert initial schema migration
INSERT INTO schema_migrations (version, description)
VALUES ('2025082901', 'Initial schema for BloodBridge AI') ON CONFLICT (version) DO NOTHING;

-- Enable pgvector extension for knowledge_base.embedding
CREATE EXTENSION IF NOT EXISTS vector;

```

`ml_services/.env`

```
# ml_services/.env

# This should be the same database URL used in your backend/.env file.
DATABASE_URL="postgresql://postgres.psussvygzgzkkwdjqbwp:asdfusahdfuu3842r7gdsfh@aws-1-ap-southeast-1.pooler.supabase.com:6543/postgres"
GEMINI_API_KEY="AIzaSyAvPuLpiCRezLDdJZt9eqW67vt1_BrG92w"

```

`ml_services/main.py`

```python
# ml_services/main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
from sentence_transformers import SentenceTransformer, util
import os
import psycopg2
from dotenv import load_dotenv # <-- ADD THIS LINE

load_dotenv() # <-- AND ADD THIS LINE

# --- Configuration ---
# Caches the ML model locally to avoid re-downloading
os.environ['SENTENCE_TRANSFORMERS_HOME'] = './.cache'

print("Loading sentence-transformer model...")
MODEL_NAME = 'all-MiniLM-L6-v2'
model = SentenceTransformer(MODEL_NAME)
print("Model loaded successfully.")

# --- Pydantic Models for type validation ---
class DonorScoreRequest(BaseModel):
    donor_id: str
    last_donation_date: Optional[str] = None
    streak_count: int = 0
    notifications_received: int = 0
    donations_confirmed: int = 0

class DonorScoreResponse(BaseModel):
    donor_id: str
    availability_score: float
    reliability_score: float
    final_score: float

# --- FastAPI App ---
app = FastAPI(title="BloodBridge AI Engine")

# --- Helper Functions ---
def calculate_availability_score(last_donation_date: Optional[str]) -> float:
    if not last_donation_date:
        return 100.0
    try:
        last_date = datetime.fromisoformat(last_donation_date.replace('Z', '+00:00'))
        days_since = (datetime.now(last_date.tzinfo) - last_date).days
        if days_since >= 90: return 100.0
        if days_since < 56: return 0.0
        # Linearly scale the score between 56 and 90 days
        return round(((days_since - 56) / (90 - 56)) * 100, 2)
    except (ValueError, TypeError):
        return 100.0 # Default to available if date is invalid

def calculate_reliability_score(streak: int, notifications: int, confirmations: int) -> float:
    # Score based on donation streak (max 40 points)
    streak_score = min(streak * 10, 40)
    
    # Score based on response rate (max 60 points)
    if notifications == 0:
        response_score = 40.0 # Default score for new donors
    else:
        response_rate = confirmations / notifications
        response_score = response_rate * 60
        
    return min(streak_score + response_score, 100.0)

# --- API Endpoints ---
@app.get("/health", summary="Health Check")
async def health_check():
    return {"status": "healthy"}

@app.post("/score-donor", response_model=DonorScoreResponse, summary="Scores a single donor")
async def score_donor(request: DonorScoreRequest):
    availability = calculate_availability_score(request.last_donation_date)
    
    reliability = calculate_reliability_score(
        request.streak_count, 
        request.notifications_received, 
        request.donations_confirmed
    )
    
    # Final score is a weighted average
    final_score = (availability * 0.6) + (reliability * 0.4)
    if availability == 0:
        final_score = 0
        
    return DonorScoreResponse(
        donor_id=request.donor_id,
        availability_score=availability,
        reliability_score=reliability,
        final_score=round(final_score, 2)
    )

```

`ml_services/requirements.txt`

```
# ml_services/requirements.txt
fastapi==0.111.0
uvicorn[standard]==0.29.0
pydantic==2.7.1
sentence-transformers==2.7.0
scikit-learn==1.3.0
psycopg2-binary==2.9.9
torch==2.1.2
numpy==1.26.4
python-dotenv

```

