`admin-dashboard/code2.txt`

```
`code.txt`

```
`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`src/App.jsx`

```javascript
// src/App.jsx

import React, { useState } from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import LoginPage from './LoginPage.jsx';
import Dashboard from './Dashboard.jsx';
import theme from './theme.js';

/**
 * The main App component.
 * It acts as the root of the application, managing authentication state
 * and providing the global MUI theme.
 */
function App() {
  // State to track if the user is logged in. Default is false.
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  // Function to be passed to LoginPage to handle successful login
  const handleLogin = () => {
    setIsLoggedIn(true);
  };

  // Function to be passed to Dashboard to handle logout
  const handleLogout = () => {
    setIsLoggedIn(false);
  };

  return (
    // ThemeProvider applies the custom theme to all descendant components.
    // CssBaseline provides a consistent baseline style across browsers.
    <ThemeProvider theme={theme}>
      <CssBaseline />
      {/* Conditionally render Dashboard or LoginPage based on login state */}
      {isLoggedIn ? (
        <Dashboard onLogout={handleLogout} />
      ) : (
        <LoginPage onLogin={handleLogin} />
      )}
    </ThemeProvider>
  );
}

export default App;

```

`src/Dashboard.jsx`

```javascript
// src/Dashboard.jsx

import React, { useState, useEffect } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Grid, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress,
  Button,
} from "@mui/material";

import { Bloodtype, LocationCity, AddLink, Close } from "@mui/icons-material";

// ✅ Dummy API functions (replace with real API calls)
const fetchPendingPatients = async () =>
  Promise.resolve([
    { id: 1, name: "John Doe", blood_group: "A+", city: "Delhi" },
    { id: 2, name: "Jane Smith", blood_group: "O-", city: "Mumbai" },
  ]);

const fetchActiveEmergencies = async () =>
  Promise.resolve([
    { id: 3, patient_name: "Alex", blood_group: "B+", status: "Urgent" },
    { id: 4, patient_name: "Maria", blood_group: "AB-", status: "Open" },
  ]);

const Dashboard = ({ onLogout }) => {
  const [tabValue, setTabValue] = useState(0);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm")); // <600px
  const isTablet = useMediaQuery(theme.breakpoints.between("sm", "md")); // 600-900px
  const isLaptop = useMediaQuery(theme.breakpoints.between("md", "lg")); // 900-1200px

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      const apiCall = tabValue === 0 ? fetchPendingPatients : fetchActiveEmergencies;
      const result = await apiCall();
      setData(result);
      setLoading(false);
    };
    loadData();
  }, [tabValue]);

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // ✅ Card list for small & medium screens
  const renderCardList = () => (
    <Grid container spacing={2}>
      {data.map((item) => (
        <Grid item xs={12} sm={6} md={4} key={item.id}>
          <Card variant="outlined" sx={{ height: "100%" }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                {tabValue === 0 ? item.name : item.patient_name}
              </Typography>
              <Stack direction="column" spacing={1}>
                <Chip
                  icon={<Bloodtype />}
                  label={`Blood Group: ${item.blood_group}`}
                  size="small"
                />
                {tabValue === 0 ? (
                  <Chip
                    icon={<LocationCity />}
                    label={`City: ${item.city}`}
                    size="small"
                  />
                ) : (
                  <Chip label={`Status: ${item.status}`} color="warning" size="small" />
                )}
              </Stack>
            </CardContent>
            <CardActions sx={{ justifyContent: "flex-end" }}>
              {tabValue === 0 ? (
                <Button variant="contained" size="small" startIcon={<AddLink />}>
                  Create Bridge
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="secondary"
                  size="small"
                  startIcon={<Close />}
                >
                  Close Request
                </Button>
              )}
            </CardActions>
          </Card>
        </Grid>
      ))}
    </Grid>
  );

  // ✅ Table for larger screens (Laptop & Desktop)
  const renderTable = () => (
    <TableContainer>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>{tabValue === 0 ? "Name" : "Patient Name"}</TableCell>
            <TableCell>Blood Group</TableCell>
            <TableCell>{tabValue === 0 ? "City" : "Status"}</TableCell>
            <TableCell align="right">Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {data.map((item) => (
            <TableRow hover key={item.id}>
              <TableCell>{tabValue === 0 ? item.name : item.patient_name}</TableCell>
              <TableCell>
                <Chip
                  label={item.blood_group}
                  color="primary"
                  variant="outlined"
                  size="small"
                />
              </TableCell>
              <TableCell>
                {tabValue === 0 ? (
                  item.city
                ) : (
                  <Chip label={item.status} color="warning" size="small" />
                )}
              </TableCell>
              <TableCell align="right">
                {tabValue === 0 ? (
                  <Button variant="contained" size="small" startIcon={<AddLink />}>
                    Create Bridge
                  </Button>
                ) : (
                  <Button
                    variant="contained"
                    color="secondary"
                    size="small"
                    startIcon={<Close />}
                  >
                    Close Request
                  </Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );

// inside src/Dashboard.jsx — modify the JSX return where Container is used:

  return (
    <Box
      sx={{
        flexGrow: 1,
        backgroundColor: theme.palette.background.default,
        minHeight: "100vh",
      }}
    >
      {/* AppBar stays full width of viewport */}
      <AppBar position="static" sx={{ boxShadow: 1 }}>
        <Toolbar sx={{ px: { xs: 2, md: 4 } }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            🩸 BloodBridge AI
          </Typography>
          <Button color="inherit" onClick={onLogout}>
            Logout
          </Button>
        </Toolbar>
      </AppBar>

      {/* Make container span full width but keep inner content centered with a maxWidth */}
      <Container
        maxWidth={false}
        disableGutters
        sx={{
          px: { xs: 2, md: 4 },
          py: 4,
        }}
      >
        {/* center the page content while allowing it to be fluid on small screens */}
        <Box sx={{ width: "100%", maxWidth: 1100, mx: "auto" }}>
          <Typography variant="h4" gutterBottom>
            Admin Dashboard
          </Typography>

          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Box sx={{ borderBottom: 1, borderColor: "divider", mb: 3 }}>
              <Tabs value={tabValue} onChange={handleTabChange}>
                <Tab label="Pending Patients" />
                <Tab label="Active Emergencies" />
              </Tabs>
            </Box>

            {loading ? (
              <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
                <CircularProgress />
              </Box>
            ) : (
              // responsive decision: cards for small/tablet, table for larger screens
              (isMobile || isTablet) ? renderCardList() : renderTable()
            )}
          </Paper>
        </Box>
      </Container>
    </Box>
  );

};

export default Dashboard;

```

`src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`src/LoginPage.jsx`

```javascript
// src/LoginPage.jsx

import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert } from '@mui/material';

/**
 * The LoginPage component.
 * It displays a simple login form and validates the password.
 * On successful validation, it calls the onLogin prop function.
 */
const LoginPage = ({ onLogin }) => {
  // State to hold the password input value
  const [password, setPassword] = useState('');
  // State to hold any login error messages
  const [error, setError] = useState('');

  // Handles the form submission
  const handleSubmit = (event) => {
    event.preventDefault(); // Prevent default form submission behavior

    // Simple validation: check if the password is "admin"
    if (password === 'admin') {
      setError(''); // Clear any previous errors
      onLogin(); // Call the parent component's login handler
    } else {
      // Set an error message for incorrect password
      setError('Incorrect password. Hint: try "admin"');
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Typography component="h1" variant="h5">
          🩸 BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {/* Display an error alert if the error state is not empty */}
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2 }}
          >
            Sign In
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;   

```

`src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

// It's good practice to have a minimal CSS reset or base styles.
// You can leave the default index.css or make it an empty file for now.
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

`src/mockApi.js`

```javascript
// src/mockApi.js

/**
 * This file acts as a fake backend API.
 * The functions here simulate network requests by returning a Promise
 * that resolves with mock data after a 500ms delay.
 */

// Mock data for the "Pending Patients" tab
const mockPendingPatients = [
  { "id": "p1", "name": "Aarav Sharma", "blood_group": "A+", "city": "Delhi" },
  { "id": "p2", "name": "Saanvi Gupta", "blood_group": "O-", "city": "Mumbai" },
  { "id": "p3", "name": "Vihaan Reddy", "blood_group": "B+", "city": "Bangalore" },
  { "id": "p4", "name": "Diya Singh", "blood_group": "AB-", "city": "Kolkata" }
];

// Mock data for the "Active Emergencies" tab
const mockActiveEmergencies = [
  { "id": "e1", "patient_name": "Isha Patel", "blood_group": "AB+", "status": "Searching" },
  { "id": "e2", "patient_name": "Rohan Kumar", "blood_group": "O+", "status": "Partially Fulfilled" },
  { "id": "e3", "patient_name": "Ananya Joshi", "blood_group": "A-", "status": "Critical" }
];

/**
 * Fetches a list of pending patients.
 * @returns {Promise<Array<Object>>} A promise that resolves to the patient list.
 */
export const fetchPendingPatients = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockPendingPatients);
    }, 500); // 500ms delay to simulate network latency
  });
};

/**
 * Fetches a list of active emergencies.
 * @returns {Promise<Array<Object>>} A promise that resolves to the emergencies list.
 */
export const fetchActiveEmergencies = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockActiveEmergencies);
    }, 500); // 500ms delay to simulate network latency
  });
};

```

`src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

```

`admin-dashboard/eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`admin-dashboard/index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`admin-dashboard/src/api/apiClient.js`

```javascript
// src/api/apiClient.js
import axios from 'axios';

const BASE = (import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001').replace(/\/$/, '');

const apiClient = axios.create({
  baseURL: BASE,
  headers: { 'Content-Type': 'application/json' },
  timeout: 20000,
});

// simple map to avoid spamming same error repeatedly
const loggedUrls = new Set();

apiClient.interceptors.request.use((config) => {
  const url = config.url || '';
  // attach token for everything except login/register
  if (!url.includes('/login') && !url.includes('/register')) {
    const token = localStorage.getItem('token');
    if (token && typeof token === 'string' && token.split('.').length === 3) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }
  return config;
});

apiClient.interceptors.response.use(
  (res) => res,
  (err) => {
    const out = {
      url: err.config?.url,
      status: err.response?.status,
      message: err.message,
      data: err.response?.data,
    };

    // Log each failing URL once to reduce noise
    if (!loggedUrls.has(out.url)) {
      loggedUrls.add(out.url);
      console.error('API request failed:', out);
    }

    const normalized = new Error(out.message || 'API error');
    normalized.url = out.url;
    normalized.status = out.status;
    normalized.data = out.data;
    return Promise.reject(normalized);
  }
);

export default apiClient;

```

`admin-dashboard/src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`admin-dashboard/src/App.jsx`

```javascript
// admin-dashboard/src/App.jsx
import React from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import { AuthProvider } from './context/AuthContext.jsx';
import { Routes, Route, Navigate } from 'react-router-dom'; // ✅ IMPORT ROUTER COMPONENTS
import theme from './theme.js';
import LoginPage from './pages/LoginPage.jsx';
import DashboardPage from './pages/Dashboard.jsx';
import { useAuth } from './hooks/useAuth.js';

/**
 * A protected route component. If the user is not logged in,
 * it redirects them to the login page.
 */
const ProtectedRoute = ({ children }) => {
  const { isLoggedIn } = useAuth();
  return isLoggedIn ? children : <Navigate to="/" />;
};

/**
 * The main App component, now with a proper routing structure.
 */
function App() {
  return (
    <AuthProvider>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <Routes>
          <Route path="/" element={<LoginPage />} />
          <Route 
            path="/dashboard" 
            element={
              <ProtectedRoute>
                <DashboardPage />
              </ProtectedRoute>
            } 
          />
        </Routes>
      </ThemeProvider>
    </AuthProvider>
  );
}

export default App;

```

`admin-dashboard/src/components/common/ConfirmationDialog.jsx`

```javascript
// src/components/common/ConfirmationDialog.jsx
import React, { useState, useCallback } from 'react';
import PropTypes from 'prop-types';
import {
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from '@mui/material';

/**
 * Reusable confirmation dialog.
 * - Awaits async onConfirm handlers before closing.
 * - Disables buttons while processing to avoid duplicate calls.
 */
const ConfirmationDialog = ({ open, onClose, onConfirm, title, message, confirmText = 'Confirm', cancelText = 'Cancel' }) => {
  const [processing, setProcessing] = useState(false);

  const handleConfirm = useCallback(async () => {
    if (processing) return;
    setProcessing(true);
    try {
      if (typeof onConfirm === 'function') {
        // Call handler and await if it returns a promise
        const result = onConfirm();
        if (result && typeof result.then === 'function') {
          await result;
        }
      }
    } catch (err) {
      // Log — parent can set error state if needed
      // Avoid swallowing errors silently in prod; you may surface this to UI
      // eslint-disable-next-line no-console
      console.error('ConfirmationDialog onConfirm error:', err);
    } finally {
      setProcessing(false);
      if (typeof onClose === 'function') onClose();
    }
  }, [onConfirm, onClose, processing]);

  return (
    <Dialog
      open={Boolean(open)}
      onClose={() => {
        if (!processing && typeof onClose === 'function') onClose();
      }}
      aria-labelledby="confirmation-dialog-title"
      aria-describedby="confirmation-dialog-description"
      fullWidth
      maxWidth="xs"
    >
      <DialogTitle id="confirmation-dialog-title">{title}</DialogTitle>
      <DialogContent>
        <DialogContentText id="confirmation-dialog-description">
          {message}
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={() => { if (!processing && typeof onClose === 'function') onClose(); }} disabled={processing}>
          {cancelText}
        </Button>

        <Button
          onClick={handleConfirm}
          color="primary"
          variant="contained"
          autoFocus
          disabled={processing}
        >
          {confirmText}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

ConfirmationDialog.propTypes = {
  open: PropTypes.bool,
  onClose: PropTypes.func,
  onConfirm: PropTypes.func,
  title: PropTypes.string,
  message: PropTypes.string,
  confirmText: PropTypes.string,
  cancelText: PropTypes.string,
};

ConfirmationDialog.defaultProps = {
  open: false,
  onClose: () => {},
  onConfirm: null,
  title: 'Confirm',
  message: '',
  confirmText: 'Confirm',
  cancelText: 'Cancel',
};

export default React.memo(ConfirmationDialog);

```

`admin-dashboard/src/components/dashboard/BloodGroupChart.jsx`

```javascript
// src/components/dashboard/BloodGroupChart.jsx
import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
} from 'recharts';
import { Box, Typography, useTheme } from '@mui/material';

/**
 * A responsive bar chart to display blood group distribution.
 * Expects data shape: [{ blood_group: 'A+', count: 10 }, ...]
 */
const BloodGroupChart = ({ data }) => {
  const theme = useTheme();

  // Defensive: normalize/sort data so chart is stable
  const prepared = useMemo(() => {
    if (!Array.isArray(data)) return [];
    // ensure numeric counts and stable ordering (by blood_group)
    return [...data]
      .map((d) => ({ blood_group: d.blood_group ?? 'Unknown', count: Number(d.count) || 0 }))
      .sort((a, b) => {
        // you can sort by count desc: return b.count - a.count;
        // here we sort by blood_group for predictable axis order
        return a.blood_group.localeCompare(b.blood_group);
      });
  }, [data]);

  if (!prepared || prepared.length === 0) {
    return (
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: 300 }}>
        <Typography color="text.secondary">No chart data available.</Typography>
      </Box>
    );
  }

  return (
    // aria-label helps screen readers understand this visual
    <Box role="img" aria-label="Donor distribution by blood group">
      <ResponsiveContainer width="100%" height={300}>
        <BarChart
          data={prepared}
          margin={{ top: 6, right: 16, left: -12, bottom: 6 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke={theme.palette.divider} />
          <XAxis dataKey="blood_group" stroke={theme.palette.text.secondary} />
          <YAxis stroke={theme.palette.text.secondary} allowDecimals={false} />
          <Tooltip
            contentStyle={{
              backgroundColor: theme.palette.background.paper,
              borderColor: theme.palette.divider,
            }}
            formatter={(value) => [value, 'Donors']}
          />
          <Legend />
          <Bar dataKey="count" name="Total Donors" fill={theme.palette.primary.main} />
        </BarChart>
      </ResponsiveContainer>
    </Box>
  );
};

BloodGroupChart.propTypes = {
  data: PropTypes.arrayOf(
    PropTypes.shape({
      blood_group: PropTypes.string,
      count: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    })
  ),
};

BloodGroupChart.defaultProps = {
  data: [],
};

export default React.memo(BloodGroupChart);

```

`admin-dashboard/src/components/dashboard/StatCard.jsx`

```javascript
// src/components/dashboard/StatCard.jsx
import React from "react";
import PropTypes from "prop-types";
import { Paper, Box, Typography, Avatar, useTheme } from "@mui/material";

/**
 * A reusable component to display a single dashboard statistic.
 *
 * Props:
 * - icon: React node shown inside the Avatar
 * - title: short label for the stat
 * - value: numeric or string value to display
 * - color: theme token or CSS color for Avatar background (e.g. "primary.main")
 */
const StatCard = ({ icon, title, value, color = "primary.main" }) => {
  const theme = useTheme();

  // Resolve theme token like "primary.main" to an actual color string
  const resolvedColor = (() => {
    if (!color) return undefined;
    // if color contains a dot, treat as theme token
    if (typeof color === "string" && color.includes(".")) {
      const [paletteKey, shade] = color.split(".");
      return theme.palette?.[paletteKey]?.[shade] ?? color;
    }
    return color;
  })();

  // Format numbers nicely (1000 -> 1,000)
  const formattedValue =
    typeof value === "number"
      ? new Intl.NumberFormat().format(value)
      : value ?? "—";

  return (
    <Paper
      elevation={3}
      sx={{
        p: 2,
        display: "flex",
        alignItems: "center",
        height: "100%",
      }}
      role="region"
      aria-label={`${title} stat`}
      title={`${title}: ${formattedValue}`}
    >
      <Avatar
        sx={{
          bgcolor: resolvedColor,
          width: 56,
          height: 56,
          mr: 2,
          color: (theme.palette.getContrastText
            ? theme.palette.getContrastText(resolvedColor)
            : "#fff"),
        }}
        aria-hidden="true"
      >
        {icon}
      </Avatar>

      <Box sx={{ minWidth: 0 }}>
        <Typography color="text.secondary" noWrap variant="caption">
          {title}
        </Typography>
        <Typography variant="h5" component="div" fontWeight="bold" noWrap>
          {formattedValue}
        </Typography>
      </Box>
    </Paper>
  );
};

StatCard.propTypes = {
  icon: PropTypes.node,
  title: PropTypes.string.isRequired,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  color: PropTypes.string,
};

StatCard.defaultProps = {
  icon: null,
  value: "0",
  color: "primary.main",
};

export default React.memo(StatCard);

```

`admin-dashboard/src/context/AuthContext.jsx`

```javascript
// src/context/AuthContext.jsx
import React, { createContext, useState } from 'react';

// 1. Create the context
// This object will be used by other components to access the auth state.
export const AuthContext = createContext(null);

// 2. Create the Provider component
// This component will wrap our application and provide the auth state.
export const AuthProvider = ({ children }) => {
  // Initialize the token state by reading from localStorage.
  // This ensures that the user remains logged in even after a page refresh.
  const [token, setToken] = useState(localStorage.getItem('token'));

  // The login function saves the token to both localStorage and the state.
  const login = (newToken) => {
    localStorage.setItem('token', newToken);
    setToken(newToken);
  };

  // The logout function removes the token from localStorage and the state.
  const logout = () => {
    localStorage.removeItem('token');
    setToken(null);
  };

  // 3. Define the value to be provided by the context
  // We derive `isLoggedIn` directly from the presence of a token.
  const value = {
    token,
    isLoggedIn: !!token,
    login,
    logout,
  };

  // 4. Return the provider with the value, wrapping any child components.
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

```

`admin-dashboard/src/hooks/useAuth.js`

```javascript
// src/hooks/useAuth.js
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext.jsx';

/**
 * A custom hook for accessing the AuthContext.
 * This simplifies the process in any component that needs auth data,
 * as we can just call `useAuth()` instead of `useContext(AuthContext)`.
 */
export const useAuth = () => {
  return useContext(AuthContext);
};

```

`admin-dashboard/src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`admin-dashboard/src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom'; // <-- 1. IMPORT THE ROUTER
import App from './App.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    {/* 2. WRAP YOUR APP WITH THE ROUTER */}
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

```

`admin-dashboard/src/pages/Dashboard.jsx`

```javascript
// src/pages/Dashboard.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress, Button, Alert,
} from "@mui/material";
import {
  Bloodtype, LocationCity, AddLink, Close, Logout,
  PeopleAlt, Favorite, Healing, Warning,
} from "@mui/icons-material";

import { useAuth } from "../hooks/useAuth.js";
import apiClient from "../api/apiClient.js";
import StatCard from "../components/dashboard/StatCard.jsx";
import BloodGroupChart from "../components/dashboard/BloodGroupChart.jsx";
import ConfirmationDialog from "../components/common/ConfirmationDialog.jsx";

// --- Utility: Normalize API response into a clean array ---
const normalizeList = (res) => {
  if (!res) return [];
  if (Array.isArray(res)) return res;
  const d = res.data;
  if (Array.isArray(d)) return d;
  if (d && Array.isArray(d.data)) return d.data;
  if (d && typeof d === "object") {
    for (const k of Object.keys(d)) {
      if (Array.isArray(d[k])) return d[k];
    }
  }
  return [];
};

// --- Mock fallback data if API fails ---
const MOCK_STATS = { total_donors: 0, active_donors: 0, pending_patients: 0, patients_at_risk: 0 };
const MOCK_PATIENTS = [];
const MOCK_EMERGENCIES = [];
const MOCK_BLOOD_GROUPS = [];

// --- Tab Panel wrapper for accessibility ---
const TabPanel = ({ children, value, index }) => (
  <div role="tabpanel" hidden={value !== index}>
    {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
  </div>
);

const DashboardPage = () => {
  const { logout } = useAuth();
  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down("md"));

  // --- State ---
  const [tabValue, setTabValue] = useState(0);
  const [stats, setStats] = useState(null);
  const [patients, setPatients] = useState([]);
  const [emergencies, setEmergencies] = useState([]);
  const [bloodGroupData, setBloodGroupData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [dialog, setDialog] = useState({ open: false, title: "", message: "", onConfirm: null });

  // --- Fetch Dashboard Data from API ---
  const fetchDashboardData = useCallback(async () => {
    setLoading(true);
    setError("");
    try {
      const results = await Promise.allSettled([
        apiClient.get("/api/admin/stats"),
        apiClient.get("/api/admin/patients"),
        apiClient.get("/api/admin/emergencies"),
        apiClient.get("/api/admin/stats/blood-groups"),
      ]);

      const [statsRes, patientsRes, emergenciesRes, bloodGroupRes] = results;

      if (statsRes.status === "fulfilled") setStats(statsRes.value?.data ?? null);
      if (patientsRes.status === "fulfilled") setPatients(normalizeList(patientsRes.value));
      if (emergenciesRes.status === "fulfilled") setEmergencies(normalizeList(emergenciesRes.value));
      if (bloodGroupRes.status === "fulfilled") setBloodGroupData(bloodGroupRes.value?.data ?? []);

      // If everything failed -> use mock data
      const allRejected = results.every((r) => r.status === "rejected");
      if (allRejected) {
        setError("Failed to fetch dashboard data — using fallback mock data.");
        setStats(MOCK_STATS);
        setPatients(MOCK_PATIENTS);
        setEmergencies(MOCK_EMERGENCIES);
        setBloodGroupData(MOCK_BLOOD_GROUPS);
      }
    } catch (err) {
      console.error("Unexpected error in fetchDashboardData:", err);
      setError("Unexpected error. Using fallback.");
      setStats(MOCK_STATS);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchDashboardData();
  }, [fetchDashboardData]);

  // --- Tabs switch handler ---
  const handleTabChange = useCallback((_, newValue) => setTabValue(newValue), []);

  // --- Utility for API actions with refresh ---
  const executeApiAction = useCallback(async (action, successCallback, errorCallback) => {
    setError("");
    try {
      await action();
      if (successCallback) successCallback();
      await fetchDashboardData();
    } catch (err) {
      console.error("API Action Failed:", err);
      if (errorCallback) errorCallback(err);
      setError(err.response?.data?.message || "An error occurred. Please try again.");
    }
  }, [fetchDashboardData]);

  // --- Action Handlers with Confirmation Dialog ---
  const handleCreateBridge = useCallback((patientId, patientName) => {
    setDialog({
      open: true,
      title: "Confirm Bridge Creation",
      message: `Create a new Blood Bridge for "${patientName}"? This will update the patient's status.`,
      onConfirm: () => executeApiAction(() => apiClient.post(`/api/admin/patients/${patientId}/create-bridge`)),
    });
  }, [executeApiAction]);

  const handleCloseEmergency = useCallback((requestId, patientName) => {
    setDialog({
      open: true,
      title: "Confirm Close Request",
      message: `Close emergency request for "${patientName}"? This action cannot be undone.`,
      onConfirm: () => executeApiAction(() => apiClient.post(`/api/admin/emergencies/${requestId}/close`)),
    });
  }, [executeApiAction]);

  // --- Choose current tab data ---
  const activeData = useMemo(() => (tabValue === 0 ? patients : emergencies), [tabValue, patients, emergencies]);
  const dataKeyMap = useMemo(() => (
    tabValue === 0
      ? { name: "name", detail: "city", icon: <LocationCity /> }
      : { name: "patient_name", detail: "status", icon: null }
  ), [tabValue]);

  // --- Cards (for mobile view) ---
  const RenderCardGrid = ({ items }) => (
    <Box sx={{ display: "grid", gap: 2, gridTemplateColumns: { xs: "1fr", sm: "repeat(2, 1fr)", md: "repeat(3, 1fr)" } }}>
      {items.map((item) => (
        <Card key={item.id} variant="outlined" sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
          <CardContent sx={{ flexGrow: 1 }}>
            <Typography variant="h6" gutterBottom noWrap title={item[dataKeyMap.name] ?? ""}>
              {item[dataKeyMap.name] ?? "—"}
            </Typography>
            <Stack direction="column" spacing={1}>
              <Chip icon={<Bloodtype />} label={`Blood Group: ${item.blood_group ?? "N/A"}`} size="small" />
              <Chip icon={dataKeyMap.icon} label={`${dataKeyMap.detail}: ${item[dataKeyMap.detail] ?? "N/A"}`} size="small" />
            </Stack>
          </CardContent>
          <CardActions sx={{ justifyContent: "flex-end" }}>
            {tabValue === 0 ? (
              <Button variant="contained" size="small" startIcon={<AddLink />} onClick={() => handleCreateBridge(item.id, item.name)}>Create Bridge</Button>
            ) : (
              <Button variant="contained" color="secondary" size="small" startIcon={<Close />} onClick={() => handleCloseEmergency(item.id, item.patient_name)}>Close Request</Button>
            )}
          </CardActions>
        </Card>
      ))}
    </Box>
  );

  // --- Table (for desktop view) ---
  const RenderTable = ({ items }) => (
    <TableContainer component={Paper} variant="outlined">
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>Name</TableCell>
            <TableCell>{tabValue === 0 ? "City" : "Status"}</TableCell>
            <TableCell>Blood Group</TableCell>
            <TableCell align="right">Action</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {items.map((item) => (
            <TableRow key={item.id}>
              <TableCell>{item[dataKeyMap.name] ?? "—"}</TableCell>
              <TableCell>{item[dataKeyMap.detail] ?? "—"}</TableCell>
              <TableCell>{item.blood_group ?? "N/A"}</TableCell>
              <TableCell align="right">
                {tabValue === 0 ? (
                  <Button size="small" startIcon={<AddLink />} onClick={() => handleCreateBridge(item.id, item.name)}>Create Bridge</Button>
                ) : (
                  <Button size="small" color="secondary" startIcon={<Close />} onClick={() => handleCloseEmergency(item.id, item.patient_name)}>Close</Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );

  // --- Decide content rendering ---
  const renderContent = () => {
    if (loading && !stats) {
      return <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}><CircularProgress /></Box>;
    }
    if (!activeData || activeData.length === 0) {
      return <Typography sx={{ p: 3, textAlign: "center" }}>No data available for this view.</Typography>;
    }
    return isSmallScreen ? <RenderCardGrid items={activeData} /> : <RenderTable items={activeData} />;
  };

  return (
    <Box sx={{ flexGrow: 1, backgroundColor: theme.palette.background.default, minHeight: "100vh" }}>
      {/* --- Header --- */}
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>🩸 BloodBridge AI</Typography>
          <Button color="inherit" onClick={logout} startIcon={<Logout />}>Logout</Button>
        </Toolbar>
      </AppBar>

      {/* --- Body --- */}
      <Container sx={{ py: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>Admin Dashboard</Typography>

        {error && <Alert severity="warning" sx={{ mb: 2 }}>{error}</Alert>}

        {/* --- Stat Cards --- */}
        {stats && (
          <Box sx={{ display: "grid", gap: 3, mb: 4, gridTemplateColumns: { xs: "1fr", sm: "repeat(2, 1fr)", md: "repeat(4, 1fr)" } }}>
            <StatCard title="Total Donors" value={stats.total_donors ?? 0} icon={<PeopleAlt />} color="primary.main" />
            <StatCard title="Active Donors" value={stats.active_donors ?? 0} icon={<Favorite />} color="success.main" />
            <StatCard title="Pending Patients" value={stats.pending_patients ?? 0} icon={<Healing />} color="info.main" />
            <StatCard title="Patients at Risk" value={stats.patients_at_risk ?? 0} icon={<Warning />} color="error.main" />
          </Box>
        )}

        {/* --- Main Grid (Patients/Emergencies + Blood Groups Chart) --- */}
        <Box sx={{ display: "grid", gap: 3, gridTemplateColumns: { xs: "1fr", lg: "2fr 1fr" }, alignItems: "start" }}>
          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Box sx={{ borderBottom: 1, borderColor: "divider" }}>
              <Tabs value={tabValue} onChange={handleTabChange}>
                <Tab label="Patients" />
                <Tab label="Emergencies" />
              </Tabs>
            </Box>
            <TabPanel value={tabValue} index={0}>{renderContent()}</TabPanel>
            <TabPanel value={tabValue} index={1}>{renderContent()}</TabPanel>
          </Paper>

          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Typography variant="h6" gutterBottom>Donor Blood Groups</Typography>
            <Box sx={{ minHeight: 320 }}><BloodGroupChart data={bloodGroupData} /></Box>
          </Paper>
        </Box>
      </Container>

      {/* --- Confirmation Dialog --- */}
      <ConfirmationDialog
        open={dialog.open}
        onClose={() => setDialog({ ...dialog, open: false })}
        onConfirm={dialog.onConfirm}
        title={dialog.title}
        message={dialog.message}
      />
    </Box>
  );
};

export default DashboardPage;

```

`admin-dashboard/src/pages/LoginPage.jsx`

```javascript
// admin-dashboard/src/pages/LoginPage.jsx
import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert, CircularProgress } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth.js';
import apiClient from '../api/apiClient.js';

const LoginPage = () => {
  const { login } = useAuth();
  const navigate = useNavigate();

  const [phone, setPhone] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleLogin = async (event) => {
    event.preventDefault();
    setError('');

    // Validate phone number
    if (!/^\+91\d{10}$/.test(phone)) {
      setError('Please enter a valid phone number with +91 (e.g., +918000000000).');
      return;
    }

    setLoading(true);
    try {
      console.log('Attempting login with:', { phone, password });

      const response = await apiClient.post('/api/admin/login', { phone, password });

      if (response.data?.token) {
        console.log('Login successful, token:', response.data.token);
        localStorage.setItem('token', response.data.token);
        login(response.data.token);
        navigate('/dashboard');
      } else {
        setError('Login failed: No token received from server.');
      }
    } catch (err) {
      console.error('Login error:', {
        message: err.message,
        status: err.response?.status,
        data: err.response?.data,
      });

      if (err.code === 'ECONNABORTED') {
        setError('Request timed out. Is the backend running on http://localhost:3001?');
      } else if (err.response?.status === 401) {
        setError('Invalid phone number or password.');
      } else if (err.response?.status === 500) {
        setError('Server error. Check backend logs for details.');
      } else {
        setError(err.response?.data?.message || 'Network error. Please try again.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box sx={{ mt: 8, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Typography component="h1" variant="h5">
          🩸 BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleLogin} sx={{ mt: 3 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="phone"
            label="Phone Number"
            name="phone"
            autoComplete="tel"
            autoFocus
            placeholder="+918000000000"
            value={phone}
            onChange={(e) => setPhone(e.target.value)}
          />
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="current-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {error && <Alert severity="error" sx={{ mt: 2, width: '100%' }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            disabled={loading}
            sx={{ mt: 3, mb: 2 }}
          >
            {loading ? (
              <>
                <CircularProgress size={24} color="inherit" sx={{ mr: 1 }} />
                Signing In...
              </>
            ) : 'Sign In'}
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;

```

`admin-dashboard/src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`admin-dashboard/vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

`backend/.env`

```
# backend/.env

# Server Configuration
PORT=3001

# --- SECURITY ---
# IMPORTANT: Replace this with a long, random, and secret string!
# You can generate one at https://www.uuidgenerator.net/
JWT_SECRET="eb4db4a414678902613083784a04ec9de45570856d8ced1dbe6fdd4a545ff715"

# --- DATABASE ---
# Get this from your Supabase project settings (Database -> Connection string -> URI)
DATABASE_URL="postgresql://postgres:asdfusahdfuu3842r7gdsfh@db.psussvygzgzkkwdjqbwp.supabase.co:5432/postgres"

# --- THIRD-PARTY APIs ---
GEMINI_API_KEY="AIzaSyAqhJPcovJUpv6M9u_jRTefTQ7VvwuPCm0"
ML_SERVICE_URL="http://localhost:8000" # URL for the Python ML service we will build later

# --- WHATSAPP (for later) ---
WHATSAPP_TOKEN="EAAY5EGe8MHkBPRCH1W6vrdF1MRvIDnP4IfzaVyGDWm7mHOaWKUJfWfBjjj4B2jrZCSudfSvxDdT8rBquvSYoDwZCxQxgKgzktlJyzGWwXSiHaSKene42wkVRWC2TA1FZCrR2ehAHCB6tgnZCmYDpBPJ4zzXSnM5Qh4z8c91ZCVZC96n6uLZBDhGRFfNKHLMZBYWiWYudt2oGGdbl3fRgi3c6WoDKNehuTrx1GPZCgMT3MDABS"
WHATSAPP_PHONE_NUMBER_ID="729824143554882"
WHATSAPP_APP_SECRET="e94bd0c1a5619ee68b105222b0185dc6"
WHATSAPP_VERIFY_TOKEN="inquilab_bloodai-123-2025-hackathon"

# --- DEMO & ADMIN ---
ADMIN_DEMO_PHONE="+918000000000"
DEMO_VERIFIED_PHONE_NUMBERS=""

```

`backend/server.js`

```javascript

// backend/server.js

// Import required dependencies
import express from 'express'; // Express framework for building the server
import cors from 'cors'; // Middleware for enabling CORS
import morgan from 'morgan'; // Middleware for request logging
import config from './src/config/config.js'; // Configuration settings (e.g., WHATSAPP_TOKEN)
import adminRoutes from './src/routes/adminRoutes.js'; // Admin dashboard routes
import { verifyWebhook } from './src/middleware/verifyWebhook.js'; // Webhook signature verification middleware (named import)
import webhookController from './src/controllers/webhookController.js'; // Webhook handling controller

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3001; // Use environment PORT or default to 3001

// Middleware setup
app.use(cors()); // Enable CORS for all routes
app.use(morgan('tiny')); // Log HTTP requests in 'tiny' format

// Note: No global body parser; using per-route body parsing for security and compatibility

// API and Health Routes
app.get('/health', (req, res) => {
  // Health check endpoint to verify server status
  res.status(200).json({ status: 'healthy', now: new Date().toISOString() });
});

// Admin routes with JSON body parser
app.use('/api/admin', express.json({ limit: '1mb' }), adminRoutes);

// Webhook Routes
app.get('/webhook', webhookController.verifyToken); // Handle Meta webhook verification (GET)

app.post(
  '/webhook',
  express.raw({ type: 'application/json' }), // Parse webhook body as raw Buffer for signature verification
  (req, res, next) => {
    // Store raw body buffer for verifyWebhook middleware
    req.rawBodyBuffer = req.body;
    next();
  },
  verifyWebhook, // Verify webhook signature for POST requests
  webhookController.handleMessage // Process incoming WhatsApp messages
);

// Global Error Handling
app.use((err, req, res, next) => {
  // Handle errors from middleware or routes
  console.error('[ERROR HANDLER]', err.stack);
  res.status(500).json({ message: 'An internal server error occurred.' });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason) => {
  console.error('Unhandled Rejection:', reason);
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
});

// Start the server
app.listen(PORT, () => {
  console.log(`✅ BloodBridge AI backend is running on port ${PORT}`);
});

```

`backend/src/config/config.js`

```javascript
// backend/src/config/config.js
import 'dotenv/config'; // Loads variables from .env into process.env

// This object maps environment variables to a clean, accessible config object.
const config = {
    port: process.env.PORT,
    jwtSecret: process.env.JWT_SECRET,
    databaseUrl: process.env.DATABASE_URL,
    geminiApiKey: process.env.GEMINI_API_KEY,
    mlServiceUrl: process.env.ML_SERVICE_URL,
    whatsappToken: process.env.WHATSAPP_TOKEN,
    whatsappPhoneNumberId: process.env.WHATSAPP_PHONE_NUMBER_ID,
    whatsappAppSecret: process.env.WHATSAPP_APP_SECRET,
    whatsappVerifyToken: process.env.WHATSAPP_VERIFY_TOKEN,
    adminDemoPhone: process.env.ADMIN_DEMO_PHONE,
    demoVerifiedPhoneNumbers: process.env.DEMO_VERIFIED_PHONE_NUMBERS
};

// This validation step ensures the application fails fast if critical secrets are missing.
// It's a crucial security and stability feature.
const requiredConfig = ['port', 'jwtSecret', 'databaseUrl'];
const missingConfig = requiredConfig.filter(key => !config[key]);

if (missingConfig.length > 0) {
    console.error(`🔴 FATAL ERROR: Missing required environment variables: ${missingConfig.join(', ')}`);
    // Exit the application with an error code.
    process.exit(1);
}

export default config;

```

`backend/src/config/db.js`

```javascript
// backend/src/config/db.js
import { Pool } from 'pg';
import config from './config.js';

/**
 * Creates a new connection pool.
 * The pool manages multiple client connections to the database,
 * reusing them to improve performance and stability.
 */
const pool = new Pool({
  connectionString: config.databaseUrl,
});

/**
 * A helper function to execute a simple query.
 * @param {string} text - The SQL query string.
 * @param {Array} params - The parameters to pass to the query.
 * @returns {Promise<QueryResult>} The result from the database.
 */
const query = (text, params) => pool.query(text, params);

// We export the entire pool so we can use it for transactions later,
// and the query function for convenience.
const db = {
  query,
  pool,
};

export default db;

```

`backend/src/controllers/adminController.js`

```javascript
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import db from '../config/db.js';
import bridgeService from '../services/bridgeService.js';

/**
 * Admin Login
 */
export const login = async (req, res) => {
  const { phone, password } = req.body;

  if (!phone || !password) {
    console.warn('Login attempt with missing credentials:', { phone, password });
    return res.status(400).json({ message: 'Phone and password are required' });
  }

  try {
    // Demo admin login (for prototype)
    if (phone === config.adminDemoPhone && password === 'admin123') {
      const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '1h' });
      console.log(`Login successful for demo admin: ${phone}`);
      return res.json({ token });
    }

    // Check if admin exists in DB
    const { rows } = await db.query(
      'SELECT * FROM users WHERE phone = $1 AND role = $2',
      [phone, 'Admin']
    );

    if (rows.length === 0) {
      console.warn('Login failed: No admin user found for phone:', phone);
      return res.status(401).json({ message: 'Invalid phone number or role' });
    }

    // Password check (⚠️ Plaintext for now, should be hashed in production)
    if (!rows[0].password || rows[0].password !== password) {
      console.warn('Login failed: Invalid password for phone:', phone);
      return res.status(401).json({ message: 'Invalid password' });
    }

    // Issue token
    const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
    console.log(`Login successful for user: ${phone}`);
    return res.json({ token });

  } catch (err) {
    console.error('Login error:', { error: err.message, phone });
    return res.status(500).json({ message: 'Server error during login' });
  }
};


/**
 * Create a Blood Bridge for a Patient
 */
export const createBridgeForPatient = async (req, res) => {
  const { patientId } = req.params;

  try {
    const { rows: [patient] } = await db.query(
      'SELECT * FROM patients WHERE id = $1',
      [patientId]
    );

    if (!patient) {
      return res.status(404).json({ message: 'Patient not found' });
    }

    if (patient.status === 'bridged') {
      return res.status(400).json({ message: 'Patient already has a bridge.' });
    }

    // Insert new bridge
    const { rows: [bridge] } = await db.query(
      'INSERT INTO blood_bridges (patient_id, name, blood_group, city) VALUES ($1, $2, $3, $4) RETURNING id',
      [patient.id, `${patient.name}'s Bridge`, patient.blood_group, patient.city]
    );

    // Populate bridge with donors
    const result = await bridgeService.populateNewBridge(
      bridge.id,
      patient.city,
      patient.blood_group,
      patient.pincode
    );

    // Update patient status
    await db.query(
      "UPDATE patients SET status = 'bridged' WHERE id = $1",
      [patientId]
    );

    console.log(`ADMIN ACTION: Created and populated Bridge ${bridge.id} with ${result.count} members.`);
    res.json({
      success: true,
      message: `Blood Bridge created and populated with ${result.count} top donors.`
    });

  } catch (error) {
    console.error('Error creating bridge for patient:', error);

    // Rollback patient status in case of failure
    await db.query(
      "UPDATE patients SET status = 'pending_verification' WHERE id = $1",
      [patientId]
    );

    res.status(500).json({ error: 'Failed to create and populate bridge.' });
  }
};


/**
 * Close Emergency Request
 */
export const closeEmergency = async (req, res) => {
  const { requestId } = req.params;

  try {
    await db.query(
      "UPDATE emergency_requests SET status = 'closed' WHERE id = $1",
      [requestId]
    );
    console.log(`ADMIN ACTION: Closed emergency request ${requestId}`);
    res.json({ success: true, message: 'Request successfully closed.' });
  } catch (error) {
    console.error(`Error closing emergency ${requestId}:`, error);
    res.status(500).json({ error: 'Failed to close request.' });
  }
};


/**
 * Escalate Emergency
 */
export const escalateEmergency = async (req, res) => {
  const { requestId } = req.params;
  console.log(`ADMIN ACTION: Escalating emergency ${requestId}`);
  res.json({
    success: true,
    message: `Escalation for request ${requestId} has been initiated.`
  });
};


/**
 * Resolve Inbox Message
 */
export const resolveInboxMessage = async (req, res) => {
  const { requestId } = req.params;

  try {
    await db.query(
      "UPDATE inbox_messages SET status = 'resolved', resolved_at = NOW() WHERE id = $1",
      [requestId]
    );
    console.log(`ADMIN ACTION: Resolved inbox message ${requestId}`);
    res.json({ success: true, message: 'Message marked as resolved.' });
  } catch (error) {
    console.error(`Error resolving message ${requestId}:`, error);
    res.status(500).json({ error: 'Failed to resolve message.' });
  }
};


// 📝 Other endpoints remain unchanged
export const getDashboardStats = async (req, res) => { /* ... */ };
export const getBloodGroupStats = async (req, res) => { /* ... */ };
export const getConfig = async (req, res) => { /* ... */ };
export const getActiveEmergencies = async (req, res) => { /* ... */ };
export const getBloodBridges = async (req, res) => { /* ... */ };
export const getPatients = async (req, res) => { /* ... */ };
export const getInboxMessages = async (req, res) => { /* ... */ };


```

`backend/src/controllers/webhookController.js`

```javascript

// backend/src/controllers/webhookController.js

// Import required dependencies
import config from '../config/config.js'; // Configuration settings (e.g., WHATSAPP_VERIFY_TOKEN)
import db from '../config/db.js'; // Database connection
import emergencyService from '../services/emergencyService.js'; // Emergency request handling service
import registrationService from '../services/registrationService.js'; // Donor registration service
import responseService from '../services/responseService.js'; // Donor response and OTP verification service
import patientService from '../services/patientService.js'; // Patient onboarding service
import donorPreferenceService from '../services/donorPreferenceService.js'; // Donor preferences (e.g., snooze, DND)
import aiRouterService from '../services/aiRouterService.js'; // AI message routing service
import faqService from '../services/faqService.js'; // FAQ handling service
import { normalizePhoneNumber } from '../utils/phoneHelper.js'; // Phone number normalization utility

// Handle GET requests for Meta webhook verification
const verifyToken = (req, res) => {
  // Extract query parameters for verification
  const mode = req.query['hub.mode']; // Expected: 'subscribe'
  const token = req.query['hub.verify_token']; // Token from Meta dashboard
  const challenge = req.query['hub.challenge']; // Challenge to return

  // Check if mode and token are valid and match configuration
  if (mode === 'subscribe' && token === config.whatsappVerifyToken) {
    console.log('✅ Webhook verified successfully:', { challenge }); // Log success
    return res.status(200).send(challenge); // Return challenge to confirm verification
  }

  // Log and reject invalid verification attempts
  console.warn('Webhook verification failed:', { mode, token });
  res.status(403).send('Verification failed');
};

// Process incoming WhatsApp message
const processMessage = async (messageData) => {
  // Ensure message is text type
  if (messageData.type !== 'text') {
    console.warn('Non-text message received:', messageData.type);
    return;
  }

  // Normalize sender's phone number
  const from = normalizePhoneNumber(messageData.from);
  // Get message body and lowercase for pattern matching
  const userMessage = messageData.text.body.trim();
  const lowerUserMessage = userMessage.toLowerCase();

  // Log incoming message for debugging
  console.log(`--- New Message --- From: ${from}, Message: "${userMessage}"`);

  // Handle ongoing patient onboarding first (high priority)
  const wasHandledByOnboarding = await patientService.processOnboardingReply(userMessage, from);
  if (wasHandledByOnboarding) {
    console.log('Message handled by patient onboarding');
    return; // Exit if onboarding handled the message
  }

  // Keyword-based routing for specific commands
  if (lowerUserMessage === 'apply') {
    // Start patient application
    const started = await patientService.startApplication(from);
    if (started) {
      console.log('Started patient application for:', from);
      return;
    }
  }

  // Check for 6-digit OTP (e.g., 123456)
  const otpPattern = /^\d{6}$/;
  if (otpPattern.test(userMessage)) {
    await responseService.verifyOTPAndConfirm(from, userMessage);
    console.log('Processed OTP for:', from);
    return;
  }

  // Check for donor response with short code (e.g., "YES 1234")
  const responsePatternWithCode = /^(?:'|")?\s*(YES)\s+(\d{4})\s*(?:'|")?$/i;
  const matchWithCode = userMessage.match(responsePatternWithCode);
  if (matchWithCode) {
    await responseService.handleDonorReplyWithShortCode(from, matchWithCode[2]);
    console.log('Processed donor response with code:', matchWithCode[2]);
    return;
  }

  // Handle emergency requests (e.g., "emergency blood")
  const emergencyPattern = /\b(emergency|urgent|need)\b.*?\b(blood)\b/i;
  if (emergencyPattern.test(lowerUserMessage)) {
    await emergencyService.handleEmergencyRequest(userMessage, from);
    console.log('Processed emergency request from:', from);
    return;
  }

  // Handle patient onboarding (e.g., "thalassemia support")
  const patientOnboardingPattern = /\b(thalassemia|patient|support|child|onboard)\b/i;
  if (patientOnboardingPattern.test(lowerUserMessage)) {
    await patientService.handleNewPatient(userMessage, from);
    console.log('Processed new patient request from:', from);
    return;
  }

  // Handle donor registration with details (e.g., "Register: John, Delhi, A+")
  const detailedRegPattern = /^Register:/i;
  if (detailedRegPattern.test(userMessage)) {
    const paramsStr = userMessage.substring(userMessage.indexOf(':') + 1).trim();
    const paramsArr = paramsStr.split(',').map(p => p.trim());
    if (paramsArr.length === 3) {
      const params = { name: paramsArr[0], city: paramsArr[1], blood_group: paramsArr[2] };
      await registrationService.handleNewDonor(params, from);
      console.log('Processed donor registration for:', from);
      return;
    }
  }

  // Handle simple registration trigger (e.g., "donate")
  const simpleRegPattern = /\b(donate|register|join)\b/i;
  if (simpleRegPattern.test(lowerUserMessage)) {
    await registrationService.handleNewDonor({}, from);
    console.log('Triggered donor registration flow for:', from);
    return;
  }

  // Fallback to AI router for unhandled messages
  console.log('No keyword match, routing to AI for:', from);
  const { rows: [user] } = await db.query('SELECT role FROM users WHERE phone = $1', [from]);
  const userRole = user ? user.role : 'Unregistered';
  const route = await aiRouterService.routeMessageWithContext(userMessage, userRole);

  // Process AI-determined route
  if (route && route.tool) {
    switch (route.tool) {
      case 'handle_snooze_request':
        await donorPreferenceService.handleSnooze(from, route.params);
        console.log('Processed snooze request for:', from);
        break;
      case 'handle_dnd_request':
        await donorPreferenceService.handleDnd(from);
        console.log('Processed DND request for:', from);
        break;
      default:
        await faqService.handleFaq(route.params?.query || userMessage, from);
        console.log('Processed FAQ for:', from);
        break;
    }
    return;
  }

  // Final fallback to general FAQ if AI route is unclear
  console.log('AI route unclear, fallback to FAQ for:', from);
  await faqService.handleFaq(userMessage, from);
};

// Handle POST requests for WhatsApp messages
const handleMessage = async (req, res) => {
  // Send immediate 200 response to acknowledge receipt (Meta requirement)
  res.sendStatus(200);

  try {
    // Extract message from webhook payload
    const messageData = req.body.entry?.[0]?.changes?.[0]?.value?.messages?.[0];
    if (!messageData) {
      console.warn('No valid message data in webhook payload:', req.body);
      return;
    }

    // Check for duplicate messages to prevent reprocessing
    const { rows } = await db.query('SELECT 1 FROM processed_messages WHERE message_id = $1', [messageData.id]);
    if (rows.length > 0) {
      console.warn('Duplicate message ignored:', messageData.id);
      return;
    }

    // Record message ID to prevent duplicates
    await db.query('INSERT INTO processed_messages(message_id) VALUES($1)', [messageData.id]);

    // Process the message
    await processMessage(messageData);
  } catch (error) {
    // Log critical errors but don't crash the server
    console.error('CRITICAL ERROR in handleMessage:', {
      message: error.message,
      stack: error.stack,
    });
  }
};

// Export controller functions
export default {
  verifyToken,
  handleMessage,
};

```

`backend/src/middleware/authMiddleware.js`

```javascript
// backend/src/middleware/authMiddleware.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';

// ✅ The function must be declared as a constant named 'authMiddleware'
const authMiddleware = (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authorization token is missing or malformed' });
  }

  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, config.jwtSecret);
    req.user = decoded;
    next();
  } catch (error) {
    console.error("JWT Verification Error:", error.message);
    return res.status(401).json({ message: 'Invalid or expired token' });
  }
};

// ✅ This line then exports that constant
export default authMiddleware;

```

`backend/src/middleware/checkRole.js`

```javascript
// backend/src/middleware/checkRole.js

const checkRole = (roles) => {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: 'Forbidden: No role assigned' });
    }
    const userRole = req.user.role;
    if (roles.includes(userRole)) {
      return next();
    }
    return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
  };
};

export default checkRole; // <-- CORRECTED LINE

```

`backend/src/middleware/verifyWebhook.js`

```javascript
// backend/src/middleware/verifyWebhook.js
import crypto from 'crypto';
import config from '../config/config.js';

/**
 * Middleware to verify WhatsApp webhook POST requests.
 * - Skips signature verification for GET (used by Meta for challenge verification).
 * - Validates signature for POST requests to ensure authenticity.
 */
export const verifyWebhook = (req, res, next) => {
  // ✅ Allow GET requests (Meta verification step)
  if (req.method === 'GET') {
    return next();
  }

  // ✅ Get signature from header
  const signature = req.headers['x-hub-signature-256'];
  if (!signature) {
    console.warn('Signature missing for POST webhook');
    return res.status(401).json({ message: 'Signature missing' });
  }

  // ✅ Create HMAC from request body
  const body = JSON.stringify(req.body);
  const hmac = crypto.createHmac('sha256', config.whatsappAppSecret);
  hmac.update(body);
  const expectedSignature = `sha256=${hmac.digest('hex')}`;

  // ✅ Compare provided signature with expected signature
  if (signature !== expectedSignature) {
    console.warn('Signature mismatch for POST webhook');
    return res.status(401).json({ message: 'Invalid signature' });
  }

  // ✅ Proceed if valid
  next();
};

```

`backend/src/routes/adminRoutes.js`

```javascript
// backend/src/routes/adminRoutes.js
import express from 'express';
import * as adminController from '../controllers/adminController.js';
import authMiddleware from '../middleware/authMiddleware.js';
import checkRole from '../middleware/checkRole.js';

const router = express.Router();

// Public (no auth needed)
router.post('/login', adminController.login);

// All routes below this require auth
router.use(authMiddleware);

// ✅ UNCOMMENTED to make all GET endpoints live
router.get('/config', checkRole(['Admin']), adminController.getConfig);
router.get('/stats', checkRole(['Admin']), adminController.getDashboardStats);
router.get('/stats/blood-groups', checkRole(['Admin']), adminController.getBloodGroupStats);
router.get('/patients', checkRole(['Admin']), adminController.getPatients);
router.get('/emergencies', checkRole(['Admin']), adminController.getActiveEmergencies);
router.get('/bridges', checkRole(['Admin']), adminController.getBloodBridges);
router.get('/inbox', checkRole(['Admin']), adminController.getInboxMessages);

// Actions
router.post('/patients/:patientId/create-bridge', checkRole(['Admin']), adminController.createBridgeForPatient);
router.post('/emergencies/:requestId/close', checkRole(['Admin']), adminController.closeEmergency);
router.post('/emergencies/:requestId/escalate', checkRole(['Admin']), adminController.escalateEmergency);
router.post('/inbox/:messageId/resolve', checkRole(['Admin']), adminController.resolveInboxMessage);

export default router;

```

`backend/src/services/aiRouterService.js`

```javascript
// backend/src/services/aiRouterService.js
import { GoogleGenerativeAI } from '@google/generative-ai';
import { TOOL_DEFINITIONS } from './aiTools.js';
import config from '../config/config.js';

/**
 * This service acts as the central "brain" for the chatbot.
 * It takes a user's message and uses the Gemini AI with function-calling
 * to determine the user's intent and extract relevant information.
 */
class AIRouterService {
  constructor() {
    if (!config.geminiApiKey) {
      throw new Error("GEMINI_API_KEY is not set in the environment variables."); //
    }
    this.genAI = new GoogleGenerativeAI(config.geminiApiKey); //
    this.model = this.genAI.getGenerativeModel({
      model: 'gemini-1.5-flash-latest',
      tools: { functionDeclarations: TOOL_DEFINITIONS } //
    });
  }

  /**
   * Routes a user's message to the appropriate tool using the AI model.
   * @param {string} userMessage - The message from the user.
   * @param {string} userRole - The role of the user (e.g., 'Admin', 'Unregistered').
   * @returns {Promise<{tool: string, params: object}|null>} The decided tool and its parameters, or null if no tool is called.
   */
  async routeMessageWithContext(userMessage, userRole) {
    const systemPrompt = `You are "Bridge AI" 🌉, an operational AI assistant. Your primary goal is to understand the user's message and call the appropriate function. The user's role is "${userRole}". Prioritize action-oriented tasks.`; //
    
    const chatHistory = [
        { role: "user", parts: [{ text: systemPrompt }] },
        { role: "model", parts: [{ text: "Understood. Ready to assist." }] }, //
    ];
    
    try {
      const chat = this.model.startChat({ history: chatHistory }); //
      const result = await chat.sendMessage(userMessage); //
      const call = result.response.functionCalls()?.[0];
      
      if (call) {
        console.log(`AI decided to call tool: ${call.name} with params:`, call.args);
        return { tool: call.name, params: call.args }; //
      }
      console.log("AI did not call a specific tool for this message.");
      return null;

    } catch (error) {
      console.error('Error routing message with Gemini:', error.message); //
      return null;
    }
  }
}

// Export a single instance of the class
export default new AIRouterService();

```

`backend/src/services/aiTools.js`

```javascript
// backend/src/services/aiTools.js

/**
 * TOOL_DEFINITIONS is a manifest of functions the Gemini AI can call.
 * The descriptions are critical, as they tell the AI *when* to use each tool.
 */
export const TOOL_DEFINITIONS = [
  {
    name: 'handle_emergency_request',
    description: `Use for any urgent blood request. The Blood Warriors Foundation specializes in rapid response, especially for Thalassemia patients, leveraging our network of over 4,443 registered donors. Emergencies for Thalassemia patients should be given the highest priority as they are central to our mission.`, //
    parameters: {
      type: 'object',
      properties: {
        patient_name: { type: 'string', description: 'Name of the patient needing blood. If not mentioned, use "Unknown".' }, //
        blood_group: { type: 'string', description: 'The blood group needed, like A+, O-, AB+.' }, //
        units_needed: { type: 'integer', description: 'The number of units of blood required. Default to 1.' }, //
        hospital_name: { type: 'string', description: 'The name of the hospital. We have partnerships with over 50 hospitals.' }, //
        city: { type: 'string', description: 'The city where the hospital is located. Our strongest presence is in Hyderabad.' } //
      },
      required: ['blood_group', 'city']
    }
  },
  {
    name: 'handle_donor_registration',
    description: `This is the primary tool for onboarding new users and is a TOP PRIORITY. Use this for ANY message where the user expresses the INTENT or GOAL of becoming a blood donor. This is the correct tool for phrases like "I want to donate blood", "register me as a donor", "I want to be a blood warrior", "sign me up", "how can I donate?", or "I want to register". If the user provides details, capture them. If not, the function will ask for them.`, //
    parameters: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Full name of the new Blood Warrior. Default to "Unknown" if not provided.' }, //
        blood_group: { type: 'string', description: 'The blood group of the person. Default to "Unknown" if not provided.' }, //
        city: { type: 'string', description: 'The city where the donor lives. Default to "Unknown" if not provided.' } //
      },
      required: []
    }
  },
  {
    name: 'check_gamification_status',
    description: `Use when a registered donor asks about their personal status, points, or donation history. Frame the response with encouragement, acknowledging their part in our community of heroes.`, //
    parameters: {
        type: 'object',
        properties: {
            status_type: { type: 'string', enum: ['points', 'rank', 'badges', 'all'], description: 'The specific status the user is asking for.' } //
        },
        required: ['status_type']
    }
  },
  // We can add the other tools like handle_patient_onboarding, etc., here later.
];

```

`backend/src/services/bridgeService.js`

```javascript
import db from '../config/db.js';

class BridgeService {
  async populateNewBridge(bridgeId, city, bloodGroup, pincode) {
    try {
      console.log(`Populating bridge ${bridgeId} for city: ${city}, blood group: ${bloodGroup}, pincode: ${pincode}`);
      const { rows: bestDonors } = await db.query(
        'SELECT donor_id, final_score FROM find_donors_for_bridge($1, $2, $3, $4)',
        [city, bloodGroup, pincode, 5]
      );
      if (!bestDonors || bestDonors.length === 0) {
        console.warn(`No donors found for bridge ${bridgeId} with city: ${city}, blood group: ${bloodGroup}, pincode: ${pincode}`);
        return { success: true, count: 0 };
      }
      const insertQueries = bestDonors.map((donor, index) =>
        db.query(
          'INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, $3)',
          [bridgeId, donor.donor_id, index + 1]
        )
      );
      await Promise.all(insertQueries);
      console.log(`Successfully populated bridge ${bridgeId} with ${bestDonors.length} donors`);
      return { success: true, count: bestDonors.length };
    } catch (error) {
      console.error(`Error populating bridge ${bridgeId}:`, {
        error: error.message,
        city,
        bloodGroup,
        pincode,
      });
      throw new Error(`Failed to populate bridge: ${error.message}`);
    }
  }
}

export default new BridgeService();

```

`backend/src/services/donorPreferenceService.js`

```javascript
// backend/src/services/donorPreferenceService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class DonorPreferenceService {
  /**
   * Sets a snooze period for a donor, pausing notifications.
   * @param {string} phone - The donor's phone number.
   * @param {object} params - Parameters from the AI, e.g., { duration: 1, unit: 'week' }.
   */
  async handleSnooze(phone, params) {
    const { duration = 15, unit = 'day' } = params; // Default to 15 days if AI provides no params
    
    try {
      const interval = `${duration} ${unit}`;
      const { rows: [user] } = await db.query(
        "UPDATE users SET snooze_until = NOW() + $1::interval WHERE phone = $2 RETURNING snooze_until",
        [interval, phone]
      );

      if (user && user.snooze_until) {
        const snoozeDate = new Date(user.snooze_until).toLocaleDateString('en-IN');
        const message = `Got it. I've paused all non-critical notifications for you until ${snoozeDate}. We'll reach out again after that. Thank you for being a donor!`;
        await whatsappService.sendTextMessage(phone, message);
      }
    } catch (error) {
      console.error(`Error setting snooze for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while setting your preferences.");
    }
  }

  /**
   * Sets the Do Not Disturb (DND) status for a donor, permanently stopping notifications.
   * @param {string} phone - The donor's phone number.
   */
  async handleDnd(phone) {
    try {
      await db.query(
        "UPDATE users SET dnd_status = true, availability_status = 'unavailable' WHERE phone = $1",
        [phone]
      );
      const message = "You have been unsubscribed from all future notifications. We're sad to see you go, but we respect your decision. If you ever change your mind, just send 'Register' to sign up again.";
      await whatsappService.sendTextMessage(phone, message);
    } catch (error) {
      console.error(`Error setting DND for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while updating your DND status.");
    }
  }
}

export default new DonorPreferenceService();

```

`backend/src/services/emergencyService.js`

```javascript
// backend/src/services/emergencyService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import aiRouterService from './aiRouterService.js';
import mlService from './mlService.js';
import geocodingService from './geocodingService.js';
import { getDistanceInKm } from '../utils/distanceHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class EmergencyService {
  async handleEmergencyRequest(userMessage, requesterPhone) {
    let params = {};
    const sanitizedPhone = normalizePhoneNumber(requesterPhone);

    const bloodGroupRegex = /\b([ABO]{1,2}\s*[\+-])\b/i;
    const cityRegex = /\b(hyderabad|mumbai|delhi|bangalore|chennai)\b/i;

    const bloodGroupMatch = userMessage.match(bloodGroupRegex);
    const cityMatch = userMessage.match(cityRegex);

    if (bloodGroupMatch && cityMatch) {
      console.log("Regex successfully extracted critical details.");
      params.blood_group = normalizeBloodGroup(bloodGroupMatch[0]);
      params.city = cityMatch[0].charAt(0).toUpperCase() + cityMatch[0].slice(1);
    } else {
      console.log("Regex failed. Engaging AI for detail extraction...");
      const route = await aiRouterService.routeMessageWithContext(userMessage, 'Unregistered');
      if (route && route.tool === 'handle_emergency_request' && route.params.blood_group && route.params.city) {
        console.log("AI successfully extracted details.");
        params = route.params;
      } else {
        console.log('AI also failed. Prompting user and setting conversation state.');
        await db.query(`
          UPDATE users SET conversation_state = 'awaiting_emergency_details'
          WHERE phone = $1;
        `, [sanitizedPhone]);
        const followupMessage = "I understand this is an emergency. To find a donor, please provide the patient's blood group and the city where the hospital is located.";
        await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);
        return;
      }
    }
    await this.createEmergencyRequest(params, sanitizedPhone);
  }

  async createEmergencyRequest(params, requesterPhone) {
    const { patient_name = 'Unknown', blood_group, city, hospital_name = 'Unknown' } = params;
    try {
      const coords = await geocodingService.getCoords(hospital_name, city, null);
      const shortCode = Math.floor(1000 + Math.random() * 9000).toString();
      const { rows: [request] } = await db.query(
        `INSERT INTO emergency_requests (patient_name, blood_group, city, hospital_name, requested_by_phone, short_code, latitude, longitude)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *;`,
        [patient_name, normalizeBloodGroup(blood_group), city, hospital_name, requesterPhone, shortCode, coords?.latitude, coords?.longitude]
      );
      
      console.log(`Successfully created emergency request ID: ${request.id}`);
      await whatsappService.sendTextMessage(requesterPhone, `✅ Emergency request active! We are now running a hyperlocal search for the best donor for *${patient_name}*.`);
      
      this.findAndNotifyDonors(request);

    } catch (error) {
      console.error('Error creating emergency request:', error);
      await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }

  /**
   * Finds potential donors, ranks them using the ML service, and notifies the best match.
   */
  async findAndNotifyDonors(request) {
    const { id: requestId, blood_group, city, requested_by_phone, latitude: hospitalLat, longitude: hospitalLon } = request;
    
    let topScoredDonors = await this.findAndRankGeneralDonors(blood_group, city, []);

    if (topScoredDonors.length === 0) {
      await whatsappService.sendTextMessage(requested_by_phone, '⚠️ We searched our network but could not find any available donors at this moment.');
      return;
    }

    if (hospitalLat && hospitalLon) {
        topScoredDonors.forEach(donor => {
            donor.distance = donor.latitude ? getDistanceInKm(hospitalLat, hospitalLon, donor.latitude, donor.longitude) : Infinity;
        });
        topScoredDonors.sort((a, b) => a.distance - b.distance);
    }

    const bestDonor = topScoredDonors[0];
    const notificationMessage = `🚨 URGENT: You are a top-ranked match!\n\nPatient *${request.patient_name}* needs your help (${request.blood_group}) at ${request.hospital_name}.\n\nReply *YES ${request.short_code}* to help.`;
    
    await whatsappService.sendTextMessage(bestDonor.phone, notificationMessage);
    await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [bestDonor.id]);
    
    let adminMessage = `✅ Hyperlocal search complete. Notifying the best match: *${bestDonor.name}* (Score: ${bestDonor.final_score.toFixed(1)}, Dist: ${bestDonor.distance ? bestDonor.distance.toFixed(1) + ' km' : 'N/A'}).`;
    await whatsappService.sendTextMessage(requested_by_phone, adminMessage);
  }

  /**
   * Helper to find and score donors via the ML service.
   */
  async findAndRankGeneralDonors(bloodGroup, city, excludedDonorIds = []) {
    const { rows: availableDonors } = await db.query(
      `SELECT id, name, phone, last_donation, notifications_received, donations_confirmed, streak_count, latitude, longitude
       FROM users
       WHERE user_type = 'donor' AND blood_group = $1 AND city ILIKE $2
         AND availability_status = 'available' AND dnd_status = false
         AND (snooze_until IS NULL OR snooze_until < NOW())
         AND id NOT IN (SELECT unnest($3::uuid[]))
       LIMIT 50;`, [normalizeBloodGroup(bloodGroup), city, excludedDonorIds]
    );

    if (!availableDonors || availableDonors.length === 0) return [];
    
    const scoringPromises = availableDonors.map(donor => mlService.scoreSingleDonor(donor));
    const results = await Promise.allSettled(scoringPromises);

    const scoredDonors = availableDonors.map((donor, index) => {
        const score = results[index].status === 'fulfilled' ? results[index].value.final_score : 0;
        return { ...donor, final_score: score };
    });

    scoredDonors.sort((a, b) => b.final_score - a.final_score);
    return scoredDonors.slice(0, 5);
  }
}

export default new EmergencyService();

```

`backend/src/services/faqService.js`

```javascript
// backend/src/services/faqService.js
import { GoogleGenerativeAI } from '@google/generative-ai';
import db from '../config/db.js';
import config from '../config/config.js';
import whatsappService from './whatsappService.js';

// Initialize the Generative AI client
const genAI = new GoogleGenerativeAI(config.geminiApiKey);
const generativeModel = genAI.getGenerativeModel({ model: 'gemini-1.5-flash-latest' });

const SENSITIVE_KEYWORDS = ['problem', 'pain', 'issue', 'bad', 'reaction', 'scared', 'help me', 'confused', 'afraid'];

class FaqService {
  /**
   * Handles general user questions by generating a response from the AI model.
   * It enriches the AI's context with live data from our database.
   */
  async handleFaq(query, phone) {
    console.log(`Getting smart, generative FAQ answer for: "${query}"`);
    const disclaimer = "\n\n_Disclaimer: I am an AI assistant. This is not medical advice. Please consult a doctor for any health concerns._";
    try {
      let contextString = 'You are a helpful and compassionate assistant for BloodBridge AI, a blood donation NGO. Answer the user\'s question concisely and warmly.';
      const lowerQuery = query.toLowerCase();
      
      // --- Context Injection ---
      // Before calling the AI, we fetch live stats to make its answer more relevant.
      if (lowerQuery.includes('patient')) {
        const { rows } = await db.query("SELECT COUNT(*) as count FROM patients WHERE status = 'bridged'");
        contextString += ` IMPORTANT: Use this live statistic in your answer: We are currently supporting ${rows[0].count} long-term patients.`;
      } else if (lowerQuery.includes('donor')) {
        const { rows } = await db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor' AND availability_status = 'available'");
        contextString += ` IMPORTANT: Use this live statistic in your answer: We have ${rows[0].count} active and eligible donors.`;
      }

      const prompt = `${contextString}\n\nUser's Question: "${query}"`;
      
      const result = await generativeModel.generateContent(prompt);
      const response = await result.response;
      const aiText = response.text();
      let answer = aiText + disclaimer;
      await whatsappService.sendTextMessage(phone, answer);

      // --- Sensitive Keyword Escalation ---
      // If the query seems sensitive, create an inbox message for an admin to review.
      if (SENSITIVE_KEYWORDS.some(keyword => lowerQuery.includes(keyword))) {
        console.log(`Sensitive keyword detected. Escalating to admin inbox...`);
        await db.query(
          "INSERT INTO inbox_messages (user_phone, user_message, reason) VALUES ($1, $2, $3)",
          [phone, query, 'Sensitive Keyword Detected']
        );
        const escalationMessage = "It sounds like you might have a specific concern. I have notified an NGO volunteer, and they will contact you on this number shortly.";
        setTimeout(() => {
            whatsappService.sendTextMessage(phone, escalationMessage);
        }, 1500);
      }

    } catch (error) {
      console.error("Error generating FAQ answer with Gemini:", error);
      const fallbackMessage = "Thank you for your question. An NGO volunteer will get back to you shortly.";
      await whatsappService.sendTextMessage(phone, fallbackMessage);
    }
  }
}

export default new FaqService();

```

`backend/src/services/gamificationService.js`

```javascript
// backend/src/services/gamificationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

// A central place to define all possible achievements in the system.
const ACHIEVEMENTS = {
  FIRST_REGISTRATION: { name: 'Community Hero', points: 50, emoji: '❤️' },
  EMERGENCY_RESPONSE: { name: 'Life Saver', points: 100, emoji: '🚨' },
};

class GamificationService {
  /**
   * Awards points for a specific event, updates the user's total,
   * logs the achievement, and notifies the user.
   * @param {string} userId - The UUID of the user.
   * @param {string} event - The key for the achievement (e.g., 'FIRST_REGISTRATION').
   * @param {string} userPhone - The user's phone number for notification.
   */
  async awardPoints(userId, event, userPhone) {
    const achievement = ACHIEVEMENTS[event];
    if (!achievement) return; // If the event doesn't exist, do nothing.

    try {
      // Add points to the user's total score.
      const { rows: [user] } = await db.query(
        "UPDATE users SET gamification_points = gamification_points + $1 WHERE id = $2 RETURNING gamification_points",
        [achievement.points, userId]
      );

      if (!user) throw new Error("User not found or update failed.");

      // Log this specific achievement in the achievements table.
      await db.query(
        "INSERT INTO achievements(user_id, badge_type, points_awarded) VALUES($1, $2, $3)",
        [userId, achievement.name, achievement.points]
      );

      // Send a notification to the user.
      const notification = `🏆 Achievement Unlocked! 🏆\n\nYou've earned the *${achievement.name}* badge ${achievement.emoji} and received *${achievement.points} points*!\n\nYour new total is *${user.gamification_points} points*.`;
      await whatsappService.sendTextMessage(userPhone, notification);
    } catch (error) {
      console.error(`Error in awardPoints for user ${userId}:`, error);
    }
  }

  // We can add the getDonorStatus function here later.
}

export default new GamificationService();

```

`backend/src/services/geocodingService.js`

```javascript
// backend/src/services/geocodingService.js
import axios from 'axios';

class GeocodingService {
    async getCoords(address, city, pincode) {
        if (!address && !pincode) return null;
        const query = `${address || ''}, ${city || ''}, ${pincode || ''}`;
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
        try {
            const response = await axios.get(url, {
                headers: { 'User-Agent': 'BloodBridgeAI/1.0 (tech@bloodbridge.org)' }
            });
            if (response.data && response.data.length > 0) {
                const { lat, lon } = response.data[0];
                return { latitude: parseFloat(lat), longitude: parseFloat(lon) };
            }
            return null;
        } catch (error) {
            console.error('Error calling Geocoding API:', error.message);
            return null;
        }
    }
}

export default new GeocodingService();

```

`backend/src/services/mlService.js`

```javascript
// backend/src/services/mlService.js
import axios from 'axios';
import db from '../config/db.js';
import config from '../config/config.js';

const CACHE_DURATION_HOURS = 6;

class MLService {
    constructor() {
        this.client = axios.create({
            baseURL: config.mlServiceUrl,
            timeout: 8000,
        });
    }

    /**
     * Scores a single donor, using a cached score if available and not stale.
     */
    async scoreSingleDonor(donor) {
        // Check for a fresh score in the cache first.
        const { rows: [cachedData] } = await db.query(
            "SELECT last_ml_score, score_cached_at FROM users WHERE id = $1",
            [donor.id]
        );

        if (cachedData && cachedData.last_ml_score && cachedData.score_cached_at) {
            const cacheAgeHours = (new Date() - new Date(cachedData.score_cached_at)) / (1000 * 60 * 60);
            if (cacheAgeHours < CACHE_DURATION_HOURS) {
                console.log(`CACHE HIT: Using cached score for donor ${donor.id}`);
                return { final_score: cachedData.last_ml_score };
            }
        }

        console.log(`CACHE MISS: Calling ML service for donor ${donor.id}`);
        try {
            // If no fresh cache, call the Python ML service.
            const response = await this.client.post('/score-donor', {
                donor_id: donor.id,
                last_donation_date: donor.last_donation,
                streak_count: donor.streak_count || 0,
                notifications_received: donor.notifications_received || 0,
                donations_confirmed: donor.donations_confirmed || 0
            });
            
            const newScore = response.data.final_score;

            // Update the cache in the database with the new score.
            db.query(
                "UPDATE users SET last_ml_score = $1, score_cached_at = NOW() WHERE id = $2",
                [newScore, donor.id]
            ).catch(err => console.error(`Failed to cache ML score for donor ${donor.id}:`, err));

            return { final_score: newScore };

        } catch (error) {
            console.error(`🔴 ML Service Error for donor ${donor.id}:`, error.message);
            throw error; // Re-throw the error to be handled by the calling service.
        }
    }
}

export default new MLService();

```

`backend/src/services/patientService.js`

```javascript
// backend/src/services/patientService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import aiRouterService from './aiRouterService.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class PatientService {
  /**
   * Handles the initial message from a potential patient.
   * Uses AI to pre-fill an application or starts a conversation.
   */
  async handleNewPatient(userMessage, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingUser] } = await db.query("SELECT id FROM users WHERE phone = $1", [sanitizedPhone]);
      if (existingUser) {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back! Our records show you are already registered. An admin will be in touch shortly.`);
        return;
      }

      // Use the AI to attempt to extract details from the first message.
      const route = await aiRouterService.routeMessageWithContext(userMessage, 'Unregistered');
      
      let patientName = 'Awaiting Input';
      let bloodGroup = 'N/A';
      let city = 'N/A';

      if (route && route.tool === 'handle_patient_onboarding' && route.params.patient_name) {
          patientName = route.params.patient_name;
          bloodGroup = normalizeBloodGroup(route.params.blood_group) || 'N/A';
          city = route.params.city || 'N/A';
      }
      
      // Use a transaction to create both a 'user' and a 'patient' record.
      const client = await db.pool.connect();
      try {
        await client.query('BEGIN');
        const { rows: [newUser] } = await client.query(
            `INSERT INTO users (name, phone, blood_group, city, role, user_type)
             VALUES ($1, $2, $3, $4, 'Patient', 'patient') RETURNING id;`,
            [patientName, sanitizedPhone, bloodGroup, city]
        );
        const { rows: [newPatient] } = await client.query(
            `INSERT INTO patients (user_id, name, phone, blood_group, city, status)
             VALUES ($1, $2, $3, $4, $5, 'pending_opt_in') RETURNING id;`,
            [newUser.id, patientName, sanitizedPhone, bloodGroup, city]
        );
        await client.query('COMMIT');
        
        console.log(`New patient lead logged. User ID: ${newUser.id}, Patient ID: ${newPatient.id}`);
        
        if (patientName !== 'Awaiting Input') {
            await db.query("UPDATE patients SET status = 'pending_verification' WHERE id = $1", [newPatient.id]);
            await whatsappService.sendTextMessage(sanitizedPhone, `Thank you! We have pre-filled your application for *${patientName}*. An admin will contact you shortly to verify.`);
        } else {
            await whatsappService.sendTextMessage(sanitizedPhone, `Thank you for reaching out. To begin your application for our Blood Bridge support program, please reply with: *APPLY*`);
        }
      } catch (e) {
        await client.query('ROLLBACK');
        throw e;
      } finally {
        client.release();
      }
    } catch (error) {
      console.error('Error in handleNewPatient:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'Sorry, we encountered an error logging your request.');
    }
  }
  
  /**
   * Starts the conversational form after the user replies "APPLY".
   */
  async startApplication(phone) {
      const { rows: [patient] } = await db.query("SELECT id FROM patients WHERE phone = $1 AND status = 'pending_opt_in'", [phone]);
      if (!patient) return false; // Not a user waiting to apply

      await db.query("UPDATE patients SET status = 'pending_details' WHERE id = $1", [patient.id]);
      await this.continueOnboarding(patient.id, phone);
      return true;
  }

  /**
   * The "state machine" that asks the next question based on what info is missing.
   */
  async continueOnboarding(patientId, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE id = $1", [patientId]);
    if (!patient) return;

    if (patient.name === 'Awaiting Input') {
      await whatsappService.sendTextMessage(phone, "Great! Let's begin.\n\nFirst, what is the patient's full name?");
      return;
    }
    if (patient.blood_group === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Thank you. What is ${patient.name}'s blood group? (e.g., O+, AB-)`);
      return;
    }
    if (patient.city === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Got it. In which city does the patient receive treatment?`);
      return;
    }

    // All details are collected.
    await db.query("UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    const finalMessage = `Thank you! We have all the initial information we need for *${patient.name}*.\n\nAn admin has been notified and will contact you on this number to verify the details.`;
    await whatsappService.sendTextMessage(phone, finalMessage);
  }

  /**
   * Processes a user's reply during the conversational form.
   */
  async processOnboardingReply(message, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE phone = $1 AND status = 'pending_details'", [phone]);
    if (!patient) return false; // User is not in the middle of an application.

    let columnToUpdate = null;
    let valueToUpdate = message;
    
    if (patient.name === 'Awaiting Input') columnToUpdate = 'name';
    else if (patient.blood_group === 'N/A') {
      columnToUpdate = 'blood_group';
      valueToUpdate = normalizeBloodGroup(message);
    } else if (patient.city === 'N/A') columnToUpdate = 'city';
    
    if (columnToUpdate) {
        await db.query(`UPDATE patients SET ${columnToUpdate} = $1 WHERE id = $2`, [valueToUpdate, patient.id]);
        await db.query(`UPDATE users SET ${columnToUpdate} = $1 WHERE id = $2`, [valueToUpdate, patient.user_id]);
        
        // Ask the next question after a short delay
        setTimeout(() => { this.continueOnboarding(patient.id, phone); }, 500);
        return true; // The message was handled.
    }
    return false;
  }
}

export default new PatientService();

```

`backend/src/services/registrationService.js`

```javascript
// backend/src/services/registrationService.js
import db from '../config/db.js';
import whatsappService from '../services/whatsappService.js';
import gamificationService from './gamificationService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';

class RegistrationService {
  async handleNewDonor(params, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingUser] } = await db.query(
        "SELECT id, name, registration_status FROM users WHERE phone = $1", 
        [sanitizedPhone]
      );
      
      if (existingUser && existingUser.registration_status === 'completed') {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back, ${existingUser.name}! You are already registered and ready to help.`);
        return;
      }
      
      let { name, city, blood_group } = params;

      if (name && city && blood_group) {
        const normalizedBG = normalizeBloodGroup(blood_group);
        let newUser;
        if (existingUser) { // If user existed but was 'pending'
          const { rows } = await db.query(
            // ✅ FIX: Corrected parameter index from $1 to $4
            "UPDATE users SET name = $1, city = $2, blood_group = $3, registration_status = 'completed', role = 'Emergency Donor' WHERE id = $4 RETURNING *;",
            [name, city, normalizedBG, existingUser.id]
          );
          newUser = rows[0];
        } else { // If a completely new user
          const { rows } = await db.query(
            "INSERT INTO users(name, city, blood_group, phone, user_type, registration_status, role) VALUES($1, $2, $3, $4, 'donor', 'completed', 'Emergency Donor') RETURNING *;",
            [name, city, normalizedBG, sanitizedPhone]
          );
          newUser = rows[0];
        }

        const successMessage = `✅ Registration Complete!\n\nWelcome, ${newUser.name}! You are now a registered Blood Warrior in ${city}.`;
        await whatsappService.sendTextMessage(sanitizedPhone, successMessage);
        
        gamificationService.awardPoints(newUser.id, 'FIRST_REGISTRATION', sanitizedPhone);
        return;
      }
      
      if (!existingUser) {
        await db.query(
          "INSERT INTO users(name, phone, registration_status, role) VALUES ($1, $2, 'pending', 'Unregistered')",
          ['Pending User', sanitizedPhone]
        );
      }
      
      const followupMessage = "Thank you for your interest! To complete your registration, please reply with your details in this format:\n\n*Register: [Your Name], [Your City], [Your Blood Group]*";
      await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);

    } catch (error) {
      console.error('Critical error in handleNewDonor:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'We encountered an error during registration. Please try again later.');
    }
  }
}

export default new RegistrationService();

```

`backend/src/services/responseService.js`

```javascript
// backend/src/services/responseService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateOTP } from '../utils/otpHelper.js';
import gamificationService from './gamificationService.js';
import bridgeService from './bridgeService.js';

class ResponseService {
    /**
     * Handles the donor's initial reply (e.g., "YES 1234").
     * It validates the code and sends back a 6-digit OTP to verify.
     */
    async handleDonorReplyWithShortCode(donorPhone, shortCode) {
        try {
            const { rows: [request] } = await db.query(`SELECT id FROM emergency_requests WHERE short_code = $1 AND status = 'active'`, [shortCode]);
            if (!request) {
                await whatsappService.sendTextMessage(donorPhone, `Sorry, we couldn't find an active request with code ${shortCode}. It may have been fulfilled.`);
                return;
            }

            const { rows: [user] } = await db.query(`SELECT id FROM users WHERE phone = $1`, [donorPhone]);
            if (!user) {
                await whatsappService.sendTextMessage(donorPhone, "We couldn't find your registration. Please register first.");
                return;
            }

            const otp = generateOTP();
            await db.query(
                `INSERT INTO donor_responses (donor_id, request_id, response, otp, otp_expires_at)
                 VALUES ($1, $2, 'pending', $3, NOW() + INTERVAL '10 minutes')
                 ON CONFLICT (donor_id, request_id) DO UPDATE SET response = 'pending', otp = $3, otp_expires_at = NOW() + INTERVAL '10 minutes';`,
                [user.id, request.id, otp]
            );

            const otpMessage = `Thank you for your quick response! To finalize your confirmation, please reply with *only* the following 6-digit code:\n\n*${otp}*`;
            await whatsappService.sendTextMessage(donorPhone, otpMessage);
        } catch (error) {
            console.error('Error in handleDonorReplyWithShortCode:', error);
            await whatsappService.sendTextMessage(donorPhone, "There was a system error processing your reply.");
        }
    }

    /**
     * Verifies the 6-digit OTP and finalizes the donation confirmation.
     * This function uses a database transaction to ensure all updates succeed or none do.
     */
    async verifyOTPAndConfirm(donorPhone, otp) {
        const client = await db.pool.connect();
        try {
            await client.query('BEGIN');

            const { rows: [response] } = await client.query(
                `SELECT dr.id, dr.request_id, u.name as donor_name, u.id as donor_id, er.patient_name, er.requested_by_phone
                 FROM donor_responses dr JOIN users u ON dr.donor_id = u.id JOIN emergency_requests er ON dr.request_id = er.id
                 WHERE u.phone = $1 AND dr.otp = $2 AND dr.otp_expires_at > NOW() AND dr.response = 'pending' FOR UPDATE;`,
                [donorPhone, otp]
            );

            if (!response) {
                await whatsappService.sendTextMessage(donorPhone, "Invalid or expired OTP. Please try the 'YES [code]' step again.");
                await client.query('ROLLBACK');
                return;
            }

            // Perform all database updates
            await client.query(`UPDATE users SET last_donation = NOW(), availability_status = 'unavailable', cooldown_until = NOW() + INTERVAL '90 days', donations_confirmed = donations_confirmed + 1, streak_count = streak_count + 1 WHERE id = $1`, [response.donor_id]);
            await client.query("UPDATE donor_responses SET response = 'accepted', confirmed_at = NOW(), otp = NULL WHERE id = $1", [response.id]);
            await client.query("UPDATE emergency_requests SET status = 'fulfilled' WHERE id = $1", [response.request_id]);
            await bridgeService.rotateMemberToBack(response.donor_id, client);

            await client.query('COMMIT');

            // Send confirmations and award points
            const donorConfirmationMessage = `✅ Confirmed! Thank you, ${response.donor_name}!\n\nYour donation for *${response.patient_name}* is confirmed. Please coordinate with the hospital. You are a true hero!`;
            await whatsappService.sendTextMessage(donorPhone, donorConfirmationMessage);

            if (response.requested_by_phone) {
                const requesterUpdate = `✅ Good News! A donor has been confirmed for your request for *${response.patient_name}*.`;
                await whatsappService.sendTextMessage(response.requested_by_phone, requesterUpdate);
            }
            gamificationService.awardPoints(response.donor_id, 'EMERGENCY_RESPONSE', donorPhone);

        } catch (error) {
            await client.query('ROLLBACK');
            console.error("Error verifying OTP:", error);
            await whatsappService.sendTextMessage(donorPhone, "A system error occurred during OTP verification.");
        } finally {
            client.release();
        }
    }

    // We can implement the handleSimpleDecline function later.
}

export default new ResponseService();

```

`backend/src/services/whatsappService.js`

```javascript
// backend/src/services/whatsappService.js
import axios from 'axios';
import config from '../config/config.js';

class WhatsAppService {
  constructor() {
    this.token = config.whatsappToken;
    this.phoneNumberId = config.whatsappPhoneNumberId;

    if (!this.token || !this.phoneNumberId) {
      console.warn('WhatsApp token or Phone Number ID are missing from configuration. Messages will not be sent.');
    }

    this.client = axios.create({
      baseURL: `https://graph.facebook.com/v18.0/${this.phoneNumberId}`,
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Content-Type': 'application/json'
      }
    });
  }

  /**
   * Sends a text message.
   * @param {string} to - The recipient's phone number (e.g., '918000000000').
   * @param {string} text - The message body.
   */
  async sendTextMessage(to, text) {
    if (!this.token) return { success: false, error: "WhatsApp service not configured." };

    const payload = {
      messaging_product: 'whatsapp',
      to: to,
      type: 'text',
      text: { body: text }
    };
    try {
      const response = await this.client.post('/messages', payload);
      console.log(`✅ Message sent successfully to ${to}.`);
      return { success: true, data: response.data };
    } catch (error) {
      console.error(`🔴 FAILED to send message to ${to}.`);
      if (error.response) {
        console.error(`Error Details: ${error.response.data.error?.message}`);
      }
      return { success: false, error: error.message };
    }
  }
}

export default new WhatsAppService();

```

`backend/src/utils/dataSanitizer.js`

```javascript
// backend/src/utils/dataSanitizer.js
export const normalizeBloodGroup = (group) => {
  if (!group) return 'Unknown';
  const upperGroup = group.toUpperCase();
  let normalized = upperGroup.replace(/\s/g, '').replace('POSITIVE', '+').replace('NEGATIVE', '-');
  if (normalized.endsWith('POS')) normalized = normalized.replace('POS', '+');
  if (normalized.endsWith('NEG')) normalized = normalized.replace('NEG', '-');
  return normalized.slice(0, 5);
};

```

`backend/src/utils/distanceHelper.js`

```javascript
// backend/src/utils/distanceHelper.js
/**
 * Calculates distance between two lat/lng points in km using the Haversine formula.
 */
export const getDistanceInKm = (lat1, lon1, lat2, lon2) => {
    if ((lat1 == lat2) && (lon1 == lon2)) {
        return 0;
    }
    const R = 6371; // Radius of the earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        0.5 - Math.cos(dLat) / 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        (1 - Math.cos(dLon)) / 2;
    return R * 2 * Math.asin(Math.sqrt(a));
};

```

`backend/src/utils/otpHelper.js`

```javascript
// backend/src/utils/otpHelper.js

/**
 * Generates a 4-digit numeric code for donors to reply with.
 * @returns {string} A 4-digit string.
 */
export const generateShortCode = () => {
  return Math.floor(1000 + Math.random() * 9000).toString();
};

/**
 * Generates a 6-digit numeric OTP for final confirmation.
 * @returns {string} A 6-digit string.
 */
export const generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

```

`backend/src/utils/phoneHelper.js`

```javascript
// backend/src/utils/phoneHelper.js
export const normalizePhoneNumber = (phone) => {
  if (!phone || typeof phone !== 'string') return null;
  let digits = phone.replace(/\D/g, '');
  if (digits.startsWith('91') && digits.length === 12) {
    return `+${digits}`;
  } else if (digits.length === 10) {
    return `+91${digits}`;
  }
  return `+${digits}`;
};

```

`code.txt`

```
`admin-dashboard/code2.txt`

```
`code.txt`

```
`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`src/App.jsx`

```javascript
// src/App.jsx

import React, { useState } from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import LoginPage from './LoginPage.jsx';
import Dashboard from './Dashboard.jsx';
import theme from './theme.js';

/**
 * The main App component.
 * It acts as the root of the application, managing authentication state
 * and providing the global MUI theme.
 */
function App() {
  // State to track if the user is logged in. Default is false.
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  // Function to be passed to LoginPage to handle successful login
  const handleLogin = () => {
    setIsLoggedIn(true);
  };

  // Function to be passed to Dashboard to handle logout
  const handleLogout = () => {
    setIsLoggedIn(false);
  };

  return (
    // ThemeProvider applies the custom theme to all descendant components.
    // CssBaseline provides a consistent baseline style across browsers.
    <ThemeProvider theme={theme}>
      <CssBaseline />
      {/* Conditionally render Dashboard or LoginPage based on login state */}
      {isLoggedIn ? (
        <Dashboard onLogout={handleLogout} />
      ) : (
        <LoginPage onLogin={handleLogin} />
      )}
    </ThemeProvider>
  );
}

export default App;

```

`src/Dashboard.jsx`

```javascript
// src/Dashboard.jsx

import React, { useState, useEffect } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Grid, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress,
  Button,
} from "@mui/material";

import { Bloodtype, LocationCity, AddLink, Close } from "@mui/icons-material";

// ✅ Dummy API functions (replace with real API calls)
const fetchPendingPatients = async () =>
  Promise.resolve([
    { id: 1, name: "John Doe", blood_group: "A+", city: "Delhi" },
    { id: 2, name: "Jane Smith", blood_group: "O-", city: "Mumbai" },
  ]);

const fetchActiveEmergencies = async () =>
  Promise.resolve([
    { id: 3, patient_name: "Alex", blood_group: "B+", status: "Urgent" },
    { id: 4, patient_name: "Maria", blood_group: "AB-", status: "Open" },
  ]);

const Dashboard = ({ onLogout }) => {
  const [tabValue, setTabValue] = useState(0);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm")); // <600px
  const isTablet = useMediaQuery(theme.breakpoints.between("sm", "md")); // 600-900px
  const isLaptop = useMediaQuery(theme.breakpoints.between("md", "lg")); // 900-1200px

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      const apiCall = tabValue === 0 ? fetchPendingPatients : fetchActiveEmergencies;
      const result = await apiCall();
      setData(result);
      setLoading(false);
    };
    loadData();
  }, [tabValue]);

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // ✅ Card list for small & medium screens
  const renderCardList = () => (
    <Grid container spacing={2}>
      {data.map((item) => (
        <Grid item xs={12} sm={6} md={4} key={item.id}>
          <Card variant="outlined" sx={{ height: "100%" }}>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                {tabValue === 0 ? item.name : item.patient_name}
              </Typography>
              <Stack direction="column" spacing={1}>
                <Chip
                  icon={<Bloodtype />}
                  label={`Blood Group: ${item.blood_group}`}
                  size="small"
                />
                {tabValue === 0 ? (
                  <Chip
                    icon={<LocationCity />}
                    label={`City: ${item.city}`}
                    size="small"
                  />
                ) : (
                  <Chip label={`Status: ${item.status}`} color="warning" size="small" />
                )}
              </Stack>
            </CardContent>
            <CardActions sx={{ justifyContent: "flex-end" }}>
              {tabValue === 0 ? (
                <Button variant="contained" size="small" startIcon={<AddLink />}>
                  Create Bridge
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="secondary"
                  size="small"
                  startIcon={<Close />}
                >
                  Close Request
                </Button>
              )}
            </CardActions>
          </Card>
        </Grid>
      ))}
    </Grid>
  );

  // ✅ Table for larger screens (Laptop & Desktop)
  const renderTable = () => (
    <TableContainer>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>{tabValue === 0 ? "Name" : "Patient Name"}</TableCell>
            <TableCell>Blood Group</TableCell>
            <TableCell>{tabValue === 0 ? "City" : "Status"}</TableCell>
            <TableCell align="right">Actions</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {data.map((item) => (
            <TableRow hover key={item.id}>
              <TableCell>{tabValue === 0 ? item.name : item.patient_name}</TableCell>
              <TableCell>
                <Chip
                  label={item.blood_group}
                  color="primary"
                  variant="outlined"
                  size="small"
                />
              </TableCell>
              <TableCell>
                {tabValue === 0 ? (
                  item.city
                ) : (
                  <Chip label={item.status} color="warning" size="small" />
                )}
              </TableCell>
              <TableCell align="right">
                {tabValue === 0 ? (
                  <Button variant="contained" size="small" startIcon={<AddLink />}>
                    Create Bridge
                  </Button>
                ) : (
                  <Button
                    variant="contained"
                    color="secondary"
                    size="small"
                    startIcon={<Close />}
                  >
                    Close Request
                  </Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );

// inside src/Dashboard.jsx — modify the JSX return where Container is used:

  return (
    <Box
      sx={{
        flexGrow: 1,
        backgroundColor: theme.palette.background.default,
        minHeight: "100vh",
      }}
    >
      {/* AppBar stays full width of viewport */}
      <AppBar position="static" sx={{ boxShadow: 1 }}>
        <Toolbar sx={{ px: { xs: 2, md: 4 } }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            🩸 BloodBridge AI
          </Typography>
          <Button color="inherit" onClick={onLogout}>
            Logout
          </Button>
        </Toolbar>
      </AppBar>

      {/* Make container span full width but keep inner content centered with a maxWidth */}
      <Container
        maxWidth={false}
        disableGutters
        sx={{
          px: { xs: 2, md: 4 },
          py: 4,
        }}
      >
        {/* center the page content while allowing it to be fluid on small screens */}
        <Box sx={{ width: "100%", maxWidth: 1100, mx: "auto" }}>
          <Typography variant="h4" gutterBottom>
            Admin Dashboard
          </Typography>

          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Box sx={{ borderBottom: 1, borderColor: "divider", mb: 3 }}>
              <Tabs value={tabValue} onChange={handleTabChange}>
                <Tab label="Pending Patients" />
                <Tab label="Active Emergencies" />
              </Tabs>
            </Box>

            {loading ? (
              <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}>
                <CircularProgress />
              </Box>
            ) : (
              // responsive decision: cards for small/tablet, table for larger screens
              (isMobile || isTablet) ? renderCardList() : renderTable()
            )}
          </Paper>
        </Box>
      </Container>
    </Box>
  );

};

export default Dashboard;

```

`src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`src/LoginPage.jsx`

```javascript
// src/LoginPage.jsx

import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert } from '@mui/material';

/**
 * The LoginPage component.
 * It displays a simple login form and validates the password.
 * On successful validation, it calls the onLogin prop function.
 */
const LoginPage = ({ onLogin }) => {
  // State to hold the password input value
  const [password, setPassword] = useState('');
  // State to hold any login error messages
  const [error, setError] = useState('');

  // Handles the form submission
  const handleSubmit = (event) => {
    event.preventDefault(); // Prevent default form submission behavior

    // Simple validation: check if the password is "admin"
    if (password === 'admin') {
      setError(''); // Clear any previous errors
      onLogin(); // Call the parent component's login handler
    } else {
      // Set an error message for incorrect password
      setError('Incorrect password. Hint: try "admin"');
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Typography component="h1" variant="h5">
          🩸 BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 3 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoFocus
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {/* Display an error alert if the error state is not empty */}
          {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2 }}
          >
            Sign In
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;   

```

`src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

// It's good practice to have a minimal CSS reset or base styles.
// You can leave the default index.css or make it an empty file for now.
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

`src/mockApi.js`

```javascript
// src/mockApi.js

/**
 * This file acts as a fake backend API.
 * The functions here simulate network requests by returning a Promise
 * that resolves with mock data after a 500ms delay.
 */

// Mock data for the "Pending Patients" tab
const mockPendingPatients = [
  { "id": "p1", "name": "Aarav Sharma", "blood_group": "A+", "city": "Delhi" },
  { "id": "p2", "name": "Saanvi Gupta", "blood_group": "O-", "city": "Mumbai" },
  { "id": "p3", "name": "Vihaan Reddy", "blood_group": "B+", "city": "Bangalore" },
  { "id": "p4", "name": "Diya Singh", "blood_group": "AB-", "city": "Kolkata" }
];

// Mock data for the "Active Emergencies" tab
const mockActiveEmergencies = [
  { "id": "e1", "patient_name": "Isha Patel", "blood_group": "AB+", "status": "Searching" },
  { "id": "e2", "patient_name": "Rohan Kumar", "blood_group": "O+", "status": "Partially Fulfilled" },
  { "id": "e3", "patient_name": "Ananya Joshi", "blood_group": "A-", "status": "Critical" }
];

/**
 * Fetches a list of pending patients.
 * @returns {Promise<Array<Object>>} A promise that resolves to the patient list.
 */
export const fetchPendingPatients = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockPendingPatients);
    }, 500); // 500ms delay to simulate network latency
  });
};

/**
 * Fetches a list of active emergencies.
 * @returns {Promise<Array<Object>>} A promise that resolves to the emergencies list.
 */
export const fetchActiveEmergencies = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockActiveEmergencies);
    }, 500); // 500ms delay to simulate network latency
  });
};

```

`src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

```

`admin-dashboard/eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

```

`admin-dashboard/index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

`admin-dashboard/src/api/apiClient.js`

```javascript
// src/api/apiClient.js
import axios from 'axios';

const BASE = (import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001').replace(/\/$/, '');

const apiClient = axios.create({
  baseURL: BASE,
  headers: { 'Content-Type': 'application/json' },
  timeout: 20000,
});

// simple map to avoid spamming same error repeatedly
const loggedUrls = new Set();

apiClient.interceptors.request.use((config) => {
  const url = config.url || '';
  // attach token for everything except login/register
  if (!url.includes('/login') && !url.includes('/register')) {
    const token = localStorage.getItem('token');
    if (token && typeof token === 'string' && token.split('.').length === 3) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }
  return config;
});

apiClient.interceptors.response.use(
  (res) => res,
  (err) => {
    const out = {
      url: err.config?.url,
      status: err.response?.status,
      message: err.message,
      data: err.response?.data,
    };

    // Log each failing URL once to reduce noise
    if (!loggedUrls.has(out.url)) {
      loggedUrls.add(out.url);
      console.error('API request failed:', out);
    }

    const normalized = new Error(out.message || 'API error');
    normalized.url = out.url;
    normalized.status = out.status;
    normalized.data = out.data;
    return Promise.reject(normalized);
  }
);

export default apiClient;

```

`admin-dashboard/src/App.css`

```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

`admin-dashboard/src/App.jsx`

```javascript
// admin-dashboard/src/App.jsx
import React from 'react';
import { ThemeProvider, CssBaseline } from '@mui/material';
import { AuthProvider } from './context/AuthContext.jsx';
import { Routes, Route, Navigate } from 'react-router-dom'; // ✅ IMPORT ROUTER COMPONENTS
import theme from './theme.js';
import LoginPage from './pages/LoginPage.jsx';
import DashboardPage from './pages/Dashboard.jsx';
import { useAuth } from './hooks/useAuth.js';

/**
 * A protected route component. If the user is not logged in,
 * it redirects them to the login page.
 */
const ProtectedRoute = ({ children }) => {
  const { isLoggedIn } = useAuth();
  return isLoggedIn ? children : <Navigate to="/" />;
};

/**
 * The main App component, now with a proper routing structure.
 */
function App() {
  return (
    <AuthProvider>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <Routes>
          <Route path="/" element={<LoginPage />} />
          <Route 
            path="/dashboard" 
            element={
              <ProtectedRoute>
                <DashboardPage />
              </ProtectedRoute>
            } 
          />
        </Routes>
      </ThemeProvider>
    </AuthProvider>
  );
}

export default App;

```

`admin-dashboard/src/components/common/ConfirmationDialog.jsx`

```javascript
// src/components/common/ConfirmationDialog.jsx
import React, { useState, useCallback } from 'react';
import PropTypes from 'prop-types';
import {
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from '@mui/material';

/**
 * Reusable confirmation dialog.
 * - Awaits async onConfirm handlers before closing.
 * - Disables buttons while processing to avoid duplicate calls.
 */
const ConfirmationDialog = ({ open, onClose, onConfirm, title, message, confirmText = 'Confirm', cancelText = 'Cancel' }) => {
  const [processing, setProcessing] = useState(false);

  const handleConfirm = useCallback(async () => {
    if (processing) return;
    setProcessing(true);
    try {
      if (typeof onConfirm === 'function') {
        // Call handler and await if it returns a promise
        const result = onConfirm();
        if (result && typeof result.then === 'function') {
          await result;
        }
      }
    } catch (err) {
      // Log — parent can set error state if needed
      // Avoid swallowing errors silently in prod; you may surface this to UI
      // eslint-disable-next-line no-console
      console.error('ConfirmationDialog onConfirm error:', err);
    } finally {
      setProcessing(false);
      if (typeof onClose === 'function') onClose();
    }
  }, [onConfirm, onClose, processing]);

  return (
    <Dialog
      open={Boolean(open)}
      onClose={() => {
        if (!processing && typeof onClose === 'function') onClose();
      }}
      aria-labelledby="confirmation-dialog-title"
      aria-describedby="confirmation-dialog-description"
      fullWidth
      maxWidth="xs"
    >
      <DialogTitle id="confirmation-dialog-title">{title}</DialogTitle>
      <DialogContent>
        <DialogContentText id="confirmation-dialog-description">
          {message}
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={() => { if (!processing && typeof onClose === 'function') onClose(); }} disabled={processing}>
          {cancelText}
        </Button>

        <Button
          onClick={handleConfirm}
          color="primary"
          variant="contained"
          autoFocus
          disabled={processing}
        >
          {confirmText}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

ConfirmationDialog.propTypes = {
  open: PropTypes.bool,
  onClose: PropTypes.func,
  onConfirm: PropTypes.func,
  title: PropTypes.string,
  message: PropTypes.string,
  confirmText: PropTypes.string,
  cancelText: PropTypes.string,
};

ConfirmationDialog.defaultProps = {
  open: false,
  onClose: () => {},
  onConfirm: null,
  title: 'Confirm',
  message: '',
  confirmText: 'Confirm',
  cancelText: 'Cancel',
};

export default React.memo(ConfirmationDialog);

```

`admin-dashboard/src/components/dashboard/BloodGroupChart.jsx`

```javascript
// src/components/dashboard/BloodGroupChart.jsx
import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import {
  BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
} from 'recharts';
import { Box, Typography, useTheme } from '@mui/material';

/**
 * A responsive bar chart to display blood group distribution.
 * Expects data shape: [{ blood_group: 'A+', count: 10 }, ...]
 */
const BloodGroupChart = ({ data }) => {
  const theme = useTheme();

  // Defensive: normalize/sort data so chart is stable
  const prepared = useMemo(() => {
    if (!Array.isArray(data)) return [];
    // ensure numeric counts and stable ordering (by blood_group)
    return [...data]
      .map((d) => ({ blood_group: d.blood_group ?? 'Unknown', count: Number(d.count) || 0 }))
      .sort((a, b) => {
        // you can sort by count desc: return b.count - a.count;
        // here we sort by blood_group for predictable axis order
        return a.blood_group.localeCompare(b.blood_group);
      });
  }, [data]);

  if (!prepared || prepared.length === 0) {
    return (
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: 300 }}>
        <Typography color="text.secondary">No chart data available.</Typography>
      </Box>
    );
  }

  return (
    // aria-label helps screen readers understand this visual
    <Box role="img" aria-label="Donor distribution by blood group">
      <ResponsiveContainer width="100%" height={300}>
        <BarChart
          data={prepared}
          margin={{ top: 6, right: 16, left: -12, bottom: 6 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke={theme.palette.divider} />
          <XAxis dataKey="blood_group" stroke={theme.palette.text.secondary} />
          <YAxis stroke={theme.palette.text.secondary} allowDecimals={false} />
          <Tooltip
            contentStyle={{
              backgroundColor: theme.palette.background.paper,
              borderColor: theme.palette.divider,
            }}
            formatter={(value) => [value, 'Donors']}
          />
          <Legend />
          <Bar dataKey="count" name="Total Donors" fill={theme.palette.primary.main} />
        </BarChart>
      </ResponsiveContainer>
    </Box>
  );
};

BloodGroupChart.propTypes = {
  data: PropTypes.arrayOf(
    PropTypes.shape({
      blood_group: PropTypes.string,
      count: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    })
  ),
};

BloodGroupChart.defaultProps = {
  data: [],
};

export default React.memo(BloodGroupChart);

```

`admin-dashboard/src/components/dashboard/StatCard.jsx`

```javascript
// src/components/dashboard/StatCard.jsx
import React from "react";
import PropTypes from "prop-types";
import { Paper, Box, Typography, Avatar, useTheme } from "@mui/material";

/**
 * A reusable component to display a single dashboard statistic.
 *
 * Props:
 * - icon: React node shown inside the Avatar
 * - title: short label for the stat
 * - value: numeric or string value to display
 * - color: theme token or CSS color for Avatar background (e.g. "primary.main")
 */
const StatCard = ({ icon, title, value, color = "primary.main" }) => {
  const theme = useTheme();

  // Resolve theme token like "primary.main" to an actual color string
  const resolvedColor = (() => {
    if (!color) return undefined;
    // if color contains a dot, treat as theme token
    if (typeof color === "string" && color.includes(".")) {
      const [paletteKey, shade] = color.split(".");
      return theme.palette?.[paletteKey]?.[shade] ?? color;
    }
    return color;
  })();

  // Format numbers nicely (1000 -> 1,000)
  const formattedValue =
    typeof value === "number"
      ? new Intl.NumberFormat().format(value)
      : value ?? "—";

  return (
    <Paper
      elevation={3}
      sx={{
        p: 2,
        display: "flex",
        alignItems: "center",
        height: "100%",
      }}
      role="region"
      aria-label={`${title} stat`}
      title={`${title}: ${formattedValue}`}
    >
      <Avatar
        sx={{
          bgcolor: resolvedColor,
          width: 56,
          height: 56,
          mr: 2,
          color: (theme.palette.getContrastText
            ? theme.palette.getContrastText(resolvedColor)
            : "#fff"),
        }}
        aria-hidden="true"
      >
        {icon}
      </Avatar>

      <Box sx={{ minWidth: 0 }}>
        <Typography color="text.secondary" noWrap variant="caption">
          {title}
        </Typography>
        <Typography variant="h5" component="div" fontWeight="bold" noWrap>
          {formattedValue}
        </Typography>
      </Box>
    </Paper>
  );
};

StatCard.propTypes = {
  icon: PropTypes.node,
  title: PropTypes.string.isRequired,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  color: PropTypes.string,
};

StatCard.defaultProps = {
  icon: null,
  value: "0",
  color: "primary.main",
};

export default React.memo(StatCard);

```

`admin-dashboard/src/context/AuthContext.jsx`

```javascript
// src/context/AuthContext.jsx
import React, { createContext, useState } from 'react';

// 1. Create the context
// This object will be used by other components to access the auth state.
export const AuthContext = createContext(null);

// 2. Create the Provider component
// This component will wrap our application and provide the auth state.
export const AuthProvider = ({ children }) => {
  // Initialize the token state by reading from localStorage.
  // This ensures that the user remains logged in even after a page refresh.
  const [token, setToken] = useState(localStorage.getItem('token'));

  // The login function saves the token to both localStorage and the state.
  const login = (newToken) => {
    localStorage.setItem('token', newToken);
    setToken(newToken);
  };

  // The logout function removes the token from localStorage and the state.
  const logout = () => {
    localStorage.removeItem('token');
    setToken(null);
  };

  // 3. Define the value to be provided by the context
  // We derive `isLoggedIn` directly from the presence of a token.
  const value = {
    token,
    isLoggedIn: !!token,
    login,
    logout,
  };

  // 4. Return the provider with the value, wrapping any child components.
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

```

`admin-dashboard/src/hooks/useAuth.js`

```javascript
// src/hooks/useAuth.js
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext.jsx';

/**
 * A custom hook for accessing the AuthContext.
 * This simplifies the process in any component that needs auth data,
 * as we can just call `useAuth()` instead of `useContext(AuthContext)`.
 */
export const useAuth = () => {
  return useContext(AuthContext);
};

```

`admin-dashboard/src/index.css`

```css
/* src/index.css - replace contents with this */

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: #213547;
  background-color: #f4f6f8;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: #f4f6f8;
  color: #213547;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-family: inherit;
}

/* root should fill the viewport and let inner layout control widths */
#root {
  width: 100%;
  height: 100%;
}

/* small utility tweaks */
a { color: #646cff; text-decoration: none; }
button { font-family: inherit; }

/* responsive headings */
h1 { font-size: 2.25rem; margin: 0; }

/* keep default button styles light so MUI takes precedence */
button {
  border: none;
  background: none;
}

/* light/dark preference override (keeps consistent colors with MUI theme) */
@media (prefers-color-scheme: dark) {
  :root { background-color: #121212; color: #e6eef6; }
}

```

`admin-dashboard/src/main.jsx`

```javascript
// src/main.jsx

import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom'; // <-- 1. IMPORT THE ROUTER
import App from './App.jsx';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    {/* 2. WRAP YOUR APP WITH THE ROUTER */}
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

```

`admin-dashboard/src/pages/Dashboard.jsx`

```javascript
// src/pages/Dashboard.jsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  AppBar, Toolbar, Typography, Container, Box, Paper, Stack,
  useTheme, useMediaQuery,
  Tabs, Tab, Table, TableBody, TableCell, TableContainer, TableHead, TableRow,
  Card, CardContent, CardActions, Chip, CircularProgress, Button, Alert,
} from "@mui/material";
import {
  Bloodtype, LocationCity, AddLink, Close, Logout,
  PeopleAlt, Favorite, Healing, Warning,
} from "@mui/icons-material";

import { useAuth } from "../hooks/useAuth.js";
import apiClient from "../api/apiClient.js";
import StatCard from "../components/dashboard/StatCard.jsx";
import BloodGroupChart from "../components/dashboard/BloodGroupChart.jsx";
import ConfirmationDialog from "../components/common/ConfirmationDialog.jsx";

// --- Utility: Normalize API response into a clean array ---
const normalizeList = (res) => {
  if (!res) return [];
  if (Array.isArray(res)) return res;
  const d = res.data;
  if (Array.isArray(d)) return d;
  if (d && Array.isArray(d.data)) return d.data;
  if (d && typeof d === "object") {
    for (const k of Object.keys(d)) {
      if (Array.isArray(d[k])) return d[k];
    }
  }
  return [];
};

// --- Mock fallback data if API fails ---
const MOCK_STATS = { total_donors: 0, active_donors: 0, pending_patients: 0, patients_at_risk: 0 };
const MOCK_PATIENTS = [];
const MOCK_EMERGENCIES = [];
const MOCK_BLOOD_GROUPS = [];

// --- Tab Panel wrapper for accessibility ---
const TabPanel = ({ children, value, index }) => (
  <div role="tabpanel" hidden={value !== index}>
    {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
  </div>
);

const DashboardPage = () => {
  const { logout } = useAuth();
  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down("md"));

  // --- State ---
  const [tabValue, setTabValue] = useState(0);
  const [stats, setStats] = useState(null);
  const [patients, setPatients] = useState([]);
  const [emergencies, setEmergencies] = useState([]);
  const [bloodGroupData, setBloodGroupData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [dialog, setDialog] = useState({ open: false, title: "", message: "", onConfirm: null });

  // --- Fetch Dashboard Data from API ---
  const fetchDashboardData = useCallback(async () => {
    setLoading(true);
    setError("");
    try {
      const results = await Promise.allSettled([
        apiClient.get("/api/admin/stats"),
        apiClient.get("/api/admin/patients"),
        apiClient.get("/api/admin/emergencies"),
        apiClient.get("/api/admin/stats/blood-groups"),
      ]);

      const [statsRes, patientsRes, emergenciesRes, bloodGroupRes] = results;

      if (statsRes.status === "fulfilled") setStats(statsRes.value?.data ?? null);
      if (patientsRes.status === "fulfilled") setPatients(normalizeList(patientsRes.value));
      if (emergenciesRes.status === "fulfilled") setEmergencies(normalizeList(emergenciesRes.value));
      if (bloodGroupRes.status === "fulfilled") setBloodGroupData(bloodGroupRes.value?.data ?? []);

      // If everything failed -> use mock data
      const allRejected = results.every((r) => r.status === "rejected");
      if (allRejected) {
        setError("Failed to fetch dashboard data — using fallback mock data.");
        setStats(MOCK_STATS);
        setPatients(MOCK_PATIENTS);
        setEmergencies(MOCK_EMERGENCIES);
        setBloodGroupData(MOCK_BLOOD_GROUPS);
      }
    } catch (err) {
      console.error("Unexpected error in fetchDashboardData:", err);
      setError("Unexpected error. Using fallback.");
      setStats(MOCK_STATS);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchDashboardData();
  }, [fetchDashboardData]);

  // --- Tabs switch handler ---
  const handleTabChange = useCallback((_, newValue) => setTabValue(newValue), []);

  // --- Utility for API actions with refresh ---
  const executeApiAction = useCallback(async (action, successCallback, errorCallback) => {
    setError("");
    try {
      await action();
      if (successCallback) successCallback();
      await fetchDashboardData();
    } catch (err) {
      console.error("API Action Failed:", err);
      if (errorCallback) errorCallback(err);
      setError(err.response?.data?.message || "An error occurred. Please try again.");
    }
  }, [fetchDashboardData]);

  // --- Action Handlers with Confirmation Dialog ---
  const handleCreateBridge = useCallback((patientId, patientName) => {
    setDialog({
      open: true,
      title: "Confirm Bridge Creation",
      message: `Create a new Blood Bridge for "${patientName}"? This will update the patient's status.`,
      onConfirm: () => executeApiAction(() => apiClient.post(`/api/admin/patients/${patientId}/create-bridge`)),
    });
  }, [executeApiAction]);

  const handleCloseEmergency = useCallback((requestId, patientName) => {
    setDialog({
      open: true,
      title: "Confirm Close Request",
      message: `Close emergency request for "${patientName}"? This action cannot be undone.`,
      onConfirm: () => executeApiAction(() => apiClient.post(`/api/admin/emergencies/${requestId}/close`)),
    });
  }, [executeApiAction]);

  // --- Choose current tab data ---
  const activeData = useMemo(() => (tabValue === 0 ? patients : emergencies), [tabValue, patients, emergencies]);
  const dataKeyMap = useMemo(() => (
    tabValue === 0
      ? { name: "name", detail: "city", icon: <LocationCity /> }
      : { name: "patient_name", detail: "status", icon: null }
  ), [tabValue]);

  // --- Cards (for mobile view) ---
  const RenderCardGrid = ({ items }) => (
    <Box sx={{ display: "grid", gap: 2, gridTemplateColumns: { xs: "1fr", sm: "repeat(2, 1fr)", md: "repeat(3, 1fr)" } }}>
      {items.map((item) => (
        <Card key={item.id} variant="outlined" sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
          <CardContent sx={{ flexGrow: 1 }}>
            <Typography variant="h6" gutterBottom noWrap title={item[dataKeyMap.name] ?? ""}>
              {item[dataKeyMap.name] ?? "—"}
            </Typography>
            <Stack direction="column" spacing={1}>
              <Chip icon={<Bloodtype />} label={`Blood Group: ${item.blood_group ?? "N/A"}`} size="small" />
              <Chip icon={dataKeyMap.icon} label={`${dataKeyMap.detail}: ${item[dataKeyMap.detail] ?? "N/A"}`} size="small" />
            </Stack>
          </CardContent>
          <CardActions sx={{ justifyContent: "flex-end" }}>
            {tabValue === 0 ? (
              <Button variant="contained" size="small" startIcon={<AddLink />} onClick={() => handleCreateBridge(item.id, item.name)}>Create Bridge</Button>
            ) : (
              <Button variant="contained" color="secondary" size="small" startIcon={<Close />} onClick={() => handleCloseEmergency(item.id, item.patient_name)}>Close Request</Button>
            )}
          </CardActions>
        </Card>
      ))}
    </Box>
  );

  // --- Table (for desktop view) ---
  const RenderTable = ({ items }) => (
    <TableContainer component={Paper} variant="outlined">
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>Name</TableCell>
            <TableCell>{tabValue === 0 ? "City" : "Status"}</TableCell>
            <TableCell>Blood Group</TableCell>
            <TableCell align="right">Action</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {items.map((item) => (
            <TableRow key={item.id}>
              <TableCell>{item[dataKeyMap.name] ?? "—"}</TableCell>
              <TableCell>{item[dataKeyMap.detail] ?? "—"}</TableCell>
              <TableCell>{item.blood_group ?? "N/A"}</TableCell>
              <TableCell align="right">
                {tabValue === 0 ? (
                  <Button size="small" startIcon={<AddLink />} onClick={() => handleCreateBridge(item.id, item.name)}>Create Bridge</Button>
                ) : (
                  <Button size="small" color="secondary" startIcon={<Close />} onClick={() => handleCloseEmergency(item.id, item.patient_name)}>Close</Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );

  // --- Decide content rendering ---
  const renderContent = () => {
    if (loading && !stats) {
      return <Box sx={{ display: "flex", justifyContent: "center", p: 4 }}><CircularProgress /></Box>;
    }
    if (!activeData || activeData.length === 0) {
      return <Typography sx={{ p: 3, textAlign: "center" }}>No data available for this view.</Typography>;
    }
    return isSmallScreen ? <RenderCardGrid items={activeData} /> : <RenderTable items={activeData} />;
  };

  return (
    <Box sx={{ flexGrow: 1, backgroundColor: theme.palette.background.default, minHeight: "100vh" }}>
      {/* --- Header --- */}
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>🩸 BloodBridge AI</Typography>
          <Button color="inherit" onClick={logout} startIcon={<Logout />}>Logout</Button>
        </Toolbar>
      </AppBar>

      {/* --- Body --- */}
      <Container sx={{ py: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>Admin Dashboard</Typography>

        {error && <Alert severity="warning" sx={{ mb: 2 }}>{error}</Alert>}

        {/* --- Stat Cards --- */}
        {stats && (
          <Box sx={{ display: "grid", gap: 3, mb: 4, gridTemplateColumns: { xs: "1fr", sm: "repeat(2, 1fr)", md: "repeat(4, 1fr)" } }}>
            <StatCard title="Total Donors" value={stats.total_donors ?? 0} icon={<PeopleAlt />} color="primary.main" />
            <StatCard title="Active Donors" value={stats.active_donors ?? 0} icon={<Favorite />} color="success.main" />
            <StatCard title="Pending Patients" value={stats.pending_patients ?? 0} icon={<Healing />} color="info.main" />
            <StatCard title="Patients at Risk" value={stats.patients_at_risk ?? 0} icon={<Warning />} color="error.main" />
          </Box>
        )}

        {/* --- Main Grid (Patients/Emergencies + Blood Groups Chart) --- */}
        <Box sx={{ display: "grid", gap: 3, gridTemplateColumns: { xs: "1fr", lg: "2fr 1fr" }, alignItems: "start" }}>
          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Box sx={{ borderBottom: 1, borderColor: "divider" }}>
              <Tabs value={tabValue} onChange={handleTabChange}>
                <Tab label="Patients" />
                <Tab label="Emergencies" />
              </Tabs>
            </Box>
            <TabPanel value={tabValue} index={0}>{renderContent()}</TabPanel>
            <TabPanel value={tabValue} index={1}>{renderContent()}</TabPanel>
          </Paper>

          <Paper elevation={2} sx={{ p: { xs: 2, md: 3 } }}>
            <Typography variant="h6" gutterBottom>Donor Blood Groups</Typography>
            <Box sx={{ minHeight: 320 }}><BloodGroupChart data={bloodGroupData} /></Box>
          </Paper>
        </Box>
      </Container>

      {/* --- Confirmation Dialog --- */}
      <ConfirmationDialog
        open={dialog.open}
        onClose={() => setDialog({ ...dialog, open: false })}
        onConfirm={dialog.onConfirm}
        title={dialog.title}
        message={dialog.message}
      />
    </Box>
  );
};

export default DashboardPage;

```

`admin-dashboard/src/pages/LoginPage.jsx`

```javascript
// admin-dashboard/src/pages/LoginPage.jsx
import React, { useState } from 'react';
import { Button, TextField, Container, Typography, Box, Alert, CircularProgress } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth.js';
import apiClient from '../api/apiClient.js';

const LoginPage = () => {
  const { login } = useAuth();
  const navigate = useNavigate();

  const [phone, setPhone] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleLogin = async (event) => {
    event.preventDefault();
    setError('');

    // Validate phone number
    if (!/^\+91\d{10}$/.test(phone)) {
      setError('Please enter a valid phone number with +91 (e.g., +918000000000).');
      return;
    }

    setLoading(true);
    try {
      console.log('Attempting login with:', { phone, password });

      const response = await apiClient.post('/api/admin/login', { phone, password });

      if (response.data?.token) {
        console.log('Login successful, token:', response.data.token);
        localStorage.setItem('token', response.data.token);
        login(response.data.token);
        navigate('/dashboard');
      } else {
        setError('Login failed: No token received from server.');
      }
    } catch (err) {
      console.error('Login error:', {
        message: err.message,
        status: err.response?.status,
        data: err.response?.data,
      });

      if (err.code === 'ECONNABORTED') {
        setError('Request timed out. Is the backend running on http://localhost:3001?');
      } else if (err.response?.status === 401) {
        setError('Invalid phone number or password.');
      } else if (err.response?.status === 500) {
        setError('Server error. Check backend logs for details.');
      } else {
        setError(err.response?.data?.message || 'Network error. Please try again.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box sx={{ mt: 8, display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
        <Typography component="h1" variant="h5">
          🩸 BloodBridge AI Admin
        </Typography>
        <Box component="form" onSubmit={handleLogin} sx={{ mt: 3 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="phone"
            label="Phone Number"
            name="phone"
            autoComplete="tel"
            autoFocus
            placeholder="+918000000000"
            value={phone}
            onChange={(e) => setPhone(e.target.value)}
          />
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="current-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          {error && <Alert severity="error" sx={{ mt: 2, width: '100%' }}>{error}</Alert>}
          <Button
            type="submit"
            fullWidth
            variant="contained"
            disabled={loading}
            sx={{ mt: 3, mb: 2 }}
          >
            {loading ? (
              <>
                <CircularProgress size={24} color="inherit" sx={{ mr: 1 }} />
                Signing In...
              </>
            ) : 'Sign In'}
          </Button>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginPage;

```

`admin-dashboard/src/theme.js`

```javascript
// src/theme.js

import { createTheme } from '@mui/material/styles';

/**
 * This file defines the custom color palette and theme for the application.
 * It uses Material-UI's createTheme function to ensure consistency
 * across all components.
 */
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // A strong, professional blue
    },
    secondary: {
      main: '#d32f2f', // A clear, attention-grabbing red
    },
    background: {
      default: '#f4f6f8', // A very light grey for the background
      paper: '#ffffff', // White for surfaces like cards and tables
    },
  },
  typography: {
    fontFamily: 'Roboto, Arial, sans-serif',
    h5: {
      fontWeight: 600,
    },
  },
});

export default theme;

```

`admin-dashboard/vite.config.js`

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

`backend/.env`

```
# backend/.env

# Server Configuration
PORT=3001

# --- SECURITY ---
# IMPORTANT: Replace this with a long, random, and secret string!
# You can generate one at https://www.uuidgenerator.net/
JWT_SECRET="eb4db4a414678902613083784a04ec9de45570856d8ced1dbe6fdd4a545ff715"

# --- DATABASE ---
# Get this from your Supabase project settings (Database -> Connection string -> URI)
DATABASE_URL="postgresql://postgres:asdfusahdfuu3842r7gdsfh@db.psussvygzgzkkwdjqbwp.supabase.co:5432/postgres"

# --- THIRD-PARTY APIs ---
GEMINI_API_KEY="AIzaSyAqhJPcovJUpv6M9u_jRTefTQ7VvwuPCm0"
ML_SERVICE_URL="http://localhost:8000" # URL for the Python ML service we will build later

# --- WHATSAPP (for later) ---
WHATSAPP_TOKEN="EAAY5EGe8MHkBPRCH1W6vrdF1MRvIDnP4IfzaVyGDWm7mHOaWKUJfWfBjjj4B2jrZCSudfSvxDdT8rBquvSYoDwZCxQxgKgzktlJyzGWwXSiHaSKene42wkVRWC2TA1FZCrR2ehAHCB6tgnZCmYDpBPJ4zzXSnM5Qh4z8c91ZCVZC96n6uLZBDhGRFfNKHLMZBYWiWYudt2oGGdbl3fRgi3c6WoDKNehuTrx1GPZCgMT3MDABS"
WHATSAPP_PHONE_NUMBER_ID="729824143554882"
WHATSAPP_APP_SECRET="e94bd0c1a5619ee68b105222b0185dc6"
WHATSAPP_VERIFY_TOKEN="inquilab_bloodai-123-2025-hackathon"

# --- DEMO & ADMIN ---
ADMIN_DEMO_PHONE="+918000000000"
DEMO_VERIFIED_PHONE_NUMBERS=""

```

`backend/server.js`

```javascript

// backend/server.js

// Import required dependencies
import express from 'express'; // Express framework for building the server
import cors from 'cors'; // Middleware for enabling CORS
import morgan from 'morgan'; // Middleware for request logging
import config from './src/config/config.js'; // Configuration settings (e.g., WHATSAPP_TOKEN)
import adminRoutes from './src/routes/adminRoutes.js'; // Admin dashboard routes
import { verifyWebhook } from './src/middleware/verifyWebhook.js'; // Webhook signature verification middleware (named import)
import webhookController from './src/controllers/webhookController.js'; // Webhook handling controller

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3001; // Use environment PORT or default to 3001

// Middleware setup
app.use(cors()); // Enable CORS for all routes
app.use(morgan('tiny')); // Log HTTP requests in 'tiny' format

// Note: No global body parser; using per-route body parsing for security and compatibility

// API and Health Routes
app.get('/health', (req, res) => {
  // Health check endpoint to verify server status
  res.status(200).json({ status: 'healthy', now: new Date().toISOString() });
});

// Admin routes with JSON body parser
app.use('/api/admin', express.json({ limit: '1mb' }), adminRoutes);

// Webhook Routes
app.get('/webhook', webhookController.verifyToken); // Handle Meta webhook verification (GET)

app.post(
  '/webhook',
  express.raw({ type: 'application/json' }), // Parse webhook body as raw Buffer for signature verification
  (req, res, next) => {
    // Store raw body buffer for verifyWebhook middleware
    req.rawBodyBuffer = req.body;
    next();
  },
  verifyWebhook, // Verify webhook signature for POST requests
  webhookController.handleMessage // Process incoming WhatsApp messages
);

// Global Error Handling
app.use((err, req, res, next) => {
  // Handle errors from middleware or routes
  console.error('[ERROR HANDLER]', err.stack);
  res.status(500).json({ message: 'An internal server error occurred.' });
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason) => {
  console.error('Unhandled Rejection:', reason);
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
});

// Start the server
app.listen(PORT, () => {
  console.log(`✅ BloodBridge AI backend is running on port ${PORT}`);
});

```

`backend/src/config/config.js`

```javascript
// backend/src/config/config.js
import 'dotenv/config'; // Loads variables from .env into process.env

// This object maps environment variables to a clean, accessible config object.
const config = {
    port: process.env.PORT,
    jwtSecret: process.env.JWT_SECRET,
    databaseUrl: process.env.DATABASE_URL,
    geminiApiKey: process.env.GEMINI_API_KEY,
    mlServiceUrl: process.env.ML_SERVICE_URL,
    whatsappToken: process.env.WHATSAPP_TOKEN,
    whatsappPhoneNumberId: process.env.WHATSAPP_PHONE_NUMBER_ID,
    whatsappAppSecret: process.env.WHATSAPP_APP_SECRET,
    whatsappVerifyToken: process.env.WHATSAPP_VERIFY_TOKEN,
    adminDemoPhone: process.env.ADMIN_DEMO_PHONE,
    demoVerifiedPhoneNumbers: process.env.DEMO_VERIFIED_PHONE_NUMBERS
};

// This validation step ensures the application fails fast if critical secrets are missing.
// It's a crucial security and stability feature.
const requiredConfig = ['port', 'jwtSecret', 'databaseUrl'];
const missingConfig = requiredConfig.filter(key => !config[key]);

if (missingConfig.length > 0) {
    console.error(`🔴 FATAL ERROR: Missing required environment variables: ${missingConfig.join(', ')}`);
    // Exit the application with an error code.
    process.exit(1);
}

export default config;

```

`backend/src/config/db.js`

```javascript
// backend/src/config/db.js
import { Pool } from 'pg';
import config from './config.js';

/**
 * Creates a new connection pool.
 * The pool manages multiple client connections to the database,
 * reusing them to improve performance and stability.
 */
const pool = new Pool({
  connectionString: config.databaseUrl,
});

/**
 * A helper function to execute a simple query.
 * @param {string} text - The SQL query string.
 * @param {Array} params - The parameters to pass to the query.
 * @returns {Promise<QueryResult>} The result from the database.
 */
const query = (text, params) => pool.query(text, params);

// We export the entire pool so we can use it for transactions later,
// and the query function for convenience.
const db = {
  query,
  pool,
};

export default db;

```

`backend/src/controllers/adminController.js`

```javascript
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import db from '../config/db.js';
import bridgeService from '../services/bridgeService.js';

/**
 * Admin Login
 */
export const login = async (req, res) => {
  const { phone, password } = req.body;

  if (!phone || !password) {
    console.warn('Login attempt with missing credentials:', { phone, password });
    return res.status(400).json({ message: 'Phone and password are required' });
  }

  try {
    // Demo admin login (for prototype)
    if (phone === config.adminDemoPhone && password === 'admin123') {
      const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '1h' });
      console.log(`Login successful for demo admin: ${phone}`);
      return res.json({ token });
    }

    // Check if admin exists in DB
    const { rows } = await db.query(
      'SELECT * FROM users WHERE phone = $1 AND role = $2',
      [phone, 'Admin']
    );

    if (rows.length === 0) {
      console.warn('Login failed: No admin user found for phone:', phone);
      return res.status(401).json({ message: 'Invalid phone number or role' });
    }

    // Password check (⚠️ Plaintext for now, should be hashed in production)
    if (!rows[0].password || rows[0].password !== password) {
      console.warn('Login failed: Invalid password for phone:', phone);
      return res.status(401).json({ message: 'Invalid password' });
    }

    // Issue token
    const token = jwt.sign({ phone, role: 'Admin' }, config.jwtSecret, { expiresIn: '8h' });
    console.log(`Login successful for user: ${phone}`);
    return res.json({ token });

  } catch (err) {
    console.error('Login error:', { error: err.message, phone });
    return res.status(500).json({ message: 'Server error during login' });
  }
};


/**
 * Create a Blood Bridge for a Patient
 */
export const createBridgeForPatient = async (req, res) => {
  const { patientId } = req.params;

  try {
    const { rows: [patient] } = await db.query(
      'SELECT * FROM patients WHERE id = $1',
      [patientId]
    );

    if (!patient) {
      return res.status(404).json({ message: 'Patient not found' });
    }

    if (patient.status === 'bridged') {
      return res.status(400).json({ message: 'Patient already has a bridge.' });
    }

    // Insert new bridge
    const { rows: [bridge] } = await db.query(
      'INSERT INTO blood_bridges (patient_id, name, blood_group, city) VALUES ($1, $2, $3, $4) RETURNING id',
      [patient.id, `${patient.name}'s Bridge`, patient.blood_group, patient.city]
    );

    // Populate bridge with donors
    const result = await bridgeService.populateNewBridge(
      bridge.id,
      patient.city,
      patient.blood_group,
      patient.pincode
    );

    // Update patient status
    await db.query(
      "UPDATE patients SET status = 'bridged' WHERE id = $1",
      [patientId]
    );

    console.log(`ADMIN ACTION: Created and populated Bridge ${bridge.id} with ${result.count} members.`);
    res.json({
      success: true,
      message: `Blood Bridge created and populated with ${result.count} top donors.`
    });

  } catch (error) {
    console.error('Error creating bridge for patient:', error);

    // Rollback patient status in case of failure
    await db.query(
      "UPDATE patients SET status = 'pending_verification' WHERE id = $1",
      [patientId]
    );

    res.status(500).json({ error: 'Failed to create and populate bridge.' });
  }
};


/**
 * Close Emergency Request
 */
export const closeEmergency = async (req, res) => {
  const { requestId } = req.params;

  try {
    await db.query(
      "UPDATE emergency_requests SET status = 'closed' WHERE id = $1",
      [requestId]
    );
    console.log(`ADMIN ACTION: Closed emergency request ${requestId}`);
    res.json({ success: true, message: 'Request successfully closed.' });
  } catch (error) {
    console.error(`Error closing emergency ${requestId}:`, error);
    res.status(500).json({ error: 'Failed to close request.' });
  }
};


/**
 * Escalate Emergency
 */
export const escalateEmergency = async (req, res) => {
  const { requestId } = req.params;
  console.log(`ADMIN ACTION: Escalating emergency ${requestId}`);
  res.json({
    success: true,
    message: `Escalation for request ${requestId} has been initiated.`
  });
};


/**
 * Resolve Inbox Message
 */
export const resolveInboxMessage = async (req, res) => {
  const { requestId } = req.params;

  try {
    await db.query(
      "UPDATE inbox_messages SET status = 'resolved', resolved_at = NOW() WHERE id = $1",
      [requestId]
    );
    console.log(`ADMIN ACTION: Resolved inbox message ${requestId}`);
    res.json({ success: true, message: 'Message marked as resolved.' });
  } catch (error) {
    console.error(`Error resolving message ${requestId}:`, error);
    res.status(500).json({ error: 'Failed to resolve message.' });
  }
};


// 📝 Other endpoints remain unchanged
export const getDashboardStats = async (req, res) => { /* ... */ };
export const getBloodGroupStats = async (req, res) => { /* ... */ };
export const getConfig = async (req, res) => { /* ... */ };
export const getActiveEmergencies = async (req, res) => { /* ... */ };
export const getBloodBridges = async (req, res) => { /* ... */ };
export const getPatients = async (req, res) => { /* ... */ };
export const getInboxMessages = async (req, res) => { /* ... */ };


```

`backend/src/controllers/webhookController.js`

```javascript

// backend/src/controllers/webhookController.js

// Import required dependencies
import config from '../config/config.js'; // Configuration settings (e.g., WHATSAPP_VERIFY_TOKEN)
import db from '../config/db.js'; // Database connection
import emergencyService from '../services/emergencyService.js'; // Emergency request handling service
import registrationService from '../services/registrationService.js'; // Donor registration service
import responseService from '../services/responseService.js'; // Donor response and OTP verification service
import patientService from '../services/patientService.js'; // Patient onboarding service
import donorPreferenceService from '../services/donorPreferenceService.js'; // Donor preferences (e.g., snooze, DND)
import aiRouterService from '../services/aiRouterService.js'; // AI message routing service
import faqService from '../services/faqService.js'; // FAQ handling service
import { normalizePhoneNumber } from '../utils/phoneHelper.js'; // Phone number normalization utility

// Handle GET requests for Meta webhook verification
const verifyToken = (req, res) => {
  // Extract query parameters for verification
  const mode = req.query['hub.mode']; // Expected: 'subscribe'
  const token = req.query['hub.verify_token']; // Token from Meta dashboard
  const challenge = req.query['hub.challenge']; // Challenge to return

  // Check if mode and token are valid and match configuration
  if (mode === 'subscribe' && token === config.whatsappVerifyToken) {
    console.log('✅ Webhook verified successfully:', { challenge }); // Log success
    return res.status(200).send(challenge); // Return challenge to confirm verification
  }

  // Log and reject invalid verification attempts
  console.warn('Webhook verification failed:', { mode, token });
  res.status(403).send('Verification failed');
};

// Process incoming WhatsApp message
const processMessage = async (messageData) => {
  // Ensure message is text type
  if (messageData.type !== 'text') {
    console.warn('Non-text message received:', messageData.type);
    return;
  }

  // Normalize sender's phone number
  const from = normalizePhoneNumber(messageData.from);
  // Get message body and lowercase for pattern matching
  const userMessage = messageData.text.body.trim();
  const lowerUserMessage = userMessage.toLowerCase();

  // Log incoming message for debugging
  console.log(`--- New Message --- From: ${from}, Message: "${userMessage}"`);

  // Handle ongoing patient onboarding first (high priority)
  const wasHandledByOnboarding = await patientService.processOnboardingReply(userMessage, from);
  if (wasHandledByOnboarding) {
    console.log('Message handled by patient onboarding');
    return; // Exit if onboarding handled the message
  }

  // Keyword-based routing for specific commands
  if (lowerUserMessage === 'apply') {
    // Start patient application
    const started = await patientService.startApplication(from);
    if (started) {
      console.log('Started patient application for:', from);
      return;
    }
  }

  // Check for 6-digit OTP (e.g., 123456)
  const otpPattern = /^\d{6}$/;
  if (otpPattern.test(userMessage)) {
    await responseService.verifyOTPAndConfirm(from, userMessage);
    console.log('Processed OTP for:', from);
    return;
  }

  // Check for donor response with short code (e.g., "YES 1234")
  const responsePatternWithCode = /^(?:'|")?\s*(YES)\s+(\d{4})\s*(?:'|")?$/i;
  const matchWithCode = userMessage.match(responsePatternWithCode);
  if (matchWithCode) {
    await responseService.handleDonorReplyWithShortCode(from, matchWithCode[2]);
    console.log('Processed donor response with code:', matchWithCode[2]);
    return;
  }

  // Handle emergency requests (e.g., "emergency blood")
  const emergencyPattern = /\b(emergency|urgent|need)\b.*?\b(blood)\b/i;
  if (emergencyPattern.test(lowerUserMessage)) {
    await emergencyService.handleEmergencyRequest(userMessage, from);
    console.log('Processed emergency request from:', from);
    return;
  }

  // Handle patient onboarding (e.g., "thalassemia support")
  const patientOnboardingPattern = /\b(thalassemia|patient|support|child|onboard)\b/i;
  if (patientOnboardingPattern.test(lowerUserMessage)) {
    await patientService.handleNewPatient(userMessage, from);
    console.log('Processed new patient request from:', from);
    return;
  }

  // Handle donor registration with details (e.g., "Register: John, Delhi, A+")
  const detailedRegPattern = /^Register:/i;
  if (detailedRegPattern.test(userMessage)) {
    const paramsStr = userMessage.substring(userMessage.indexOf(':') + 1).trim();
    const paramsArr = paramsStr.split(',').map(p => p.trim());
    if (paramsArr.length === 3) {
      const params = { name: paramsArr[0], city: paramsArr[1], blood_group: paramsArr[2] };
      await registrationService.handleNewDonor(params, from);
      console.log('Processed donor registration for:', from);
      return;
    }
  }

  // Handle simple registration trigger (e.g., "donate")
  const simpleRegPattern = /\b(donate|register|join)\b/i;
  if (simpleRegPattern.test(lowerUserMessage)) {
    await registrationService.handleNewDonor({}, from);
    console.log('Triggered donor registration flow for:', from);
    return;
  }

  // Fallback to AI router for unhandled messages
  console.log('No keyword match, routing to AI for:', from);
  const { rows: [user] } = await db.query('SELECT role FROM users WHERE phone = $1', [from]);
  const userRole = user ? user.role : 'Unregistered';
  const route = await aiRouterService.routeMessageWithContext(userMessage, userRole);

  // Process AI-determined route
  if (route && route.tool) {
    switch (route.tool) {
      case 'handle_snooze_request':
        await donorPreferenceService.handleSnooze(from, route.params);
        console.log('Processed snooze request for:', from);
        break;
      case 'handle_dnd_request':
        await donorPreferenceService.handleDnd(from);
        console.log('Processed DND request for:', from);
        break;
      default:
        await faqService.handleFaq(route.params?.query || userMessage, from);
        console.log('Processed FAQ for:', from);
        break;
    }
    return;
  }

  // Final fallback to general FAQ if AI route is unclear
  console.log('AI route unclear, fallback to FAQ for:', from);
  await faqService.handleFaq(userMessage, from);
};

// Handle POST requests for WhatsApp messages
const handleMessage = async (req, res) => {
  // Send immediate 200 response to acknowledge receipt (Meta requirement)
  res.sendStatus(200);

  try {
    // Extract message from webhook payload
    const messageData = req.body.entry?.[0]?.changes?.[0]?.value?.messages?.[0];
    if (!messageData) {
      console.warn('No valid message data in webhook payload:', req.body);
      return;
    }

    // Check for duplicate messages to prevent reprocessing
    const { rows } = await db.query('SELECT 1 FROM processed_messages WHERE message_id = $1', [messageData.id]);
    if (rows.length > 0) {
      console.warn('Duplicate message ignored:', messageData.id);
      return;
    }

    // Record message ID to prevent duplicates
    await db.query('INSERT INTO processed_messages(message_id) VALUES($1)', [messageData.id]);

    // Process the message
    await processMessage(messageData);
  } catch (error) {
    // Log critical errors but don't crash the server
    console.error('CRITICAL ERROR in handleMessage:', {
      message: error.message,
      stack: error.stack,
    });
  }
};

// Export controller functions
export default {
  verifyToken,
  handleMessage,
};

```

`backend/src/middleware/authMiddleware.js`

```javascript
// backend/src/middleware/authMiddleware.js
import jwt from 'jsonwebtoken';
import config from '../config/config.js';

// ✅ The function must be declared as a constant named 'authMiddleware'
const authMiddleware = (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Authorization token is missing or malformed' });
  }

  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, config.jwtSecret);
    req.user = decoded;
    next();
  } catch (error) {
    console.error("JWT Verification Error:", error.message);
    return res.status(401).json({ message: 'Invalid or expired token' });
  }
};

// ✅ This line then exports that constant
export default authMiddleware;

```

`backend/src/middleware/checkRole.js`

```javascript
// backend/src/middleware/checkRole.js

const checkRole = (roles) => {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: 'Forbidden: No role assigned' });
    }
    const userRole = req.user.role;
    if (roles.includes(userRole)) {
      return next();
    }
    return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
  };
};

export default checkRole; // <-- CORRECTED LINE

```

`backend/src/middleware/verifyWebhook.js`

```javascript
// backend/src/middleware/verifyWebhook.js
import crypto from 'crypto';
import config from '../config/config.js';

/**
 * Middleware to verify WhatsApp webhook POST requests.
 * - Skips signature verification for GET (used by Meta for challenge verification).
 * - Validates signature for POST requests to ensure authenticity.
 */
export const verifyWebhook = (req, res, next) => {
  // ✅ Allow GET requests (Meta verification step)
  if (req.method === 'GET') {
    return next();
  }

  // ✅ Get signature from header
  const signature = req.headers['x-hub-signature-256'];
  if (!signature) {
    console.warn('Signature missing for POST webhook');
    return res.status(401).json({ message: 'Signature missing' });
  }

  // ✅ Create HMAC from request body
  const body = JSON.stringify(req.body);
  const hmac = crypto.createHmac('sha256', config.whatsappAppSecret);
  hmac.update(body);
  const expectedSignature = `sha256=${hmac.digest('hex')}`;

  // ✅ Compare provided signature with expected signature
  if (signature !== expectedSignature) {
    console.warn('Signature mismatch for POST webhook');
    return res.status(401).json({ message: 'Invalid signature' });
  }

  // ✅ Proceed if valid
  next();
};

```

`backend/src/routes/adminRoutes.js`

```javascript
// backend/src/routes/adminRoutes.js
import express from 'express';
import * as adminController from '../controllers/adminController.js';
import authMiddleware from '../middleware/authMiddleware.js';
import checkRole from '../middleware/checkRole.js';

const router = express.Router();

// Public (no auth needed)
router.post('/login', adminController.login);

// All routes below this require auth
router.use(authMiddleware);

// ✅ UNCOMMENTED to make all GET endpoints live
router.get('/config', checkRole(['Admin']), adminController.getConfig);
router.get('/stats', checkRole(['Admin']), adminController.getDashboardStats);
router.get('/stats/blood-groups', checkRole(['Admin']), adminController.getBloodGroupStats);
router.get('/patients', checkRole(['Admin']), adminController.getPatients);
router.get('/emergencies', checkRole(['Admin']), adminController.getActiveEmergencies);
router.get('/bridges', checkRole(['Admin']), adminController.getBloodBridges);
router.get('/inbox', checkRole(['Admin']), adminController.getInboxMessages);

// Actions
router.post('/patients/:patientId/create-bridge', checkRole(['Admin']), adminController.createBridgeForPatient);
router.post('/emergencies/:requestId/close', checkRole(['Admin']), adminController.closeEmergency);
router.post('/emergencies/:requestId/escalate', checkRole(['Admin']), adminController.escalateEmergency);
router.post('/inbox/:messageId/resolve', checkRole(['Admin']), adminController.resolveInboxMessage);

export default router;

```

`backend/src/services/aiRouterService.js`

```javascript
// backend/src/services/aiRouterService.js
import { GoogleGenerativeAI } from '@google/generative-ai';
import { TOOL_DEFINITIONS } from './aiTools.js';
import config from '../config/config.js';

/**
 * This service acts as the central "brain" for the chatbot.
 * It takes a user's message and uses the Gemini AI with function-calling
 * to determine the user's intent and extract relevant information.
 */
class AIRouterService {
  constructor() {
    if (!config.geminiApiKey) {
      throw new Error("GEMINI_API_KEY is not set in the environment variables."); //
    }
    this.genAI = new GoogleGenerativeAI(config.geminiApiKey); //
    this.model = this.genAI.getGenerativeModel({
      model: 'gemini-1.5-flash-latest',
      tools: { functionDeclarations: TOOL_DEFINITIONS } //
    });
  }

  /**
   * Routes a user's message to the appropriate tool using the AI model.
   * @param {string} userMessage - The message from the user.
   * @param {string} userRole - The role of the user (e.g., 'Admin', 'Unregistered').
   * @returns {Promise<{tool: string, params: object}|null>} The decided tool and its parameters, or null if no tool is called.
   */
  async routeMessageWithContext(userMessage, userRole) {
    const systemPrompt = `You are "Bridge AI" 🌉, an operational AI assistant. Your primary goal is to understand the user's message and call the appropriate function. The user's role is "${userRole}". Prioritize action-oriented tasks.`; //
    
    const chatHistory = [
        { role: "user", parts: [{ text: systemPrompt }] },
        { role: "model", parts: [{ text: "Understood. Ready to assist." }] }, //
    ];
    
    try {
      const chat = this.model.startChat({ history: chatHistory }); //
      const result = await chat.sendMessage(userMessage); //
      const call = result.response.functionCalls()?.[0];
      
      if (call) {
        console.log(`AI decided to call tool: ${call.name} with params:`, call.args);
        return { tool: call.name, params: call.args }; //
      }
      console.log("AI did not call a specific tool for this message.");
      return null;

    } catch (error) {
      console.error('Error routing message with Gemini:', error.message); //
      return null;
    }
  }
}

// Export a single instance of the class
export default new AIRouterService();

```

`backend/src/services/aiTools.js`

```javascript
// backend/src/services/aiTools.js

/**
 * TOOL_DEFINITIONS is a manifest of functions the Gemini AI can call.
 * The descriptions are critical, as they tell the AI *when* to use each tool.
 */
export const TOOL_DEFINITIONS = [
  {
    name: 'handle_emergency_request',
    description: `Use for any urgent blood request. The Blood Warriors Foundation specializes in rapid response, especially for Thalassemia patients, leveraging our network of over 4,443 registered donors. Emergencies for Thalassemia patients should be given the highest priority as they are central to our mission.`, //
    parameters: {
      type: 'object',
      properties: {
        patient_name: { type: 'string', description: 'Name of the patient needing blood. If not mentioned, use "Unknown".' }, //
        blood_group: { type: 'string', description: 'The blood group needed, like A+, O-, AB+.' }, //
        units_needed: { type: 'integer', description: 'The number of units of blood required. Default to 1.' }, //
        hospital_name: { type: 'string', description: 'The name of the hospital. We have partnerships with over 50 hospitals.' }, //
        city: { type: 'string', description: 'The city where the hospital is located. Our strongest presence is in Hyderabad.' } //
      },
      required: ['blood_group', 'city']
    }
  },
  {
    name: 'handle_donor_registration',
    description: `This is the primary tool for onboarding new users and is a TOP PRIORITY. Use this for ANY message where the user expresses the INTENT or GOAL of becoming a blood donor. This is the correct tool for phrases like "I want to donate blood", "register me as a donor", "I want to be a blood warrior", "sign me up", "how can I donate?", or "I want to register". If the user provides details, capture them. If not, the function will ask for them.`, //
    parameters: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Full name of the new Blood Warrior. Default to "Unknown" if not provided.' }, //
        blood_group: { type: 'string', description: 'The blood group of the person. Default to "Unknown" if not provided.' }, //
        city: { type: 'string', description: 'The city where the donor lives. Default to "Unknown" if not provided.' } //
      },
      required: []
    }
  },
  {
    name: 'check_gamification_status',
    description: `Use when a registered donor asks about their personal status, points, or donation history. Frame the response with encouragement, acknowledging their part in our community of heroes.`, //
    parameters: {
        type: 'object',
        properties: {
            status_type: { type: 'string', enum: ['points', 'rank', 'badges', 'all'], description: 'The specific status the user is asking for.' } //
        },
        required: ['status_type']
    }
  },
  // We can add the other tools like handle_patient_onboarding, etc., here later.
];

```

`backend/src/services/bridgeService.js`

```javascript
import db from '../config/db.js';

class BridgeService {
  async populateNewBridge(bridgeId, city, bloodGroup, pincode) {
    try {
      console.log(`Populating bridge ${bridgeId} for city: ${city}, blood group: ${bloodGroup}, pincode: ${pincode}`);
      const { rows: bestDonors } = await db.query(
        'SELECT donor_id, final_score FROM find_donors_for_bridge($1, $2, $3, $4)',
        [city, bloodGroup, pincode, 5]
      );
      if (!bestDonors || bestDonors.length === 0) {
        console.warn(`No donors found for bridge ${bridgeId} with city: ${city}, blood group: ${bloodGroup}, pincode: ${pincode}`);
        return { success: true, count: 0 };
      }
      const insertQueries = bestDonors.map((donor, index) =>
        db.query(
          'INSERT INTO bridge_members(bridge_id, donor_id, position) VALUES($1, $2, $3)',
          [bridgeId, donor.donor_id, index + 1]
        )
      );
      await Promise.all(insertQueries);
      console.log(`Successfully populated bridge ${bridgeId} with ${bestDonors.length} donors`);
      return { success: true, count: bestDonors.length };
    } catch (error) {
      console.error(`Error populating bridge ${bridgeId}:`, {
        error: error.message,
        city,
        bloodGroup,
        pincode,
      });
      throw new Error(`Failed to populate bridge: ${error.message}`);
    }
  }
}

export default new BridgeService();

```

`backend/src/services/donorPreferenceService.js`

```javascript
// backend/src/services/donorPreferenceService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

class DonorPreferenceService {
  /**
   * Sets a snooze period for a donor, pausing notifications.
   * @param {string} phone - The donor's phone number.
   * @param {object} params - Parameters from the AI, e.g., { duration: 1, unit: 'week' }.
   */
  async handleSnooze(phone, params) {
    const { duration = 15, unit = 'day' } = params; // Default to 15 days if AI provides no params
    
    try {
      const interval = `${duration} ${unit}`;
      const { rows: [user] } = await db.query(
        "UPDATE users SET snooze_until = NOW() + $1::interval WHERE phone = $2 RETURNING snooze_until",
        [interval, phone]
      );

      if (user && user.snooze_until) {
        const snoozeDate = new Date(user.snooze_until).toLocaleDateString('en-IN');
        const message = `Got it. I've paused all non-critical notifications for you until ${snoozeDate}. We'll reach out again after that. Thank you for being a donor!`;
        await whatsappService.sendTextMessage(phone, message);
      }
    } catch (error) {
      console.error(`Error setting snooze for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while setting your preferences.");
    }
  }

  /**
   * Sets the Do Not Disturb (DND) status for a donor, permanently stopping notifications.
   * @param {string} phone - The donor's phone number.
   */
  async handleDnd(phone) {
    try {
      await db.query(
        "UPDATE users SET dnd_status = true, availability_status = 'unavailable' WHERE phone = $1",
        [phone]
      );
      const message = "You have been unsubscribed from all future notifications. We're sad to see you go, but we respect your decision. If you ever change your mind, just send 'Register' to sign up again.";
      await whatsappService.sendTextMessage(phone, message);
    } catch (error) {
      console.error(`Error setting DND for ${phone}:`, error);
      await whatsappService.sendTextMessage(phone, "I'm sorry, I encountered an error while updating your DND status.");
    }
  }
}

export default new DonorPreferenceService();

```

`backend/src/services/emergencyService.js`

```javascript
// backend/src/services/emergencyService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import aiRouterService from './aiRouterService.js';
import mlService from './mlService.js';
import geocodingService from './geocodingService.js';
import { getDistanceInKm } from '../utils/distanceHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class EmergencyService {
  async handleEmergencyRequest(userMessage, requesterPhone) {
    let params = {};
    const sanitizedPhone = normalizePhoneNumber(requesterPhone);

    const bloodGroupRegex = /\b([ABO]{1,2}\s*[\+-])\b/i;
    const cityRegex = /\b(hyderabad|mumbai|delhi|bangalore|chennai)\b/i;

    const bloodGroupMatch = userMessage.match(bloodGroupRegex);
    const cityMatch = userMessage.match(cityRegex);

    if (bloodGroupMatch && cityMatch) {
      console.log("Regex successfully extracted critical details.");
      params.blood_group = normalizeBloodGroup(bloodGroupMatch[0]);
      params.city = cityMatch[0].charAt(0).toUpperCase() + cityMatch[0].slice(1);
    } else {
      console.log("Regex failed. Engaging AI for detail extraction...");
      const route = await aiRouterService.routeMessageWithContext(userMessage, 'Unregistered');
      if (route && route.tool === 'handle_emergency_request' && route.params.blood_group && route.params.city) {
        console.log("AI successfully extracted details.");
        params = route.params;
      } else {
        console.log('AI also failed. Prompting user and setting conversation state.');
        await db.query(`
          UPDATE users SET conversation_state = 'awaiting_emergency_details'
          WHERE phone = $1;
        `, [sanitizedPhone]);
        const followupMessage = "I understand this is an emergency. To find a donor, please provide the patient's blood group and the city where the hospital is located.";
        await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);
        return;
      }
    }
    await this.createEmergencyRequest(params, sanitizedPhone);
  }

  async createEmergencyRequest(params, requesterPhone) {
    const { patient_name = 'Unknown', blood_group, city, hospital_name = 'Unknown' } = params;
    try {
      const coords = await geocodingService.getCoords(hospital_name, city, null);
      const shortCode = Math.floor(1000 + Math.random() * 9000).toString();
      const { rows: [request] } = await db.query(
        `INSERT INTO emergency_requests (patient_name, blood_group, city, hospital_name, requested_by_phone, short_code, latitude, longitude)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *;`,
        [patient_name, normalizeBloodGroup(blood_group), city, hospital_name, requesterPhone, shortCode, coords?.latitude, coords?.longitude]
      );
      
      console.log(`Successfully created emergency request ID: ${request.id}`);
      await whatsappService.sendTextMessage(requesterPhone, `✅ Emergency request active! We are now running a hyperlocal search for the best donor for *${patient_name}*.`);
      
      this.findAndNotifyDonors(request);

    } catch (error) {
      console.error('Error creating emergency request:', error);
      await whatsappService.sendTextMessage(requesterPhone, 'We could not process your request due to a system error.');
    }
  }

  /**
   * Finds potential donors, ranks them using the ML service, and notifies the best match.
   */
  async findAndNotifyDonors(request) {
    const { id: requestId, blood_group, city, requested_by_phone, latitude: hospitalLat, longitude: hospitalLon } = request;
    
    let topScoredDonors = await this.findAndRankGeneralDonors(blood_group, city, []);

    if (topScoredDonors.length === 0) {
      await whatsappService.sendTextMessage(requested_by_phone, '⚠️ We searched our network but could not find any available donors at this moment.');
      return;
    }

    if (hospitalLat && hospitalLon) {
        topScoredDonors.forEach(donor => {
            donor.distance = donor.latitude ? getDistanceInKm(hospitalLat, hospitalLon, donor.latitude, donor.longitude) : Infinity;
        });
        topScoredDonors.sort((a, b) => a.distance - b.distance);
    }

    const bestDonor = topScoredDonors[0];
    const notificationMessage = `🚨 URGENT: You are a top-ranked match!\n\nPatient *${request.patient_name}* needs your help (${request.blood_group}) at ${request.hospital_name}.\n\nReply *YES ${request.short_code}* to help.`;
    
    await whatsappService.sendTextMessage(bestDonor.phone, notificationMessage);
    await db.query('UPDATE users SET notifications_received = notifications_received + 1 WHERE id = $1', [bestDonor.id]);
    
    let adminMessage = `✅ Hyperlocal search complete. Notifying the best match: *${bestDonor.name}* (Score: ${bestDonor.final_score.toFixed(1)}, Dist: ${bestDonor.distance ? bestDonor.distance.toFixed(1) + ' km' : 'N/A'}).`;
    await whatsappService.sendTextMessage(requested_by_phone, adminMessage);
  }

  /**
   * Helper to find and score donors via the ML service.
   */
  async findAndRankGeneralDonors(bloodGroup, city, excludedDonorIds = []) {
    const { rows: availableDonors } = await db.query(
      `SELECT id, name, phone, last_donation, notifications_received, donations_confirmed, streak_count, latitude, longitude
       FROM users
       WHERE user_type = 'donor' AND blood_group = $1 AND city ILIKE $2
         AND availability_status = 'available' AND dnd_status = false
         AND (snooze_until IS NULL OR snooze_until < NOW())
         AND id NOT IN (SELECT unnest($3::uuid[]))
       LIMIT 50;`, [normalizeBloodGroup(bloodGroup), city, excludedDonorIds]
    );

    if (!availableDonors || availableDonors.length === 0) return [];
    
    const scoringPromises = availableDonors.map(donor => mlService.scoreSingleDonor(donor));
    const results = await Promise.allSettled(scoringPromises);

    const scoredDonors = availableDonors.map((donor, index) => {
        const score = results[index].status === 'fulfilled' ? results[index].value.final_score : 0;
        return { ...donor, final_score: score };
    });

    scoredDonors.sort((a, b) => b.final_score - a.final_score);
    return scoredDonors.slice(0, 5);
  }
}

export default new EmergencyService();

```

`backend/src/services/faqService.js`

```javascript
// backend/src/services/faqService.js
import { GoogleGenerativeAI } from '@google/generative-ai';
import db from '../config/db.js';
import config from '../config/config.js';
import whatsappService from './whatsappService.js';

// Initialize the Generative AI client
const genAI = new GoogleGenerativeAI(config.geminiApiKey);
const generativeModel = genAI.getGenerativeModel({ model: 'gemini-1.5-flash-latest' });

const SENSITIVE_KEYWORDS = ['problem', 'pain', 'issue', 'bad', 'reaction', 'scared', 'help me', 'confused', 'afraid'];

class FaqService {
  /**
   * Handles general user questions by generating a response from the AI model.
   * It enriches the AI's context with live data from our database.
   */
  async handleFaq(query, phone) {
    console.log(`Getting smart, generative FAQ answer for: "${query}"`);
    const disclaimer = "\n\n_Disclaimer: I am an AI assistant. This is not medical advice. Please consult a doctor for any health concerns._";
    try {
      let contextString = 'You are a helpful and compassionate assistant for BloodBridge AI, a blood donation NGO. Answer the user\'s question concisely and warmly.';
      const lowerQuery = query.toLowerCase();
      
      // --- Context Injection ---
      // Before calling the AI, we fetch live stats to make its answer more relevant.
      if (lowerQuery.includes('patient')) {
        const { rows } = await db.query("SELECT COUNT(*) as count FROM patients WHERE status = 'bridged'");
        contextString += ` IMPORTANT: Use this live statistic in your answer: We are currently supporting ${rows[0].count} long-term patients.`;
      } else if (lowerQuery.includes('donor')) {
        const { rows } = await db.query("SELECT COUNT(*) as count FROM users WHERE user_type = 'donor' AND availability_status = 'available'");
        contextString += ` IMPORTANT: Use this live statistic in your answer: We have ${rows[0].count} active and eligible donors.`;
      }

      const prompt = `${contextString}\n\nUser's Question: "${query}"`;
      
      const result = await generativeModel.generateContent(prompt);
      const response = await result.response;
      const aiText = response.text();
      let answer = aiText + disclaimer;
      await whatsappService.sendTextMessage(phone, answer);

      // --- Sensitive Keyword Escalation ---
      // If the query seems sensitive, create an inbox message for an admin to review.
      if (SENSITIVE_KEYWORDS.some(keyword => lowerQuery.includes(keyword))) {
        console.log(`Sensitive keyword detected. Escalating to admin inbox...`);
        await db.query(
          "INSERT INTO inbox_messages (user_phone, user_message, reason) VALUES ($1, $2, $3)",
          [phone, query, 'Sensitive Keyword Detected']
        );
        const escalationMessage = "It sounds like you might have a specific concern. I have notified an NGO volunteer, and they will contact you on this number shortly.";
        setTimeout(() => {
            whatsappService.sendTextMessage(phone, escalationMessage);
        }, 1500);
      }

    } catch (error) {
      console.error("Error generating FAQ answer with Gemini:", error);
      const fallbackMessage = "Thank you for your question. An NGO volunteer will get back to you shortly.";
      await whatsappService.sendTextMessage(phone, fallbackMessage);
    }
  }
}

export default new FaqService();

```

`backend/src/services/gamificationService.js`

```javascript
// backend/src/services/gamificationService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';

// A central place to define all possible achievements in the system.
const ACHIEVEMENTS = {
  FIRST_REGISTRATION: { name: 'Community Hero', points: 50, emoji: '❤️' },
  EMERGENCY_RESPONSE: { name: 'Life Saver', points: 100, emoji: '🚨' },
};

class GamificationService {
  /**
   * Awards points for a specific event, updates the user's total,
   * logs the achievement, and notifies the user.
   * @param {string} userId - The UUID of the user.
   * @param {string} event - The key for the achievement (e.g., 'FIRST_REGISTRATION').
   * @param {string} userPhone - The user's phone number for notification.
   */
  async awardPoints(userId, event, userPhone) {
    const achievement = ACHIEVEMENTS[event];
    if (!achievement) return; // If the event doesn't exist, do nothing.

    try {
      // Add points to the user's total score.
      const { rows: [user] } = await db.query(
        "UPDATE users SET gamification_points = gamification_points + $1 WHERE id = $2 RETURNING gamification_points",
        [achievement.points, userId]
      );

      if (!user) throw new Error("User not found or update failed.");

      // Log this specific achievement in the achievements table.
      await db.query(
        "INSERT INTO achievements(user_id, badge_type, points_awarded) VALUES($1, $2, $3)",
        [userId, achievement.name, achievement.points]
      );

      // Send a notification to the user.
      const notification = `🏆 Achievement Unlocked! 🏆\n\nYou've earned the *${achievement.name}* badge ${achievement.emoji} and received *${achievement.points} points*!\n\nYour new total is *${user.gamification_points} points*.`;
      await whatsappService.sendTextMessage(userPhone, notification);
    } catch (error) {
      console.error(`Error in awardPoints for user ${userId}:`, error);
    }
  }

  // We can add the getDonorStatus function here later.
}

export default new GamificationService();

```

`backend/src/services/geocodingService.js`

```javascript
// backend/src/services/geocodingService.js
import axios from 'axios';

class GeocodingService {
    async getCoords(address, city, pincode) {
        if (!address && !pincode) return null;
        const query = `${address || ''}, ${city || ''}, ${pincode || ''}`;
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
        try {
            const response = await axios.get(url, {
                headers: { 'User-Agent': 'BloodBridgeAI/1.0 (tech@bloodbridge.org)' }
            });
            if (response.data && response.data.length > 0) {
                const { lat, lon } = response.data[0];
                return { latitude: parseFloat(lat), longitude: parseFloat(lon) };
            }
            return null;
        } catch (error) {
            console.error('Error calling Geocoding API:', error.message);
            return null;
        }
    }
}

export default new GeocodingService();

```

`backend/src/services/mlService.js`

```javascript
// backend/src/services/mlService.js
import axios from 'axios';
import db from '../config/db.js';
import config from '../config/config.js';

const CACHE_DURATION_HOURS = 6;

class MLService {
    constructor() {
        this.client = axios.create({
            baseURL: config.mlServiceUrl,
            timeout: 8000,
        });
    }

    /**
     * Scores a single donor, using a cached score if available and not stale.
     */
    async scoreSingleDonor(donor) {
        // Check for a fresh score in the cache first.
        const { rows: [cachedData] } = await db.query(
            "SELECT last_ml_score, score_cached_at FROM users WHERE id = $1",
            [donor.id]
        );

        if (cachedData && cachedData.last_ml_score && cachedData.score_cached_at) {
            const cacheAgeHours = (new Date() - new Date(cachedData.score_cached_at)) / (1000 * 60 * 60);
            if (cacheAgeHours < CACHE_DURATION_HOURS) {
                console.log(`CACHE HIT: Using cached score for donor ${donor.id}`);
                return { final_score: cachedData.last_ml_score };
            }
        }

        console.log(`CACHE MISS: Calling ML service for donor ${donor.id}`);
        try {
            // If no fresh cache, call the Python ML service.
            const response = await this.client.post('/score-donor', {
                donor_id: donor.id,
                last_donation_date: donor.last_donation,
                streak_count: donor.streak_count || 0,
                notifications_received: donor.notifications_received || 0,
                donations_confirmed: donor.donations_confirmed || 0
            });
            
            const newScore = response.data.final_score;

            // Update the cache in the database with the new score.
            db.query(
                "UPDATE users SET last_ml_score = $1, score_cached_at = NOW() WHERE id = $2",
                [newScore, donor.id]
            ).catch(err => console.error(`Failed to cache ML score for donor ${donor.id}:`, err));

            return { final_score: newScore };

        } catch (error) {
            console.error(`🔴 ML Service Error for donor ${donor.id}:`, error.message);
            throw error; // Re-throw the error to be handled by the calling service.
        }
    }
}

export default new MLService();

```

`backend/src/services/patientService.js`

```javascript
// backend/src/services/patientService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import aiRouterService from './aiRouterService.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';

class PatientService {
  /**
   * Handles the initial message from a potential patient.
   * Uses AI to pre-fill an application or starts a conversation.
   */
  async handleNewPatient(userMessage, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingUser] } = await db.query("SELECT id FROM users WHERE phone = $1", [sanitizedPhone]);
      if (existingUser) {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back! Our records show you are already registered. An admin will be in touch shortly.`);
        return;
      }

      // Use the AI to attempt to extract details from the first message.
      const route = await aiRouterService.routeMessageWithContext(userMessage, 'Unregistered');
      
      let patientName = 'Awaiting Input';
      let bloodGroup = 'N/A';
      let city = 'N/A';

      if (route && route.tool === 'handle_patient_onboarding' && route.params.patient_name) {
          patientName = route.params.patient_name;
          bloodGroup = normalizeBloodGroup(route.params.blood_group) || 'N/A';
          city = route.params.city || 'N/A';
      }
      
      // Use a transaction to create both a 'user' and a 'patient' record.
      const client = await db.pool.connect();
      try {
        await client.query('BEGIN');
        const { rows: [newUser] } = await client.query(
            `INSERT INTO users (name, phone, blood_group, city, role, user_type)
             VALUES ($1, $2, $3, $4, 'Patient', 'patient') RETURNING id;`,
            [patientName, sanitizedPhone, bloodGroup, city]
        );
        const { rows: [newPatient] } = await client.query(
            `INSERT INTO patients (user_id, name, phone, blood_group, city, status)
             VALUES ($1, $2, $3, $4, $5, 'pending_opt_in') RETURNING id;`,
            [newUser.id, patientName, sanitizedPhone, bloodGroup, city]
        );
        await client.query('COMMIT');
        
        console.log(`New patient lead logged. User ID: ${newUser.id}, Patient ID: ${newPatient.id}`);
        
        if (patientName !== 'Awaiting Input') {
            await db.query("UPDATE patients SET status = 'pending_verification' WHERE id = $1", [newPatient.id]);
            await whatsappService.sendTextMessage(sanitizedPhone, `Thank you! We have pre-filled your application for *${patientName}*. An admin will contact you shortly to verify.`);
        } else {
            await whatsappService.sendTextMessage(sanitizedPhone, `Thank you for reaching out. To begin your application for our Blood Bridge support program, please reply with: *APPLY*`);
        }
      } catch (e) {
        await client.query('ROLLBACK');
        throw e;
      } finally {
        client.release();
      }
    } catch (error) {
      console.error('Error in handleNewPatient:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'Sorry, we encountered an error logging your request.');
    }
  }
  
  /**
   * Starts the conversational form after the user replies "APPLY".
   */
  async startApplication(phone) {
      const { rows: [patient] } = await db.query("SELECT id FROM patients WHERE phone = $1 AND status = 'pending_opt_in'", [phone]);
      if (!patient) return false; // Not a user waiting to apply

      await db.query("UPDATE patients SET status = 'pending_details' WHERE id = $1", [patient.id]);
      await this.continueOnboarding(patient.id, phone);
      return true;
  }

  /**
   * The "state machine" that asks the next question based on what info is missing.
   */
  async continueOnboarding(patientId, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE id = $1", [patientId]);
    if (!patient) return;

    if (patient.name === 'Awaiting Input') {
      await whatsappService.sendTextMessage(phone, "Great! Let's begin.\n\nFirst, what is the patient's full name?");
      return;
    }
    if (patient.blood_group === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Thank you. What is ${patient.name}'s blood group? (e.g., O+, AB-)`);
      return;
    }
    if (patient.city === 'N/A') {
      await whatsappService.sendTextMessage(phone, `Got it. In which city does the patient receive treatment?`);
      return;
    }

    // All details are collected.
    await db.query("UPDATE patients SET status = 'pending_verification' WHERE id = $1", [patientId]);
    const finalMessage = `Thank you! We have all the initial information we need for *${patient.name}*.\n\nAn admin has been notified and will contact you on this number to verify the details.`;
    await whatsappService.sendTextMessage(phone, finalMessage);
  }

  /**
   * Processes a user's reply during the conversational form.
   */
  async processOnboardingReply(message, phone) {
    const { rows: [patient] } = await db.query("SELECT * FROM patients WHERE phone = $1 AND status = 'pending_details'", [phone]);
    if (!patient) return false; // User is not in the middle of an application.

    let columnToUpdate = null;
    let valueToUpdate = message;
    
    if (patient.name === 'Awaiting Input') columnToUpdate = 'name';
    else if (patient.blood_group === 'N/A') {
      columnToUpdate = 'blood_group';
      valueToUpdate = normalizeBloodGroup(message);
    } else if (patient.city === 'N/A') columnToUpdate = 'city';
    
    if (columnToUpdate) {
        await db.query(`UPDATE patients SET ${columnToUpdate} = $1 WHERE id = $2`, [valueToUpdate, patient.id]);
        await db.query(`UPDATE users SET ${columnToUpdate} = $1 WHERE id = $2`, [valueToUpdate, patient.user_id]);
        
        // Ask the next question after a short delay
        setTimeout(() => { this.continueOnboarding(patient.id, phone); }, 500);
        return true; // The message was handled.
    }
    return false;
  }
}

export default new PatientService();

```

`backend/src/services/registrationService.js`

```javascript
// backend/src/services/registrationService.js
import db from '../config/db.js';
import whatsappService from '../services/whatsappService.js';
import gamificationService from './gamificationService.js';
import { normalizePhoneNumber } from '../utils/phoneHelper.js';
import { normalizeBloodGroup } from '../utils/dataSanitizer.js';

class RegistrationService {
  async handleNewDonor(params, phone) {
    const sanitizedPhone = normalizePhoneNumber(phone);
    try {
      const { rows: [existingUser] } = await db.query(
        "SELECT id, name, registration_status FROM users WHERE phone = $1", 
        [sanitizedPhone]
      );
      
      if (existingUser && existingUser.registration_status === 'completed') {
        await whatsappService.sendTextMessage(sanitizedPhone, `Welcome back, ${existingUser.name}! You are already registered and ready to help.`);
        return;
      }
      
      let { name, city, blood_group } = params;

      if (name && city && blood_group) {
        const normalizedBG = normalizeBloodGroup(blood_group);
        let newUser;
        if (existingUser) { // If user existed but was 'pending'
          const { rows } = await db.query(
            // ✅ FIX: Corrected parameter index from $1 to $4
            "UPDATE users SET name = $1, city = $2, blood_group = $3, registration_status = 'completed', role = 'Emergency Donor' WHERE id = $4 RETURNING *;",
            [name, city, normalizedBG, existingUser.id]
          );
          newUser = rows[0];
        } else { // If a completely new user
          const { rows } = await db.query(
            "INSERT INTO users(name, city, blood_group, phone, user_type, registration_status, role) VALUES($1, $2, $3, $4, 'donor', 'completed', 'Emergency Donor') RETURNING *;",
            [name, city, normalizedBG, sanitizedPhone]
          );
          newUser = rows[0];
        }

        const successMessage = `✅ Registration Complete!\n\nWelcome, ${newUser.name}! You are now a registered Blood Warrior in ${city}.`;
        await whatsappService.sendTextMessage(sanitizedPhone, successMessage);
        
        gamificationService.awardPoints(newUser.id, 'FIRST_REGISTRATION', sanitizedPhone);
        return;
      }
      
      if (!existingUser) {
        await db.query(
          "INSERT INTO users(name, phone, registration_status, role) VALUES ($1, $2, 'pending', 'Unregistered')",
          ['Pending User', sanitizedPhone]
        );
      }
      
      const followupMessage = "Thank you for your interest! To complete your registration, please reply with your details in this format:\n\n*Register: [Your Name], [Your City], [Your Blood Group]*";
      await whatsappService.sendTextMessage(sanitizedPhone, followupMessage);

    } catch (error) {
      console.error('Critical error in handleNewDonor:', error);
      await whatsappService.sendTextMessage(sanitizedPhone, 'We encountered an error during registration. Please try again later.');
    }
  }
}

export default new RegistrationService();

```

`backend/src/services/responseService.js`

```javascript
// backend/src/services/responseService.js
import db from '../config/db.js';
import whatsappService from './whatsappService.js';
import { generateOTP } from '../utils/otpHelper.js';
import gamificationService from './gamificationService.js';
import bridgeService from './bridgeService.js';

class ResponseService {
    /**
     * Handles the donor's initial reply (e.g., "YES 1234").
     * It validates the code and sends back a 6-digit OTP to verify.
     */
    async handleDonorReplyWithShortCode(donorPhone, shortCode) {
        try {
            const { rows: [request] } = await db.query(`SELECT id FROM emergency_requests WHERE short_code = $1 AND status = 'active'`, [shortCode]);
            if (!request) {
                await whatsappService.sendTextMessage(donorPhone, `Sorry, we couldn't find an active request with code ${shortCode}. It may have been fulfilled.`);
                return;
            }

            const { rows: [user] } = await db.query(`SELECT id FROM users WHERE phone = $1`, [donorPhone]);
            if (!user) {
                await whatsappService.sendTextMessage(donorPhone, "We couldn't find your registration. Please register first.");
                return;
            }

            const otp = generateOTP();
            await db.query(
                `INSERT INTO donor_responses (donor_id, request_id, response, otp, otp_expires_at)
                 VALUES ($1, $2, 'pending', $3, NOW() + INTERVAL '10 minutes')
                 ON CONFLICT (donor_id, request_id) DO UPDATE SET response = 'pending', otp = $3, otp_expires_at = NOW() + INTERVAL '10 minutes';`,
                [user.id, request.id, otp]
            );

            const otpMessage = `Thank you for your quick response! To finalize your confirmation, please reply with *only* the following 6-digit code:\n\n*${otp}*`;
            await whatsappService.sendTextMessage(donorPhone, otpMessage);
        } catch (error) {
            console.error('Error in handleDonorReplyWithShortCode:', error);
            await whatsappService.sendTextMessage(donorPhone, "There was a system error processing your reply.");
        }
    }

    /**
     * Verifies the 6-digit OTP and finalizes the donation confirmation.
     * This function uses a database transaction to ensure all updates succeed or none do.
     */
    async verifyOTPAndConfirm(donorPhone, otp) {
        const client = await db.pool.connect();
        try {
            await client.query('BEGIN');

            const { rows: [response] } = await client.query(
                `SELECT dr.id, dr.request_id, u.name as donor_name, u.id as donor_id, er.patient_name, er.requested_by_phone
                 FROM donor_responses dr JOIN users u ON dr.donor_id = u.id JOIN emergency_requests er ON dr.request_id = er.id
                 WHERE u.phone = $1 AND dr.otp = $2 AND dr.otp_expires_at > NOW() AND dr.response = 'pending' FOR UPDATE;`,
                [donorPhone, otp]
            );

            if (!response) {
                await whatsappService.sendTextMessage(donorPhone, "Invalid or expired OTP. Please try the 'YES [code]' step again.");
                await client.query('ROLLBACK');
                return;
            }

            // Perform all database updates
            await client.query(`UPDATE users SET last_donation = NOW(), availability_status = 'unavailable', cooldown_until = NOW() + INTERVAL '90 days', donations_confirmed = donations_confirmed + 1, streak_count = streak_count + 1 WHERE id = $1`, [response.donor_id]);
            await client.query("UPDATE donor_responses SET response = 'accepted', confirmed_at = NOW(), otp = NULL WHERE id = $1", [response.id]);
            await client.query("UPDATE emergency_requests SET status = 'fulfilled' WHERE id = $1", [response.request_id]);
            await bridgeService.rotateMemberToBack(response.donor_id, client);

            await client.query('COMMIT');

            // Send confirmations and award points
            const donorConfirmationMessage = `✅ Confirmed! Thank you, ${response.donor_name}!\n\nYour donation for *${response.patient_name}* is confirmed. Please coordinate with the hospital. You are a true hero!`;
            await whatsappService.sendTextMessage(donorPhone, donorConfirmationMessage);

            if (response.requested_by_phone) {
                const requesterUpdate = `✅ Good News! A donor has been confirmed for your request for *${response.patient_name}*.`;
                await whatsappService.sendTextMessage(response.requested_by_phone, requesterUpdate);
            }
            gamificationService.awardPoints(response.donor_id, 'EMERGENCY_RESPONSE', donorPhone);

        } catch (error) {
            await client.query('ROLLBACK');
            console.error("Error verifying OTP:", error);
            await whatsappService.sendTextMessage(donorPhone, "A system error occurred during OTP verification.");
        } finally {
            client.release();
        }
    }

    // We can implement the handleSimpleDecline function later.
}

export default new ResponseService();

```

`backend/src/services/whatsappService.js`

```javascript
// backend/src/services/whatsappService.js
import axios from 'axios';
import config from '../config/config.js';

class WhatsAppService {
  constructor() {
    this.token = config.whatsappToken;
    this.phoneNumberId = config.whatsappPhoneNumberId;

    if (!this.token || !this.phoneNumberId) {
      console.warn('WhatsApp token or Phone Number ID are missing from configuration. Messages will not be sent.');
    }

    this.client = axios.create({
      baseURL: `https://graph.facebook.com/v18.0/${this.phoneNumberId}`,
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'Content-Type': 'application/json'
      }
    });
  }

  /**
   * Sends a text message.
   * @param {string} to - The recipient's phone number (e.g., '918000000000').
   * @param {string} text - The message body.
   */
  async sendTextMessage(to, text) {
    if (!this.token) return { success: false, error: "WhatsApp service not configured." };

    const payload = {
      messaging_product: 'whatsapp',
      to: to,
      type: 'text',
      text: { body: text }
    };
    try {
      const response = await this.client.post('/messages', payload);
      console.log(`✅ Message sent successfully to ${to}.`);
      return { success: true, data: response.data };
    } catch (error) {
      console.error(`🔴 FAILED to send message to ${to}.`);
      if (error.response) {
        console.error(`Error Details: ${error.response.data.error?.message}`);
      }
      return { success: false, error: error.message };
    }
  }
}

export default new WhatsAppService();

```

`backend/src/utils/dataSanitizer.js`

```javascript
// backend/src/utils/dataSanitizer.js
export const normalizeBloodGroup = (group) => {
  if (!group) return 'Unknown';
  const upperGroup = group.toUpperCase();
  let normalized = upperGroup.replace(/\s/g, '').replace('POSITIVE', '+').replace('NEGATIVE', '-');
  if (normalized.endsWith('POS')) normalized = normalized.replace('POS', '+');
  if (normalized.endsWith('NEG')) normalized = normalized.replace('NEG', '-');
  return normalized.slice(0, 5);
};

```

`backend/src/utils/distanceHelper.js`

```javascript
// backend/src/utils/distanceHelper.js
/**
 * Calculates distance between two lat/lng points in km using the Haversine formula.
 */
export const getDistanceInKm = (lat1, lon1, lat2, lon2) => {
    if ((lat1 == lat2) && (lon1 == lon2)) {
        return 0;
    }
    const R = 6371; // Radius of the earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        0.5 - Math.cos(dLat) / 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        (1 - Math.cos(dLon)) / 2;
    return R * 2 * Math.asin(Math.sqrt(a));
};

```

`backend/src/utils/otpHelper.js`

```javascript
// backend/src/utils/otpHelper.js

/**
 * Generates a 4-digit numeric code for donors to reply with.
 * @returns {string} A 4-digit string.
 */
export const generateShortCode = () => {
  return Math.floor(1000 + Math.random() * 9000).toString();
};

/**
 * Generates a 6-digit numeric OTP for final confirmation.
 * @returns {string} A 6-digit string.
 */
export const generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

```

`backend/src/utils/phoneHelper.js`

```javascript
// backend/src/utils/phoneHelper.js
export const normalizePhoneNumber = (phone) => {
  if (!phone || typeof phone !== 'string') return null;
  let digits = phone.replace(/\D/g, '');
  if (digits.startsWith('91') && digits.length === 12) {
    return `+${digits}`;
  } else if (digits.length === 10) {
    return `+91${digits}`;
  }
  return `+${digits}`;
};

```

`code.txt`

```

```

`db.txt`

```

-- Create users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    phone VARCHAR(15) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    password VARCHAR(255), -- For admin login
    blood_group VARCHAR(5), -- e.g., 'A+', 'O-', 'AB+'
    city VARCHAR(100),
    pincode VARCHAR(10),
    user_type VARCHAR(50) NOT NULL CHECK (user_type IN ('donor', 'patient', 'admin')),
    role VARCHAR(50) DEFAULT 'Emergency Donor',
    registration_status VARCHAR(50) DEFAULT 'completed' CHECK (registration_status IN ('pending', 'completed')),
    availability_status VARCHAR(50) DEFAULT 'available' CHECK (availability_status IN ('available', 'unavailable', 'on_hold')),
    dnd_status BOOLEAN DEFAULT false,
    snooze_until TIMESTAMPTZ,
    cooldown_until TIMESTAMPTZ,
    last_donation DATE,
    donations_till_date INTEGER DEFAULT 0 CHECK (donations_till_date >= 0),
    gamification_points INTEGER DEFAULT 0 CHECK (gamification_points >= 0),
    streak_count INTEGER DEFAULT 0 CHECK (streak_count >= 0),
    last_ml_score REAL,
    score_cached_at TIMESTAMPTZ,
    last_request_short_code VARCHAR(4),
    quiet_hours_start TIME,
    quiet_hours_end TIME,
    inactive_trigger_comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT valid_blood_group CHECK (blood_group IN ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-', 'Unknown'))
);

-- Create patients table (standalone, no user_id foreign key)
CREATE TABLE patients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    phone VARCHAR(15) NOT NULL UNIQUE,
    blood_group VARCHAR(5) NOT NULL,
    city VARCHAR(100) NOT NULL,
    pincode VARCHAR(10),
    condition TEXT, -- e.g., 'thalassemia'
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'pending_verification', 'bridged', 'active')),
    last_transfusion_date DATE,
    frequency_in_days INTEGER CHECK (frequency_in_days > 0),
    quantity_required INTEGER DEFAULT 1 CHECK (quantity_required > 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT valid_blood_group CHECK (blood_group IN ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'))
);

-- Create emergency_requests table
CREATE TABLE emergency_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    patient_name VARCHAR(255) NOT NULL,
    blood_group VARCHAR(5) NOT NULL,
    units_needed INTEGER NOT NULL CHECK (units_needed > 0),
    hospital_name VARCHAR(255) NOT NULL,
    hospital_contact VARCHAR(15),
    city VARCHAR(100) NOT NULL,
    urgency_level VARCHAR(50) DEFAULT 'high' CHECK (urgency_level IN ('critical', 'high', 'medium')),
    status VARCHAR(50) DEFAULT 'active' CHECK (status IN ('active', 'fulfilled', 'closed', 'escalated')),
    created_by UUID REFERENCES users(id) ON DELETE SET NULL,
    requested_by_phone VARCHAR(15) NOT NULL,
    short_code VARCHAR(4) UNIQUE,
    units_confirmed INTEGER DEFAULT 0 CHECK (units_confirmed >= 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    fulfilled_at TIMESTAMPTZ,
    CONSTRAINT valid_blood_group CHECK (blood_group IN ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'))
);

-- Create blood_bridges table
CREATE TABLE blood_bridges (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    patient_id UUID REFERENCES patients(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    blood_group VARCHAR(5) NOT NULL,
    city VARCHAR(100) NOT NULL,
    rotation_position INTEGER DEFAULT 1 CHECK (rotation_position >= 1),
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT valid_blood_group CHECK (blood_group IN ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-'))
);

-- Create bridge_members table
CREATE TABLE bridge_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    bridge_id UUID REFERENCES blood_bridges(id) ON DELETE CASCADE,
    donor_id UUID REFERENCES users(id) ON DELETE CASCADE,
    position INTEGER NOT NULL CHECK (position >= 0),
    status VARCHAR(50) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'skipped')),
    joined_at TIMESTAMPTZ DEFAULT NOW(),
    rotation_order INTEGER,
    UNIQUE(bridge_id, donor_id)
);

-- Create donor_responses table
CREATE TABLE donor_responses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    donor_id UUID REFERENCES users(id) ON DELETE CASCADE,
    request_id UUID REFERENCES emergency_requests(id) ON DELETE CASCADE,
    response VARCHAR(50) NOT NULL CHECK (response IN ('pending', 'accepted', 'declined')),
    otp VARCHAR(6),
    otp_expires_at TIMESTAMPTZ,
    confirmed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(donor_id, request_id)
);

-- Create inbox_messages table
CREATE TABLE inbox_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_phone VARCHAR(15) NOT NULL,
    user_message TEXT NOT NULL,
    reason VARCHAR(255) NOT NULL,
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'resolved')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    resolved_at TIMESTAMPTZ
);

-- Create processed_messages table
CREATE TABLE processed_messages (
    message_id VARCHAR(255) PRIMARY KEY,
    processed_at TIMESTAMPTZ DEFAULT NOW(),
    payload JSONB
);

-- Create achievements table
CREATE TABLE achievements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    badge_type VARCHAR(255) NOT NULL,
    points_awarded INTEGER DEFAULT 0 CHECK (points_awarded >= 0),
    earned_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create knowledge_base table
CREATE TABLE knowledge_base (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    category VARCHAR(255),
    embedding VECTOR -- Requires pgvector extension
);

-- Create schema_migrations table
CREATE TABLE schema_migrations (
    version VARCHAR(255) PRIMARY KEY,
    applied_at TIMESTAMPTZ DEFAULT NOW(),
    description TEXT
);

-- Create conversations table
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    message TEXT NOT NULL,
    response TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create optimized donor search function
CREATE OR REPLACE FUNCTION find_donors_for_bridge(
    p_city VARCHAR,
    p_blood_group VARCHAR,
    p_pincode VARCHAR,
    p_limit INTEGER
)
RETURNS TABLE (donor_id UUID, final_score FLOAT) AS $$
BEGIN
    RETURN QUERY
    SELECT
        u.id AS donor_id,
        COALESCE(u.last_ml_score, 0.0) AS final_score
    FROM users u
    WHERE
        u.user_type = 'donor'
        AND u.city ILIKE p_city
        AND u.blood_group = p_blood_group
        AND u.availability_status = 'available'
        AND u.dnd_status = false
        AND (u.snooze_until IS NULL OR u.snooze_until < NOW())
        AND u.registration_status = 'completed'
        AND u.id NOT IN (
            SELECT bm.donor_id 
            FROM bridge_members bm 
            JOIN blood_bridges bb ON bm.bridge_id = bb.id 
            WHERE bb.active = true
        )
    ORDER BY
        COALESCE(u.last_ml_score, 0.0) DESC,
        u.created_at ASC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Create indexes for performance
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_blood_group ON users(blood_group);
CREATE INDEX idx_users_city ON users(city);
CREATE INDEX idx_users_user_type ON users(user_type);
CREATE INDEX idx_patients_phone ON patients(phone);
CREATE INDEX idx_emergency_requests_short_code ON emergency_requests(short_code);
CREATE INDEX idx_bridge_members_bridge_id ON bridge_members(bridge_id);
CREATE INDEX idx_donor_responses_donor_id ON donor_responses(donor_id);
CREATE INDEX idx_knowledge_base_category ON knowledge_base(category);

-- Enable Row-Level Security (RLS)
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE patients ENABLE ROW LEVEL SECURITY;
ALTER TABLE emergency_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE blood_bridges ENABLE ROW LEVEL SECURITY;
ALTER TABLE bridge_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE donor_responses ENABLE ROW LEVEL SECURITY;
ALTER TABLE inbox_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE processed_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE knowledge_base ENABLE ROW LEVEL SECURITY;
ALTER TABLE schema_migrations ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- Insert test data
INSERT INTO users (
    name, phone, password, blood_group, city, pincode, user_type, 
    role, registration_status, availability_status
) VALUES (
    'Admin User', '+918000000000', 'admin123', NULL, NULL, NULL, 
    'admin', 'admin', 'completed', 'available'
), (
    'Test Donor', '+911234567890', NULL, 'O+', 'Hyderabad', '500001', 
    'donor', 'Emergency Donor', 'completed', 'available'
) ON CONFLICT (phone) DO NOTHING;

INSERT INTO patients (
    name, phone, blood_group, city, pincode, status
) VALUES (
    'John Doe', '+919876543210', 'A+', 'Delhi', '110001', 'pending_verification'
) ON CONFLICT (phone) DO NOTHING;

-- Insert initial schema migration
INSERT INTO schema_migrations (version, description)
VALUES ('2025082901', 'Initial schema for BloodBridge AI') ON CONFLICT (version) DO NOTHING;

-- Enable pgvector extension for knowledge_base.embedding
CREATE EXTENSION IF NOT EXISTS vector;

```

`ml_services/.env`

```
# ml_services/.env

# This should be the same database URL used in your backend/.env file.
DATABASE_URL="postgresql://postgres:asdfusahdfuu3842r7gdsfh@db.psussvygzgzkkwdjqbwp.supabase.co:5432/postgres"


```

`ml_services/main.py`

```python
# ml_services/main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
from sentence_transformers import SentenceTransformer, util
import os
import psycopg2
from dotenv import load_dotenv # <-- ADD THIS LINE

load_dotenv() # <-- AND ADD THIS LINE

# --- Configuration ---
# Caches the ML model locally to avoid re-downloading
os.environ['SENTENCE_TRANSFORMERS_HOME'] = './.cache'

print("Loading sentence-transformer model...")
MODEL_NAME = 'all-MiniLM-L6-v2'
model = SentenceTransformer(MODEL_NAME)
print("Model loaded successfully.")

# --- Pydantic Models for type validation ---
class DonorScoreRequest(BaseModel):
    donor_id: str
    last_donation_date: Optional[str] = None
    streak_count: int = 0
    notifications_received: int = 0
    donations_confirmed: int = 0

class DonorScoreResponse(BaseModel):
    donor_id: str
    availability_score: float
    reliability_score: float
    final_score: float

# --- FastAPI App ---
app = FastAPI(title="BloodBridge AI Engine")

# --- Helper Functions ---
def calculate_availability_score(last_donation_date: Optional[str]) -> float:
    if not last_donation_date:
        return 100.0
    try:
        last_date = datetime.fromisoformat(last_donation_date.replace('Z', '+00:00'))
        days_since = (datetime.now(last_date.tzinfo) - last_date).days
        if days_since >= 90: return 100.0
        if days_since < 56: return 0.0
        # Linearly scale the score between 56 and 90 days
        return round(((days_since - 56) / (90 - 56)) * 100, 2)
    except (ValueError, TypeError):
        return 100.0 # Default to available if date is invalid

def calculate_reliability_score(streak: int, notifications: int, confirmations: int) -> float:
    # Score based on donation streak (max 40 points)
    streak_score = min(streak * 10, 40)
    
    # Score based on response rate (max 60 points)
    if notifications == 0:
        response_score = 40.0 # Default score for new donors
    else:
        response_rate = confirmations / notifications
        response_score = response_rate * 60
        
    return min(streak_score + response_score, 100.0)

# --- API Endpoints ---
@app.get("/health", summary="Health Check")
async def health_check():
    return {"status": "healthy"}

@app.post("/score-donor", response_model=DonorScoreResponse, summary="Scores a single donor")
async def score_donor(request: DonorScoreRequest):
    availability = calculate_availability_score(request.last_donation_date)
    
    reliability = calculate_reliability_score(
        request.streak_count, 
        request.notifications_received, 
        request.donations_confirmed
    )
    
    # Final score is a weighted average
    final_score = (availability * 0.6) + (reliability * 0.4)
    if availability == 0:
        final_score = 0
        
    return DonorScoreResponse(
        donor_id=request.donor_id,
        availability_score=availability,
        reliability_score=reliability,
        final_score=round(final_score, 2)
    )

```

`ml_services/requirements.txt`

```
# ml_services/requirements.txt
fastapi==0.111.0
uvicorn[standard]==0.29.0
pydantic==2.7.1
sentence-transformers==2.7.0
scikit-learn==1.3.0
psycopg2-binary==2.9.9
torch==2.1.2
numpy==1.26.4
python-dotenv

```

